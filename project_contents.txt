Project Structure:
./.env
./.env.example
./.eslintrc.js
./.gitignore
./.npmrc
./.prettierrc
./downloads/Текстовый документ.txt
./launch.json
./nest-cli.json
./package.json
./prisma/schema.prisma
./public/css/styles.css
./public/fonts/GothamSSm/GothamSSm-Book.ttf
./public/fonts/GothamSSm/GothamSSm-Book.woff
./public/fonts/GothamSSm/GothamSSm-Book.woff2
./public/fonts/GothamSSm/GothamSSm-Light.eot
./public/fonts/GothamSSm/GothamSSm-Light.ttf
./public/fonts/GothamSSm/GothamSSm-Light.woff
./public/fonts/GothamSSm/GothamSSm-Light.woff2
./public/fonts/GothamSSm/GothamSSm-Medium.eot
./public/fonts/GothamSSm/GothamSSm-Medium.ttf
./public/fonts/GothamSSm/GothamSSm-Medium.woff
./public/fonts/GothamSSm/GothamSSm-Medium.woff2
./public/img/arrow.svg
./public/img/cart.svg
./public/img/favicon.ico
./public/img/home.svg
./public/img/link.svg
./public/img/menu.png
./public/img/person.svg
./public/img/route.svg
./public/img/search.svg
./public/receipts/receipt_750126398_2024-10-06_22-07.jpg
./public/receipts/receipt_750126398_2024-10-06_22-12.jpg
./public/receipts/receipt_750126398_2024-10-07_10-04.jpg
./public/receipts/receipt_750126398_2024-10-17_17-36.jpg
./public/receipts/receipt_750126398_2024-10-17_19-55.jpg
./public/receipts/receipt_750126398_2024-10-18_19-48.jpg
./public/receipts/receipt_750126398_2024-10-18_19-52.jpg
./public/receipts/receipt_750126398_2024-12-12_11-10.jpg
./public/receipts/receipt_750126398_2024-12-12_11-18.jpg
./public/receipts/receipt_750126398_2025-01-09_12-50.jpg
./public/receipts/receipt_750126398_2025-01-09_12-52.jpg
./public/receipts/receipt_750126398_2025-01-09_12-54.jpg
./public/receipts/receipt_750126398_2025-05-30_14-26.jpg
./public/receipts/receipt_750126398_2025-08-02_12-25.jpg
./src/app.constants.ts
./src/app.module.ts
./src/common/database/database.module.ts
./src/common/database/index.ts
./src/common/database/prisma.client.ts
./src/common/database/prisma.service.ts
./src/common/decorators/roles.decorator.ts
./src/common/decorators/user.decorator.ts
./src/common/decorators/zenno.decorator.ts
./src/common/helpers/hbs.helper.ts
./src/common/jwt/jwt.config.ts
./src/common/middleware/session.middleware.ts
./src/common/telegram/telegram.config.ts
./src/main.ts
./src/module/account/account.controller.ts
./src/module/account/account.module.ts
./src/module/account/account.repository.ts
./src/module/account/account.service.ts
./src/module/account/constants/error.constant.ts
./src/module/account/course.repository.ts
./src/module/account/course.service.ts
./src/module/account/deviceInfo.repository.ts
./src/module/account/deviceInfo.service.ts
./src/module/account/dto/course-account.dto.ts
./src/module/account/dto/course-status.dto.ts
./src/module/account/dto/create-account.dto.ts
./src/module/account/dto/create-deviceInfo.dto.ts
./src/module/account/dto/getAccessTokenCourse-account.dto.ts
./src/module/account/dto/isEmail-account.dto.ts
./src/module/account/dto/update-account.dto.ts
./src/module/account/dto/update-course-status-account.dto.ts
./src/module/account/dto/update-course-tokens-account.dto.ts
./src/module/account/dto/update-tokens-account.dto.ts
./src/module/account/dto/updateBonusCount-account.dto.ts
./src/module/account/dto/updateCookie-account.dto.ts
./src/module/account/dto/updateCourseStatus-course.ts
./src/module/account/dto/updateGoogleId-account.dto.ts
./src/module/account/dto/updatePushToken-account.dto.ts
./src/module/account/dto/uuid-account.dto.ts
./src/module/account/entities/account.entity.ts
./src/module/account/entities/accountUpdate.entity.ts
./src/module/account/entities/accountWithProxy.entity.ts
./src/module/account/entities/citySM.entity.ts
./src/module/account/entities/courseTokens.entity.ts
./src/module/account/entities/deviceInfo.entity.ts
./src/module/account/entities/headers.entity.ts
./src/module/account/entities/lesson.entity.ts
./src/module/account/entities/refreshTokens.entity.ts
./src/module/account/guard/zenno.guard.ts
./src/module/account/interfaces/account.interface.ts
./src/module/account/interfaces/cart.interface.ts
./src/module/account/interfaces/cookie.interface.ts
./src/module/account/interfaces/course-data.interface.ts
./src/module/account/interfaces/course-list.interface.ts
./src/module/account/interfaces/course.interface.ts
./src/module/account/interfaces/deviceInfo.interface.ts
./src/module/account/interfaces/headers.interface.ts
./src/module/account/interfaces/lesson-progress.interface.ts
./src/module/account/interfaces/order-info.interface.ts
./src/module/account/interfaces/orders.interface.ts
./src/module/account/interfaces/pickup-avability.interface.ts
./src/module/account/interfaces/promocode.interface.ts
./src/module/account/interfaces/search-product.interface.ts
./src/module/account/interfaces/short-info.interface.ts
./src/module/account/interfaces/userGateToken.interface.ts
./src/module/auth/auth.controller.ts
./src/module/auth/auth.module.ts
./src/module/auth/auth.provider.ts
./src/module/auth/auth.service.ts
./src/module/auth/constants/auth.constants.ts
./src/module/auth/dto/login.dto.ts
./src/module/auth/dto/register.dto.ts
./src/module/auth/guard/accessToken.guard.ts
./src/module/auth/guard/roles.guard.ts
./src/module/auth/strategy/access.strategy.ts
./src/module/auth/types/auth.interface.ts
./src/module/auth/types/user.context.interface.ts
./src/module/bott/bott.module.ts
./src/module/bott/bott.service.ts
./src/module/bott/decorators/wrap-with-loading.decorator.ts
./src/module/bott/headers.service.ts
./src/module/bott/interfaces/bot-t.interface.ts
./src/module/bott/interfaces/replenishment-bot-t.interface.ts
./src/module/cache/cache.keys.ts
./src/module/coupon/coupon.module.ts
./src/module/coupon/fortune-coupon.service.ts
./src/module/coupon/forune-coupon.repository.ts
./src/module/coupon/interfaces/fortune.interface.ts
./src/module/cron/cron.module.ts
./src/module/cron/cron.service.ts
./src/module/http/http.module.ts
./src/module/http/http.service.ts
./src/module/http/interfaces/http.interface.ts
./src/module/http/tls-forwarder.service.ts
./src/module/logger/index.ts
./src/module/logger/pino.service.ts
./src/module/logger/strategies/base.strategy.ts
./src/module/logger/strategies/development.strategy.ts
./src/module/logger/strategies/index.ts
./src/module/logger/strategies/production.strategy.ts
./src/module/mirror/mirror.controller.ts
./src/module/mirror/mirror.module.ts
./src/module/mirror/mirror.repository.ts
./src/module/mirror/mirror.service.ts
./src/module/order/dto/get-order-page.dto.ts
./src/module/order/order.controller.ts
./src/module/order/order.module.ts
./src/module/order/order.service.ts
./src/module/payment/constants/error.constants.ts
./src/module/payment/dto/queryFilter.dto.ts
./src/module/payment/dto/stats.query.dto.ts
./src/module/payment/dto/updateStatus.dto.ts
./src/module/payment/entities/payment.entities.ts
./src/module/payment/interfaces/payment.interface.ts
./src/module/payment/interfaces/statistic.interface.ts
./src/module/payment/payment.controller.ts
./src/module/payment/payment.module.ts
./src/module/payment/payment.repository.ts
./src/module/payment/payment.service.ts
./src/module/proxy/dto/query.dto.ts
./src/module/proxy/dto/update-proxy.dto.ts
./src/module/proxy/entities/proxy.entity.ts
./src/module/proxy/error/error.constant.ts
./src/module/proxy/interfaces/proxy.interface.ts
./src/module/proxy/proxy.controller.ts
./src/module/proxy/proxy.module.ts
./src/module/proxy/proxy.repository.ts
./src/module/proxy/proxy.service.ts
./src/module/shared/file.service.ts
./src/module/shared/shared.module.ts
./src/module/telegram/constants/admin.constant.ts
./src/module/telegram/constants/error.constant.ts
./src/module/telegram/filters/telegraf-exception.filter.ts
./src/module/telegram/interfaces/calculate.interface.ts
./src/module/telegram/interfaces/telegram.context.ts
./src/module/telegram/keyboards/base.keyboard.ts
./src/module/telegram/keyboards/calculate.keyboard.ts
./src/module/telegram/keyboards/make-order.keyboard.ts
./src/module/telegram/keyboards/payment.keyboard.ts
./src/module/telegram/keyboards/profile.keyboard.ts
./src/module/telegram/keyboards/qr-code.keyboard.ts
./src/module/telegram/pipes/isAccountId.pipe.ts
./src/module/telegram/pipes/isCity.pipe.ts
./src/module/telegram/pipes/isCode.pipe.ts
./src/module/telegram/pipes/isFio.pipe.ts
./src/module/telegram/pipes/isMoneyAmount.pipe.ts
./src/module/telegram/pipes/isPhone.pipe.ts
./src/module/telegram/pipes/isUrl.pipe.ts
./src/module/telegram/scenes/base.scene-constant.ts
./src/module/telegram/scenes/calculate.scene-constant.ts
./src/module/telegram/scenes/change-number.scene-constants.ts
./src/module/telegram/scenes/make-order.scene-constant.ts
./src/module/telegram/scenes/profile.scene-constant.ts
./src/module/telegram/telegram.module.ts
./src/module/telegram/telegram.service.ts
./src/module/telegram/updates/admin/admin.guard.ts
./src/module/telegram/updates/admin/admin.update.ts
./src/module/telegram/updates/auth-mirror/auth-mirror.update.ts
./src/module/telegram/updates/auth-mirror/seller.guard.ts
./src/module/telegram/updates/base-command/base-command.constants.ts
./src/module/telegram/updates/base-command/base-command.update.ts
./src/module/telegram/updates/calculate/calculate-settings.update.ts
./src/module/telegram/updates/calculate/calculate.repository.ts
./src/module/telegram/updates/calculate/calculate.service.ts
./src/module/telegram/updates/calculate/calculate.update.ts
./src/module/telegram/updates/change-number/change-number.update.ts
./src/module/telegram/updates/checking/checking.service.ts
./src/module/telegram/updates/checking/checking.update.ts
./src/module/telegram/updates/cookie/cookie.update.ts
./src/module/telegram/updates/email/email.service.ts
./src/module/telegram/updates/email/email.update.ts
./src/module/telegram/updates/fortune/fortune.update.ts
./src/module/telegram/updates/make-order/make-order.service.ts
./src/module/telegram/updates/make-order/make-order.update.ts
./src/module/telegram/updates/payment/payment.update.ts
./src/module/telegram/updates/profile/profile.update.ts
./src/module/telegram/updates/qr-code/back_img.png
./src/module/telegram/updates/qr-code/qr-code.service.ts
./src/module/telegram/updates/qr-code/qr-code.update.ts
./src/module/telegram/updates/start/start.update.ts
./src/module/telegram/utils/cart.utils.ts
./src/module/telegram/utils/isPhone.utils.ts
./src/module/telegram/utils/order.utils.ts
./src/module/telegram/utils/payment.utils.ts
./src/module/telegram/utils/receipt.utils.ts
./src/module/user/entities/user-telegram.entity.ts
./src/module/user/interfaces/user-telegram.interface.ts
./src/module/user/user.controller.ts
./src/module/user/user.module.ts
./src/module/user/user.repository.ts
./src/module/user/user.service.ts
./src/module/webapp/webapp.controller.ts
./src/module/webapp/webapp.module.ts
./src/module/zenno/dto/config.dto.ts
./src/module/zenno/dto/configV2.dto.ts
./src/module/zenno/zenno.controller.ts
./src/module/zenno/zenno.module.ts
./src/module/zenno/zenno.repository.ts
./src/module/zenno/zenno.service.ts
./tsconfig.build.json
./tsconfig.json
./views/order.hbs
./views/web-app.auth.html

File Contents:
.env:
```
TG_ADMIN="t.me/tpsm_shop"
SHOP_TELEGRAM="@sportmaster_accbot"

HOST="localhost"
PORT=3001
DOMAIN="http://localhost:3001"
DATABASE_URL="postgresql://redmi:postgres@localhost:5432/sportmaster?schema=public"
TELEGRAM_TOKEN="5813231792:AAGxv2qq10rMt-fC09IsGAK8ksQYHGuhZAk"
TELEGRAM_ADMIN_ID=750126398,

TELEGRAM_NAMES_EXCEPTION_STATISTIC=Nastya_34561,Bsn_Tey
TELEGRAM_ID_VIP_COEF=5054271758,625894246

ZENNO_HASH="fwee233FF322080uhhdKBBJbdfabjdasjdg32yeiugeidq"
TTL_CASH=86400000
TIME_DURATION_PROXY_BLOCK_IN_MIN=5
HOST_DONOR="mp4x-api.sportmaster.ru"
API_DONOR="https://${HOST_DONOR}/api/"
HOST_DONOR_SITE="sportmaster.ru"
API_DONOR_SITE="https://${HOST_DONOR_SITE}/"
X_REQUESTED_WITH="ru.sportmaster.app"
ONLINE_COURSES="https://onlinecourses.ru/"

HOST_BOTT="bot-t.com"
API_BOTT_W_PROTOCOL="https://api.${HOST_BOTT}/"
HOST_BOTT_W_PROTOCOL="https://${HOST_BOTT}/"
SELLER_TRADE_BOT_ID="25624"
SELLER_TRADE_TOKEN="6487654530:AAGbR_TQGt762gRUvkxsg0lYgH3gUTa8Rk0"

TLS_FORWARDER_URL=http://127.0.0.1:8080/api/forward
TLS_FORWARDER_API_KEY=my-auth-key-1
TLS_CLIENT_IDENTIFIER=okhttp4_android_11

```

.env.example:
```
TG_ADMIN="t.me/example"
SHOP_TELEGRAM="@example_bot"

HOST="localhost"
PORT=3001
DOMAIN="http://localhost:3001"
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/name?schema=public"
TELEGRAM_TOKEN="58133121792:AAECZadad9qzTrfaYclGZ0T_wEVB9fadaabvNjQ"
TELEGRAM_ADMIN_ID=730129461,
ZENNO_HASH="fwee23dasdsadffabjdasjfaf3e2ugeidq"
TTL_CASH=86400000
TIME_DURATION_PROXY_BLOCK_IN_MIN=5
HOST_DONOR="example.ru"
API_DONOR="https://${HOST_DONOR}/api/"
HOST_DONOR_SITE="example1.ru"
API_DONOR_SITE="https://${HOST_DONOR_SITE}"
X_REQUESTED_WITH="ru.example.app"
ONLINE_COURSES="https://example.ru/"

HOST_BOTT="example.com"
API_BOTT_W_PROTOCOL="https://api.${HOST_BOTT}/"
HOST_BOTT_W_PROTOCOL="https://${HOST_BOTT}/"
SELLER_TRADE_BOT_ID="32569"
SELLER_TRADE_TOKEN="648eqe23:AFDDR_TQGt762fsdfsdfH3gUTa8Rk0"

TLS_FORWARDER_URL=http://127.0.0.1:8080/api/forward
TLS_FORWARDER_API_KEY=auth-key-228
TLS_CLIENT_IDENTIFIER=okhttp4_android_11
```

.eslintrc.js:
```
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: ['plugin:@typescript-eslint/recommended', 'plugin:prettier/recommended'],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-namespace': 'off',
    'no-console': 'error',
    "prettier/prettier": ["error", { "endOfLine": "auto" }]
  },
};

```

.gitignore:
```
# compiled output
/dist
/node_modules
/build
downloads/*
!downloads/.gitkeep
public/receipts


# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local
launch.json

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

```

.npmrc:
```
legacy-peer-deps=true
```

.prettierrc:
```
{
  "singleQuote": true,
  "tabWidth": 4,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "trailingComma": "all",
  "printWidth": 140
}

```

launch.json:
```
{
    "version": "0.2.0",
    "configurations": [
      {
        "type": "node",
        "request": "launch",
        "name": "Debug NestJS Application",
        "skipFiles": ["<node_internals>/**"],
        "program": "${workspaceFolder}/dist/main.js",
        "preLaunchTask": "npm: start:debug",
        "outFiles": ["${workspaceFolder}/dist/**/*.js"],
        "sourceMaps": true,
        "restart": true  
      }
    ]
  }
  
```

nest-cli.json:
```
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

```

package.json:
```
{
  "name": "sportik_server",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "migrate:dev": "prisma migrate dev",
    "migrate:generate": "prisma generate",
    "migrate:deploy": "prisma migrate deploy",
    "prisma:studio": "npx prisma studio",
    "npm-install": "npm install",
    "ts-check-errors": "tsc --noemit"
  },
  "dependencies": {
    "@nestjs/cache-manager": "^2.2.2",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.2.2",
    "@nestjs/core": "^10.0.0",
    "@nestjs/cqrs": "^10.2.7",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.3.8",
    "@nestjs/schedule": "^4.1.1",
    "@prisma/client": "^6.4.1",
    "argon2": "^0.40.1",
    "axios": "^1.6.8",
    "cache-manager": "^5.5.2",
    "date-fns": "^3.6.0",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.5",
    "email-validator": "^2.0.4",
    "emailjs-mime-codec": "^2.0.9",
    "express-handlebars": "^7.1.2",
    "handlebars": "^4.7.8",
    "hbs": "^4.2.0",
    "iconv-lite": "^0.6.3",
    "imap": "^0.8.19",
    "koffi": "^2.11.0",
    "mailparser": "^3.7.1",
    "md5": "^2.3.0",
    "mimelib": "^0.3.1",
    "nestjs-telegraf": "^2.7.0",
    "nestjs-zod": "^3.0.0",
    "nodemailer": "^6.9.13",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "patchright": "^1.52.4",
    "pdf2pic": "^3.1.3",
    "pino": "^9.7.0",
    "pino-pretty": "^13.0.0",
    "qrcode": "^1.5.3",
    "qs": "^6.13.0",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1",
    "sharp": "^0.33.4",
    "sleep-promise": "^9.1.0",
    "socks-proxy-agent": "^8.0.3",
    "telegraf": "^4.16.3",
    "uuid": "^9.0.1",
    "uuid-validate": "^0.0.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/cache-manager": "^4.0.6",
    "@types/date-fns": "^2.6.0",
    "@types/emailjs-mime-codec": "^2.0.2",
    "@types/express": "^4.17.17",
    "@types/express-handlebars": "^6.0.0",
    "@types/hbs": "^4.0.4",
    "@types/imap": "^0.8.40",
    "@types/jest": "^29.5.2",
    "@types/mailparser": "^3.4.4",
    "@types/md5": "^2.3.5",
    "@types/node": "^20.3.1",
    "@types/nodemailer": "^6.4.15",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/qrcode": "^1.5.5",
    "@types/supertest": "^6.0.0",
    "@types/uuid": "^9.0.8",
    "@types/uuid-validate": "^0.0.3",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "prisma": "^6.4.1",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

```

tsconfig.build.json:
```
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

```

tsconfig.json:
```
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2020",
    "sourceMap": true,
    "resolveJsonModule": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "paths": {
      "@common/*": ["./src/common/*"],
      "@libs/contracts/*": ["./libs/contracts/*"]
    },
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "strict": true,
    "strictPropertyInitialization": false,
    "noImplicitAny": true,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "useDefineForClassFields": true
  }
}

```

downloads/Текстовый документ.txt:
```
8981fcda-8fdc-4a14-adcb-aacbb0738944	phsby1o@rambler.ru	IWGM4SDQNSAF98TStpx	IWGM4SDQNSAF98TStpx	[{"domain":".sportmaster.ru","expirationDate":1789811780.0,"hostOnly":false,"httpOnly":true,"name":"SMAID","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"48a0c9a6-fdc6-4fa0-953b-927f567224e2"},{"domain":".sportmaster.ru","expirationDate":3902726118.0,"hostOnly":false,"httpOnly":true,"name":"smafauth","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"9b8e5a27-fb88-4124-a868-c6e48204dae3"},{"domain":"www.sportmaster.ru","expirationDate":1789811780.0,"hostOnly":true,"httpOnly":true,"name":"UDID","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"84ac4825-2c23-4893-a9fc-3e9a5c446011"},{"domain":"www.sportmaster.ru","expirationDate":3902726094.0,"hostOnly":true,"httpOnly":true,"name":"SMAUTH","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"eyJpZCI6IjQ4YTBjOWE2LWZkYzYtNGZhMC05NTNiLTkyN2Y1NjcyMjRlMiIsInN0IjoiTkVXIiwidG0iOjE3NTUyNDI0NDh9"},{"domain":"www.sportmaster.ru","expirationDate":3902726118.0,"hostOnly":true,"httpOnly":true,"name":"SMID","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiIzNmIyMWE4MC1hMDZhLTRhOTAtODMyMS0zODkyMDhlOTNiYjUiLCJpc3MiOiJTTTMwIiwiaWF0IjoxNzU1MjQwOTgwLCJhdWQiOlsic3BvcnRtYXN0ZXIiXSwiYW5UIjoiMGFhYWQzM2EtNzFiNC00ZjVmLWJjNzAtYjQ3ZDEzM2NjNWQxIiwiYW5QIjoiNDhhMGM5YTYtZmRjNi00ZmEwLTk1M2ItOTI3ZjU2NzIyNGUyIiwiYW5VIjoiMTAwMDAwMDIzOTg2NDYyMTE1IiwiY2FuVCI6IkFJQXN4N2paUVRNZllUd0hrekk5V09ta0wrOGx5NXZ2cmJnQVMwMmo5dUVWZnJVcmY2YnRvWG1WZlBseXNGbHpGcDRLZW9ucGhjdEkwd20rRTBFWWpJTitPcG9iQUVYMFBXVVlCUGY5VFZWa0JldmtZOEovVnFkcGtvbDlLMTgwMzJDZ2FWT2l5eEFQSmFUY0hISlEyRTZ5dWw5NmVCWHpYQjY3cXQ5WW93dVNySjRxNHRpL0ZPRzVCZVQrbXI0VTMzZmtOYnl0dFJsVGFPc1JqdmZadEplTFMyNjd0S3M4N0dLYlhXVm4yVlNKMUVHMFVHTy9RWVlqU243d2FwV0RTcW89IiwiY2FuUCI6IkFJQTZ4UVp2RnhHc09tbzhpaHdWbGVqYlJlRTZqVWowYkRJK0Z4RnBsVU1YSTg2QXpMWEh5aUt0ZU9SeWpGQytMSWpUcFAwTVBCR0UxdkRTRkhvZEJwb2poeFgwVDhIT2Y3aWtuMkF1a1dZNERjbWRmNFVqNzhhRjIySnlJM2FsNUtGb2dyVVlON1dPRnI4cldTUEJVeWxRUjlOcGlCWmU1WEMwZDRTUkZQQUtieFhkZTZOTXErZVNPcjU5RUhHdzhnREg3MXM1Ymp3WE93SWJLdW51M09yN2IvRWZ0aVV0N0tzYi9LQ3Vmd2N6ZEc2aS9aWmdjelpNaVdDOUl1M0twNjg9IiwiYXVUIjoiOWI4ZTVhMjctZmI4OC00MTI0LWE4NjgtYzZlNDgyMDRkYWUzIiwiYXVQIjoiMTAxMDAwMDAwNjYxMDMzOTE1IiwiY2F1VCI6IkFJQlc5U2I3ZE9BcW9zaWZXN1lxVGhMaXF6aHNickJtQ1JjWWRxU2JFT1N6ejFBKzRwRnNwczFTeGtLb05MV1ZDRDZGYlVoc2x3WEZocEx2YkZ6ZllIYy8vWlJ0NDBPaC9SaWF3TXF1VXZ3ZWhNaW5EQjhhWEVRRjVFQUpGcVZvSHBiZ2JjdFI2NFgyQ2V3bFQvcHl5QW1MMHdVU0VvUnJkazZtTzd4b0Y5VEdnR3V3UzJhbCsvOFYwdzlyVkE2cDdEblFCcVhydU1SMDFSNjVVdVhweXpFeVU2MnVQUlZEZDFJczA4R0pxd0xSL1d5STkwdFc4eWQ3T25pNFNiT2l3T2M9In0.YrjynrJRII-7Bqm1g-NIzvyprZH0k5B1dHp25FnIkKeD70MPVCCdRZpGoo5X5vZe76mnLtvO7lf9_2uz2YLKjtVF5HSIjqt2ZrqmdTo6yXAgqvhgHgMDKb_eTtvSm0TOh0inFkNNk8cFK4McPt8qHXqm61FQbSUOX8PLQtSeopR3N5dcXEVLquCYKBXpuZiYyoWlf_FU1hvJjPitNqSBQYomt1iuewFeEqEe-509thTPZURST6u9s9c69uq7A0nl0hpWGAvXW8jE195CsZPUYFqNdbf-JKWiiwauk1JQaPqisDKg2cFmjLeUKRPgxrfLdRUaJej78ss3jP-ziKECzA"}]	eyJ0eXAiOiJKV1QiLCJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.Riw0KW9BGkGQvxsePPxsZ7D5jn2qnBd0Yd9v9qz2cs-1BMz6Gr5f0cX0oxtHcKFnO_gFwRXswDaHDe4NKduPaKTbYe3-h7UgguOSVUQWKreUxoF_gYGphnacyOc-t9tCUtXEPMyaQfxlYOHPE1HOoNr9_YHHCGdFFX090FGYoJp-GwaqlnDLYK3JYK-I9bjCLGPuh5youVyAuL2g9mvk2cnUpergfpWgUJenwLnC9LxbYuf5xZu3d8176EC9Q6JPQqHCNoNuSwbumDoMqB2HpkRahcXQ6c4703sML3CboUx586wMYX3uR9wOujv2W0XYdVbDyCAyCYGBmwguKiTUmQ.N2zMTIR_DmsqH6MX.gIvqX9JvnqUtaWfr1oL3RkBVXn3Xbb4saP2eZGJXOIvX2Q_dkOBDiI1r2wfPBg6zoPL2RKDTpFWyOqXs3jU-AipYG28jPDY16npLJty5uBbysFDif7GLMj5Kv-F0O9P3rmBk0z4NEA3v2ukmRlyqG3nVjQM5OxvpzJR1IgRogr6xzVURMmfuqXP20OgP4ckeTR4uvrDSngOpgdfsBwXUDYKvVd41BlpIWCYITxUqCiYndTGtsOK4VPJ2hCaB8hoQzuTb4wECZjIhYsqhq_YB367NC6VTJAP0fp_cl9Z8qzbCZII-r2F_ifP3Ro8elMkhTYucx3edbxn1FtLK2Bhaazq9L8iQPuXilyWL2b_-kFvxIdrMtB3MJRdOxolqZNDbkeeOHYKiOo0wVQd4i2sb4couBFsvks4geQ.5YaVtYsrXHIkQM_BkhUuEQ	eyJ0eXAiOiJKV1QiLCJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.gkCKipaeeRFfJEL8CVb1aAkSZbvnWxvMMGRdsTAvZfckuXrvdINLrI4p7kcF8OmJYMH-NwLtSnZaOC5S9h1HurIQXY9gnjMmfh92mzJVSeDUlqCv1jGmKOfVkboCdE9VUmAwdw2VJsBRjvbo8Q-SxJd72jC2gYZx5-3PuZSYej95BpFjmQrk84PjHU_5eRGIOEEdplXkSSFaRAOvnltPFdXRa0a0rawx2AOWKw70S-vI_ToBH84sFFnuo9O6aA_J0Hnt_3OVvxlaep0NmaoTqfEYqWPrQsYfsSQA1OWCPVX1WDyxcjk7iGxVlpQOL5_6xGIJlnG_yP4uPhNQdBhiqQ.SxE0nAawd8HuLcrb.kgqRo9xYDGad49n-z88-DfvYv9WfCFkp5lBSP_RUXOKdmnRIVmUR3TUP6m5D45JEAWA2O8c2fcCC0LT87UodZTY4F5JZuHz7FA0jBgnQdZZ2AL1OUMFuolFK5Vnd5mQzN0E_xLZxI-JjYvaTI9AXlr9MFAsYxOgxK38wLo2s9786fr3SsLRRSdqUWp35G2qbZnBh1KaR4VswfanblJeOgyYrY7WocQIdoUVCg4rNCJh8WXp_rKCLzGOqAyhdPIPYtPTYD4aaN5PlHXB7ywP30Dpl4zGMm8ARVd7rLW1ZQRWzSwPoBB0G5Y1wPqf9LaztfGRiJcDojbV2LBkmm0GC7gF-PthsJRs7zc6gskG1YsY2vB-uDeYV5O8YOAPwuoRs42qdqlC26JSA_p1_JWnQd7Hc97KE03r2E6E.SNQqIHTG_oIqeqtVgAKLDQ	101000000661033915	8981fcda-8fdc-4a14-adcb-aacbb0738944	d670a13b-fb24-41e1-899b-d4e1d9999409
a53d0f84-d094-4a82-b90d-8ef6e4cfbdd1	mxtfds6@rambler.ru	1PIEXJCKBOAAKTI1ptu	1PIEXJCKBOAAKTI1ptu	[{"domain":".sportmaster.ru","expirationDate":1789811779.0,"hostOnly":false,"httpOnly":true,"name":"SMAID","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"02003a7f-1761-45f0-962e-9f505d2ff175"},{"domain":".sportmaster.ru","expirationDate":3902726117.0,"hostOnly":false,"httpOnly":true,"name":"smafauth","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"eddded24-fc1e-49ef-9fdb-1fbfb9f234f2"},{"domain":"www.sportmaster.ru","expirationDate":1789811779.0,"hostOnly":true,"httpOnly":true,"name":"UDID","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"3ba7646e-b228-4a1d-b185-23e445da2d21"},{"domain":"www.sportmaster.ru","expirationDate":3902726094.0,"hostOnly":true,"httpOnly":true,"name":"SMAUTH","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"eyJpZCI6IjAyMDAzYTdmLTE3NjEtNDVmMC05NjJlLTlmNTA1ZDJmZjE3NSIsInN0IjoiTkVXIiwidG0iOjE3NTUyNDI0NDd9"},{"domain":"www.sportmaster.ru","expirationDate":3902726117.0,"hostOnly":true,"httpOnly":true,"name":"SMID","path":"/","sameSite":null,"secure":false,"session":false,"storeId":null,"value":"eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiIxODYxZmU4YS0zYzlhLTQxYTAtYjBhZC1jYmNiZjU4MjAwNTAiLCJpc3MiOiJTTTMwIiwiaWF0IjoxNzU1MjQwOTgwLCJhdWQiOlsic3BvcnRtYXN0ZXIiXSwiYW5UIjoiYWZmNjdlNWItY2JkMy00NzViLWI2MzYtNWE5ZWRkY2ExZTk1IiwiYW5QIjoiMDIwMDNhN2YtMTc2MS00NWYwLTk2MmUtOWY1MDVkMmZmMTc1IiwiYW5VIjoiMTAwMDAwMDIzOTg2NDYxOTA1IiwiY2FuVCI6IkFJQTEyTjhXQUxQVTUxdVlPaDk2ZXJTeVNMNWs0ME9Oc0RCRVFQRGpwa0t2a2ZoRnB3QjdTRUk1Y21OZndjVitiUmxiRWw3dlc5Mk45KzhZR0pKdkJOcTlUZCtzVlp4bk4rTFlla2Uvd0E5eVB4N0llenBGaFY0bm5Kekg1aGoxS3JZanlpL0Q5UFdsOS81UVpOdHY5TVB5WUtBTnJURjRYdFBUY3B0U08waEVvYWZZN05xM0o2RVFYMHk3dkUvSVMveE1PWHFOeHN4c1M2TCtIV1BiMUlvRGc1ckZYM3MvYmlPRkY5enRoYkpSN1hiQ2tWMy9maWhpQ082K1VUdUhZK2s9IiwiY2FuUCI6IkFJQ0FheGF1UTk4TDdVNUFrcEw3QVNoSVJ3SXZEd1gxQ1k3NFRCUzVhNHlwVTluWUhhT3o3SVBpNzNsSU5SZXRrbHNqaVkrY1ozTXBDTGJmRExzMzRwcWkxc2oxNkZJM1FtdDNuOEJDbzc0RFZYWlVuTHNzRjdKeWkyeUhVM2RIUXVuRVZBclZOMWt4N08wZWVtN2NJREFoT1pHU00xcWx1YjFpWmo3RDF0azJHMWQzRkZKUVNTY0d4eFpGL01MVnNzQ0lxekVXKytkNGE2Y0lUWWhiRlVYdlhDWk5LOFJDaVV4TXA4NnhPQlBQc1dQakFJWkRXQVlreisvNmFzVW5NQ289IiwiYXVUIjoiZWRkZGVkMjQtZmMxZS00OWVmLTlmZGItMWZiZmI5ZjIzNGYyIiwiYXVQIjoiMTAwMDAwMDIzOTg2OTgwNzMyIiwiY2F1VCI6IkFJQi8xV0w4bVRPcVVURkFHNC9LQi8wUlVUUG51aDI1Q0VqUVRhc0FReGpqOFZyOXhMY3h4MXNSNFlkZS9zQnZZdnl6NlE3Y2JqTjgvM1c3QXpBQVp0L3UzSmlMYWp6VG1Wc1JZV2xYb1g5QzFmcjBtanY0VjJEMnM0U3V6QkxLNEFLRWwzUVdQMWxPNE1oV3NLQzhnd0FXRmNyV2laSlpEUFF0MXYrL04vb0V2czJJZi9yQkpuWlEzOUw0T1Q5QkFaOXI3UzVydnNWdjNMdnF5R25mRGx2Y1Zsc2tkbkliMXZERWRZVHEzSUNWRFlHSjNFZFdIQkhZbXRyNE1Ha280eEU9In0.CSW7onTw8C4QsLt6j-UgL3hJnHwbaCrM6McqI-AlIwM_vsMEmwIfvM78lTNQf9I-pUUAm4bLo97PCBqc2szPFy8G-jvtZtsBLCrhXAkdRN-fosTPLkM1mSZor_Oal__u4EkKLojybivTIXIBvpM4FfyU75l9CQ-8kOxb_zIvTQhhidv774Wd731G8iNodNvXpOTJTWv7R_dp_7I7bmcJevZYirOPCtkmviAZXzOl3xitFZHBjqgeTufplGvTVwTtV6BV5bx7zsKed6UUX4af1fzsseS7MwhcSUGE00l8wCf_QQVwUT9-VhgRWIJoaSTyeG8aUAEThh8GcaiCXBjg5w"}]	eyJ0eXAiOiJKV1QiLCJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.Pf3vL_tE_ESMJmwhp6PV6hXOOLC5a6vKKzMMvws3HpGuVel_LO0QD3YSF-0S86qF5i9NGGTSJqHKMi5hYNOXGFLZfZ4tIZ-j-rkS3rq1GR0pr1nEmoc8FvtErSVkfObFkqSp6gtMRLAIJTe47bYkwJ3m6HXJWgLU-bOWcJ2-vDTjJnpk5EC9vS-gL5bo1smuUbRGaC2-vqSnu0Ak7JrchodPPcuANqcudhmK6BKUr7ly6Cjut3RuAJxEsbKlGWvIwFN2NTTAmHdQ0wWf2eDRaSGjL_rTc0QEjy21AJ6ZYqOqDv_zJOEtmcAsDgpaN2OPwZiK63j1pVsxL-LkqYEpRw.K20mH5gHgeWc0Akk.SDyGfVpo9Rn7pKw4yNMw9xc2K6lmXFxGOqg1CJsQ727YPv1UrCSfzkTd6ksY0Kk45hlQ6C_780joSB0VpVbWQMMDCsXtMnzoznkijOhaq8qT3w1gqv96-AjYzpVrHQiFINkW-FsX9fUMg-Y8Kg6MaQPSvWV7_rGVzzaGxODuRocgE8ftqRuszRhDZ4pA4Ycb9KZY8VyKioC9bzRZIIbYqiNjTPB4WDeF5Njw9hlza4F0RIDqu-72gxDSoZIo1WuP8e1qIpF3b8QlKShZ028A1NRU-rPNrqf74IYGoeHccuuKueOJ_ZxoYHRbTveDP8grdOIIdSUjqraqD59L3LK81uaqGO8dr2EiiGpd-Chd9l2m92XqgYdsXiBizbMkS5EhLop7CnubOeGOsQUtRy4FGfyn8oKf2L5j5A.kxZi7opP_YIohNU1zMZLGQ	eyJ0eXAiOiJKV1QiLCJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.dgBSS2JeEukup7_BeXociRKePxN2O423OwZfLmieegkTRvxih4xRaacw-T3vAwSnaX6HlzuJubnoP__Ytc7nvMI6Sel-Yh56gLM94h-zNSWHgLFJnZTRzUsf75KrWKt4gBYGBuEyXHJd0Nn-Hx6ZEdb93RwUkEPS-r6v3PXK63UuGcNVCZM0rqVDsMOKCtt7sFp71nmyi1kkJO9Vh6jOVUKDAqLAubJwneu5pMJdrrYfnrC4WrSft-8hT7Wp0NVO7Ol9wX_WG_KFPAytSH41-1lGZpQJarK4dLHTAhlA9303rKwxKbKY8t9v9mMvYEXWYZfkZZcmiWXnu4ysm3A6UA.yH7xS9TVKR9IwgPh.Wf9oNvsb0vip_3vSr0gk25xeZsqHRsB8htctkmOQODAoS1aWcWV0PyJDlpBxwhv-xwZpvp7WNkJBSZx343k73RV-6WhbAOFdBZamNVXBSyWuc9ldZO6YMwbeAqGvW7RelQXJuIdoTT9Xmdrxm5C22-sN15VxaWc009eXf94VXpsF6kToabaOyzjAu0VpUtO7eZfKcLnsJbCfMhZLW3FZi4D5LhGbaHAlTtofEDqRVBVjyUmmNsQ6NaEIfz9_bvTgYcwtgbsIUDzI5euENKgRZKp-JggIrhaDv06mjLLaHbQgUZMYetqDRIAjkXNMCNE0Gtz3f4KJHhwoaLyX3TtIwupEw3MlWKAWUsG_t8coSmIb480rOS9XxXaEdSWZd3E2b4LT2ZJTgBNg_BOkJt0HWNJN5eyvaflsoRc.DBcndItcUsNY3a-8_xExEQ	100000023986980732	a53d0f84-d094-4a82-b90d-8ef6e4cfbdd1	fa30a88f-9df2-4303-8bb5-4e61c5d7bf76
```

prisma/schema.prisma:
```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  firstName      String       @map("first_name")
  email          String       @unique
  passwordHash   String       @map("password_hash")
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt @map("updated_at")
  userTelegramId String       @unique
  uuid           String       @id @default(uuid()) @db.Uuid
  userTelegram   UserTelegram @relation(fields: [userTelegramId], references: [telegramId])

  @@map("user")
}

model UserTelegram {
  telegramId     String          @id @unique @map("telegram_id")
  telegramName   String          @map("telegram_name")
  countBonuses   Int             @default(0) @map("count_bonuses")
  isBan          Boolean         @default(false) @map("is_ban")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  role           UserRole        @default(User)
  accounts       Account[]
  paymentOrders  PaymentOrder[]
  user           User?
  fortuneCoupons FortuneCoupon[]
  userCities     UserCitySM[]
  UserTemplate   UserTemplate[]

  @@map("user_telegram")
}

model UserTemplate {
  id             String       @id @default(uuid()) @db.Uuid
  name           String
  template       String       @db.Text
  userTelegramId String       @map("user_telegram_id")
  commissionType String       @default("TOTAL") @map("commission_type")
  commissionRate Float        @default(10) @map("commission_rate")
  roundTo        Int          @default(10) @map("round_to")
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt @map("updated_at")
  userTelegram   UserTelegram @relation(fields: [userTelegramId], references: [telegramId])

  @@map("user_template")
}

model Account {
  accountId                String                  @id @map("account_id")
  email                    String
  passImap                 String                  @map("pass_imap")
  passEmail                String                  @map("pass_email")
  cookie                   String
  accessToken              String                  @map("access_token")
  xUserId                  String                  @map("x_user_id")
  deviceId                 String                  @map("device_id")
  installationId           String                  @map("installation_id")
  googleId                 String?                 @map("google_id")
  pushToken                String?                 @map("push_token")
  expiresInAccess          DateTime                @map("expires_in_access")
  isAccessMp               Boolean                 @default(true) @map("is_access_mp")
  isAccessCookie           Boolean                 @default(true) @map("is_access_cookie")
  isOnlyAccessOrder        Boolean                 @default(false) @map("is_only_access_order")
  bonusCount               Int                     @map("bonus_count")
  isUpdateBonus            Boolean                 @default(false) @map("is_update_bonus")
  createdAt                DateTime                @default(now()) @map("created_at")
  updatedAt                DateTime                @updatedAt @map("updated_at")
  refreshToken             String                  @map("refresh_token")
  cityId                   String                  @default("1720920299") @map("city_id")
  ownerTelegramId          String                  @map("owner_telegram_id")
  proxyUuid                String?                 @map("proxy_uuid") @db.Uuid
  expiresInRefresh         DateTime                @map("expires_in_refresh")
  userGateToken            String?                 @map("user_gate_token")
  accessTokenCourse        String?                 @map("access_token_course")
  isValidAccessTokenCourse Boolean                 @default(true) @map("is_valid_access_token_course")
  refreshTokenCourse       String?                 @map("refresh_token_course")
  statusCourse             CourseStatus            @default(NONE) @map("status_course")
  citySM                   CitySM                  @relation(fields: [cityId], references: [cityId])
  ownerTelegram            UserTelegram            @relation(fields: [ownerTelegramId], references: [telegramId])
  proxy                    Proxy?                  @relation(fields: [proxyUuid], references: [uuid])
  AccountCourse            AccountCourse[]
  AccountLessonProgress    AccountLessonProgress[]
  orders                   Order[]
  courses                  OriginalCourse[]
  deviceInfo               DeviceInfo?

  @@map("account")
}

model DeviceInfo {
  id               String   @id @default(uuid()) @db.Uuid
  osVersion        String   @map("os_version")
  buildVersion     String   @map("build_version")
  brand            String
  model            String
  screenResolution String   @map("screen_resolution")
  browserVersion   String   @map("browser_version")
  IP               String
  accountId        String   @unique @map("account_id")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  account          Account  @relation(fields: [accountId], references: [accountId])

  @@map("device_info")
}

model CitySM {
  name      String       @default("Москва")
  cityId    String       @id @unique @default("1720920299") @map("city_id")
  fullName  String       @default("Москва") @map("full_name")
  createdAt DateTime     @default(now()) @map("created_at")
  updatedAt DateTime     @updatedAt @map("updated_at")
  accounts  Account[]
  cityUsers UserCitySM[]

  @@map("city_sm")
}

model UserCitySM {
  cityId         String       @map("city_id")
  userTelegramId String       @map("user_telegram_id")
  city           CitySM       @relation(fields: [cityId], references: [cityId])
  userTelegram   UserTelegram @relation(fields: [userTelegramId], references: [telegramId])

  @@id([cityId, userTelegramId])
  @@map("user_city_sm")
}

model Order {
  id          Int      @id @default(autoincrement())
  orderNumber String   @unique @map("order_number")
  accountId   String   @map("account_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  account     Account  @relation(fields: [accountId], references: [accountId])

  @@map("order")
}

model Proxy {
  uuid      String    @id @default(uuid()) @db.Uuid
  proxy     String
  expiresAt DateTime  @map("expires_at")
  blockedAt DateTime? @map("blocked_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  accounts  Account[]

  @@map("proxy")
}

model Todo {
  id        Int      @id @default(autoincrement())
  todo      String   @unique
  name      String
  active    Boolean
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("todo")
}

model Course {
  id        Int      @id
  name      String   @unique
  count     Int
  active    Boolean
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("course")
}

model PaymentOrder {
  id             String                      @id @default(uuid()) @db.Uuid
  amount         Int
  status         StatusPayment               @default(Created) @map("status")
  receiptUrl     String?                     @map("receipt_url")
  completedAt    DateTime?                   @map("completed_at")
  userTelegramId String                      @map("user_telegram_id")
  createdAt      DateTime                    @default(now()) @map("created_at")
  updatedAt      DateTime                    @updatedAt @map("updated_at")
  isPositive     Boolean?                    @map("is_positive")
  amountCredited Int                         @map("amount_credited")
  transactionId  Int?                        @unique @map("transaction_id")
  couponId       String?                     @db.Uuid
  couponApplied  Boolean                     @default(false)
  userTelegram   UserTelegram                @relation(fields: [userTelegramId], references: [telegramId])
  statusHistory  PaymentOrderStatusHistory[]
  coupon         FortuneCoupon?              @relation(fields: [couponId], references: [id])

  @@index([userTelegramId])
  @@index([status])
  @@map("payment_order")
}

model PaymentOrderStatusHistory {
  id             Int           @id @default(autoincrement())
  paymentOrderId String        @map("payment_order_id") @db.Uuid
  status         StatusPayment @map("status")
  changedAt      DateTime      @default(now()) @map("changed_at")
  paymentOrder   PaymentOrder  @relation(fields: [paymentOrderId], references: [id])

  @@index([paymentOrderId])
  @@map("payment_order_status_history")
}

model OriginalCourse {
  courseId         String          @id @map("course_id")
  title            String
  mnemocode        String
  points           Int
  lessons          Lesson[]
  AccountCourse    AccountCourse[]
  Account          Account?        @relation(fields: [accountAccountId], references: [accountId])
  accountAccountId String?

  @@map("original_course")
}

model Lesson {
  lessonId              String                  @id @map("lesson_id")
  title                 String
  duration              Int
  position              Int
  videoId               String                  @map("video_id")
  courseId              String                  @map("course_id")
  course                OriginalCourse          @relation(fields: [courseId], references: [courseId])
  AccountLessonProgress AccountLessonProgress[]

  @@unique([courseId, position])
  @@map("lesson")
}

model AccountCourse {
  accountCourseId Int                     @id @default(autoincrement()) @map("account_course_id")
  accountId       String                  @map("account_id")
  courseId        String                  @map("course_id")
  status          CourseStatus            @default(BLOCKED)
  account         Account                 @relation(fields: [accountId], references: [accountId])
  course          OriginalCourse          @relation(fields: [courseId], references: [courseId])
  lessonsProgress AccountLessonProgress[]

  @@unique([accountId, courseId])
  @@map("account_course")
}

model AccountLessonProgress {
  progressId                   Int            @id @default(autoincrement()) @map("progress_id")
  accountId                    String         @map("account_id")
  lessonId                     String         @map("lesson_id")
  status                       LessonStatus   @default(BLOCKED)
  nextViewAt                   DateTime?
  accountCourseAccountCourseId Int?
  AccountCourse                AccountCourse? @relation(fields: [accountCourseAccountCourseId], references: [accountCourseId])
  account                      Account        @relation(fields: [accountId], references: [accountId])
  lesson                       Lesson         @relation(fields: [lessonId], references: [lessonId])

  @@unique([accountId, lessonId])
  @@map("account_lesson_progress")
}

model AccountMirror {
  id                String    @id @default(uuid()) @db.Uuid
  telegramId        String    @map("telegram_id")
  telegramName      String    @map("telegram_name")
  accountId         String?   @map("account_id")
  userIp            String?   @map("user_ip")
  mirrorToken       String?   @unique @map("mirror_token")
  mirrorTokenExpiry DateTime? @map("mirror_token_expiry")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  @@map("account_mirror")
}

model FortuneCoupon {
  id           String              @id @default(uuid()) @db.Uuid
  coupon       String              @unique
  type         FortuneSurpriseType
  value        Int
  isActive     Boolean             @default(true) @map("is_active")
  expiresAt    DateTime            @map("expires_at")
  usageCount   Int                 @default(0) @map("usage_count")
  maxUsage     Int                 @default(1) @map("max_usage")
  description  String?
  redeemedAt   DateTime?           @map("redeemed_at")
  createdAt    DateTime            @default(now()) @map("created_at")
  updatedAt    DateTime            @updatedAt @map("updated_at")
  owner        String
  userTelegram UserTelegram?       @relation(fields: [owner], references: [telegramId])
  payments     PaymentOrder[]

  @@map("fortune_surprise")
}

enum FortuneSurpriseType {
  Replenish
  Discount
  Payment
}

enum UserRole {
  User
  Admin
  Seller
}

enum StatusPayment {
  Created
  Transfered
  Completed
  Cancelled
  Proceedings
}

enum CourseStatus {
  NONE
  ACTIVE
  FINISHED
  BLOCKED
}

enum LessonStatus {
  NONE
  VIEWED
  BLOCKED
}

```

public/css/styles.css:
```
@font-face {
    font-family: 'GothamSSm';
    src: url('../fonts/GothamSSm/GothamSSm-Medium.eot'),
url('../fonts/GothamSSm/GothamSSm-Medium.eot?#iefix') format('embedded-opentype'),
url('../fonts/GothamSSm/GothamSSm-Medium.woff2') format('woff2'),
url('../fonts/GothamSSm/GothamSSm-Medium.woff') format('woff'),
url('../fonts/GothamSSm/GothamSSm-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'GothamSSm';
    src: url('../fonts/GothamSSm/GothamSSm-Light.eot'),
url('../fonts/GothamSSm/GothamSSm-Light.eot?#iefix') format('embedded-opentype'),
url('../fonts/GothamSSm/GothamSSm-Light.woff2') format('woff2'),
url('../fonts/GothamSSm/GothamSSm-Light.woff') format('woff'),
url('../fonts/GothamSSm/GothamSSm-Light.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}

@font-face {
    font-family: 'GothamSSm';
    src: url('../fonts/GothamSSm/GothamSSm-Book.woff2') format('woff2'),
    url('../fonts/GothamSSm/GothamSSm-Book.woff') format('woff'),
    url('../fonts/GothamSSm/GothamSSm-Book.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}

body {
    font-family: 'GothamSSm', sans-serif;
    background-color: white;
}

* {
    padding: 0;
    margin: 0;
}

.text18-black {
    font-family: 'GothamSSm', sans-serif;
    font-size: 18px;
    font-weight: 500;
    color: #000;
}

.text17-black {
    font-family: 'GothamSSm', sans-serif;
    font-size: 17px;
    font-weight: 500;
    color: #000;
}

.text16-black {
    font-family: 'GothamSSm', sans-serif;
    font-size: 16px;
    font-weight: 500;
    color: #000;
}

.text14-black-bold {
    font-family: 'GothamSSm', sans-serif;
    font-size: 14px;
    font-weight: 500;
    color: #000;
}

.text14-black {
    font-size: 14px;
    color: #000;
}

.text14-black-med {
    font-family: 'GothamSSm', sans-serif;
    font-weight: 500;
    font-size: 14px;
    color: #000;
}

.text14-grey {
    font-size: 14px;
    color: #676767;
}

.text14-orange {
    font-size: 14px;
    color: #E79225;
}

.text12-grey {
    font-size: 12px;
    color: #676767;
}

.text12-black {
    font-size: 12px;
    color: #000;
}

.main {
    margin: auto;
    max-width: 350px;
    padding: 62px 19px 100px;
}


.header {
    display: flex;
    padding: 20px 0;
    position: fixed;
    top: 0;
    background-color: white;
    z-index: 1;

}

.order-number {
    margin-left: 24px;
}

.date-create {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.button-check {
    flex: 0 1 auto;
    padding: 5px 13px;
    font-family: 'GothamSSm', sans-serif;
    font-size: 12px;
    color: #809FEB;
    border: none;
    background-color: #E7EEFB;
    border-radius: 14px;
    user-select: none;
    line-height: 1.5;
    text-align: center;
    vertical-align: middle;
    white-space: nowrap;
}

.about-address {
    display: flex;
    margin-top: 27px;
    justify-content: space-between;
}

.about-address-info {
    display: flex;
    flex-direction: column;
    max-width: 270px;

}

.button-route {
    margin-top: 30px;
    vertical-align: top;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(122, 122, 122, 0.5);
}

.button-route img {
    position: relative;
    top: 25%;
    left: 25%
}

.address {
    margin-top: 10px;
}

#trek-number-block {
    display: flex;
    flex-direction: column;
    margin-top: 27px;
}

#trek-number-link-block {
    display: flex;
    align-items: center;
    margin-top: 10px;
}

#trek-number-link-block p {
    margin-right: 10px;
}

#trek-number-link-block img {
    margin-right: 10px;
    filter: invert(24%) sepia(95%) saturate(4207%) hue-rotate(224deg) brightness(88%) contrast(86%);
}

.operating-mode {
    margin-top: 17px;
}

.date-delivery {
    margin-top: 27px;
}

.date-delivery p:nth-child(2) {
    margin-top: 10px;
}

.payment-method-info {
    margin-top: 26px;
}

.payment-method {
    display: flex;
    margin-top: 9px;
    justify-content: space-between;
}

.about-price {
    margin-top: 26px;

}

.price-items {
    float: right;
}

.discount-bonus {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
}

.count-items {
    display: flex;
    justify-content: space-between;
}

.total-price {
    margin-top: 14px;
    display: flex;
    justify-content: space-between;
}

.about-buyer {
    margin-top: 49px;
}

.about-buyer p {
    margin-top: 8px;
}

.about-order {
    display: flex;
    flex-direction: column;
    margin-top: 33px;
}

.about-order-section {
    display: flex;
    flex-direction: column;
    margin-top: 10px;

}

.order-section {
    display: flex;
    border-top: 1px solid #EFEFF1;
    padding-top: 16px;
    padding-bottom: 38px;
    list-style-type: none;
}

.order-section:nth-child(1) {
    border-top: none;
}


.about-order-info {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
}

.order-section img {
    width: 60px;
    height: 80px;
    margin-right: 12px;
    border-radius: 5px;
}

.wrapper-order-info p {
    padding-bottom: 2px;
}

.param-order li {
    margin-top: 6px;
    list-style-type: none;
}

.about-order-info-price {
    display: flex;
    align-items: flex-end;
    margin-top: 9px;
}

.price-item-discount {
    text-decoration: line-through;
    margin-left: 10px;
}

.count-item {
    margin-left: auto;
}

.about-order-info-price p {
    margin-bottom: 0;
}

.buttons-footer {
    margin: 12px auto 0;
    display: grid;
    gap: 18px;
    align-items: center;
}

.button-ask {
    padding: 12px 0;
    width: 100%;
    font-size: 16px;
    font-weight: 500;
    color: #1851E4;
    border: none;
    background-color: #E7EEFB;
    border-radius: 6px;
    user-select: none;
    line-height: 1.5;
    text-align: center;
}

#cancelled-order {
    background-color: #fff;
    color: #000;
    border: 1px solid #BABABA;
}


.footer-menu {
    box-sizing: border-box;
    padding: 10px 24px;
    width: 316px;
    height: 48px;
    background-color: #fff;
    border-radius: 24px;
    box-shadow: 0 0 30px rgba(122, 122, 122, 0.5);
    position: fixed;
    bottom: 19px;
    z-index: 1;
    left: 50%;
    margin-top: -24px;
    margin-left: -158px

}

.footer-menu ul {
    display: flex;
    justify-content: space-between;
    list-style-type: none;
    align-items: center;

}

.grey-wrap {
    filter: invert(83%) sepia(6%) saturate(18%) hue-rotate(317deg) brightness(88%) contrast(94%);
}

.current-link {
    filter: invert(24%) sepia(95%) saturate(4207%) hue-rotate(224deg) brightness(88%) contrast(86%);
}
src/app.constants.ts:
```
/* eslint-disable @typescript-eslint/no-non-null-assertion */
export const APP_NAME = process.env.npm_package_name!;
export const APP_VERSION = process.env.npm_package_version!;

```

src/app.module.ts:
```
import { Module } from '@nestjs/common';
import { TelegrafModule } from 'nestjs-telegraf';
import { getTelegramConfig } from '@common/telegram/telegram.config';
import { ConfigModule } from '@nestjs/config';
import { TelegramModule } from './module/telegram/telegram.module';
import { UserModule } from './module/user/user.module';
import { AccountModule } from './module/account/account.module';
import { CacheModule } from '@nestjs/cache-manager';
import { ProxyModule } from './module/proxy/proxy.module';
import { HttpModule } from './module/http/http.module';
import { OrderModule } from './module/order/order.module';
import { ZennoModule } from './module/zenno/zenno.module';
import { AuthModule } from './module/auth/auth.module';
import { MirrorModule } from './module/mirror/mirror.module';
import { SharedModule } from './module/shared/shared.module';
import { BottModule } from './module/bott/bott.module';
import { PaymentModule } from './module/payment/payment.module';
import { ScheduleModule } from '@nestjs/schedule';
import { CronModule } from './module/cron/cron.module';
import { WebappModule } from './module/webapp/webapp.module';
import { CouponModule } from './module/coupon/coupon.module';

@Module({
    imports: [
        ConfigModule.forRoot({
            isGlobal: true,
        }),
        ScheduleModule.forRoot(),
        CacheModule.register({
            isGlobal: true,
            ttl: 18000000,
            max: 1000,
        }),
        TelegrafModule.forRootAsync(getTelegramConfig()),
        AuthModule,
        TelegramModule,
        UserModule,
        AccountModule,
        ProxyModule,
        HttpModule,
        OrderModule,
        ZennoModule,
        MirrorModule,
        BottModule,
        SharedModule,
        PaymentModule,
        CronModule,
        WebappModule,
        CouponModule,
    ],
})
export class AppModule {}

```

src/main.ts:
```
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ZodValidationPipe } from 'nestjs-zod';
import { join } from 'path';
import { NestExpressApplication } from '@nestjs/platform-express';
import './common/helpers/hbs.helper';
import { engine } from 'express-handlebars';
import { handlebarsHelpers } from '@common/helpers/hbs.helper';
import { ConfigService } from '@nestjs/config';
import { DEVELOPMENT_STRATEGY, PinoService, PRODUCTION_STRATEGY } from './module/logger';
import { APP_NAME, APP_VERSION } from './app.constants';

async function bootstrap() {
    const pinoStrategy = process.env.NODE_ENV === 'production' ? PRODUCTION_STRATEGY : DEVELOPMENT_STRATEGY;
    const logger = new PinoService(pinoStrategy);

    const app = await NestFactory.create<NestExpressApplication>(AppModule, { logger });
    app.setGlobalPrefix('api');
    app.useGlobalPipes(new ZodValidationPipe());
    app.enableCors();
    app.useStaticAssets(join(__dirname, '..', 'public'));
    app.setBaseViewsDir(join(__dirname, '..', 'views'));
    app.engine(
        'hbs',
        engine({
            extname: 'hbs',
            helpers: handlebarsHelpers,
            defaultLayout: false,
        }),
    );
    const configService = app.get(ConfigService);

    const PORT = configService.getOrThrow('PORT', 3001);
    const HOST = configService.getOrThrow<string>('HOST', 'localhost');

    app.setViewEngine('hbs');
    await app.listen(PORT, HOST);

    const context = 'Bootstrap';
    logger.log(`Listening on ${JSON.stringify(app.getHttpServer().address())}`, context);
    logger.log(`Application "${APP_NAME}" version ${APP_VERSION} has started`, context);
}
bootstrap();

```

src/common/database/database.module.ts:
```
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
    providers: [PrismaService],
    exports: [PrismaService],
})
export class DatabaseModule {}

```

src/common/database/index.ts:
```
export * from './database.module';

```

src/common/database/prisma.client.ts:
```
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient().$extends({
    name: 'StatusHistoryExtension',
    query: {
        paymentOrder: {
            async update({ args, query }) {
                // Проверяем, изменяется ли статус
                const newStatus = args.data.status;

                // Выполняем обновление PaymentOrder
                const result = await query(args);

                if (newStatus) {
                    // Записываем историю изменения статуса
                    await prisma.paymentOrderStatusHistory.create({
                        data: {
                            paymentOrderId: result.id,
                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            //@ts-ignore
                            status: newStatus,
                        },
                    });
                }

                return result;
            },
        },
    },
});

```

src/common/database/prisma.service.ts:
```
import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
    async onModuleInit() {
        await this.$connect();
    }

    async onModuleDestroy() {
        await this.$disconnect();
    }
}

```

src/common/decorators/roles.decorator.ts:
```
import { SetMetadata, applyDecorators, UseGuards } from '@nestjs/common';
import { AccessTokenGuard } from '../../module/auth/guard/accessToken.guard';
import { RolesGuard } from '../../module/auth/guard/roles.guard';

export enum RoleEnum {
    USER = 'User',
    ADMIN = 'Admin',
}

export const HasRoles = ([...roles]: RoleEnum[]) => {
    return applyDecorators(
        SetMetadata('roles', roles),
        UseGuards(AccessTokenGuard, RolesGuard)
    );
};

```

src/common/decorators/user.decorator.ts:
```
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
});

```

src/common/decorators/zenno.decorator.ts:
```
import { applyDecorators, UseGuards } from '@nestjs/common';
import { ZennoGuard } from '../../module/account/guard/zenno.guard';

export const HasZenno = () => {
    return applyDecorators(UseGuards(ZennoGuard));
};

```

src/common/helpers/hbs.helper.ts:
```
import * as hbs from 'handlebars';

export const handlebarsHelpers = {
    digitSeparator: (value: number) => {
        return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
    },
    formatDate: (dateString: string) => {
        if (!dateString) return '';
        const date = new Date(dateString);
        const months = [
            'января',
            'февраля',
            'марта',
            'апреля',
            'мая',
            'июня',
            'июля',
            'августа',
            'сентября',
            'октября',
            'ноября',
            'декабря',
        ];
        return `${date.getDate()} ${months[date.getMonth()]}, ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
    },
    formatDateRange: (startDateString: string, endDateString: string) => {
        if (!startDateString) return '';
        const startDate = new Date(startDateString);
        const months = [
            'января',
            'февраля',
            'марта',
            'апреля',
            'мая',
            'июня',
            'июля',
            'августа',
            'сентября',
            'октября',
            'ноября',
            'декабря',
        ];
        const formattedStartDate = `${startDate.getDate()} ${months[startDate.getMonth()]}, ${startDate.getHours()}:${startDate.getMinutes().toString().padStart(2, '0')}`;

        if (!endDateString) return formattedStartDate;
        const endDate = new Date(endDateString);
        const formattedEndDate = `${endDate.getDate()} ${months[endDate.getMonth()]}, ${endDate.getHours()}:${endDate.getMinutes().toString().padStart(2, '0')}`;

        return `${formattedStartDate} - ${formattedEndDate}`;
    },
    getPaymentStatus: (isPayed: boolean) => {
        return isPayed ? 'Оплачен' : 'Не оплачен';
    },
    getItemName: (count: number) => {
        const numItems: { [key: number]: string } = {
            1: 'товар',
            2: 'товара',
            3: 'товара',
            4: 'товара',
            5: 'товаров',
        };
        return numItems[count] || numItems[5];
    },
    formatPhone: (phone: string) => {
        const phoneStr = phone.toString();
        return phoneStr.replace(/(\d{3})(\d{3})(\d{2})(\d{2})/, '$1 $2 $3 $4');
    },
    divide: (value: number, divisor: number) => {
        return value / divisor;
    },
    trim: (str: string) => {
        return str.trim();
    },
    equals: (a: any, b: any) => {
        return a === b;
    },
    extractTrackNumber: (trackUrl: string) => {
        if (!trackUrl) return '';
        const parts = trackUrl.split('?');
        return parts[1] || '';
    },
    removeImagePath: (url: string) => {
        if (!url) return '';
        return url.replace('/{width}_{height}_{hash}', '');
    },
    or: (a: any, b: any) => {
        return a || b;
    },
};

Object.entries(handlebarsHelpers).forEach(([name, fn]) => {
    hbs.registerHelper(name, fn);
});

```

src/common/jwt/jwt.config.ts:
```
import { JwtModuleAsyncOptions } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';

export const getJWTConfig = (): JwtModuleAsyncOptions => ({
    imports: [ConfigModule],
    inject: [ConfigService],
    useFactory: (configService: ConfigService) => ({
        global: true,
        secret: configService.getOrThrow('ACCESS_TOKEN_JWT_SECRET'),
        signOptions: {
            expiresIn: configService.getOrThrow('ACCESS_TOKEN_EXPIRATION'),
        },
    }),
});

```

src/common/middleware/session.middleware.ts:
```
import { session } from 'telegraf';

export const sessionMiddleware = session();

```

src/common/telegram/telegram.config.ts:
```
import { sessionMiddleware } from '@common/middleware/session.middleware';
import { ConfigModule, ConfigService } from '@nestjs/config';

export const getTelegramConfig = () => ({
    imports: [ConfigModule],
    inject: [ConfigService],
    useFactory: (configService: ConfigService) => ({
        token: configService.getOrThrow('TELEGRAM_TOKEN'),
        middlewares: [sessionMiddleware],
        include: [],
    }),
});

```

src/module/account/account.controller.ts:
```
import { Body, Controller, Get, HttpCode, NotFoundException, Param, Patch, Post, Put } from '@nestjs/common';
import { AccountService } from './account.service';
import { HasZenno } from '@common/decorators/zenno.decorator';
import { AddingAccountRequestDto } from './dto/create-account.dto';
import { UpdatingAccountRequestDto } from './dto/update-tokens-account.dto';
import { AccountIdParamsDto } from './dto/uuid-account.dto';
import { UpdateAccountRequestDto, UpdateAccountResponseDto } from './dto/update-account.dto';
import { IsEmailRequestDto, IsEmailResponseDto } from './dto/isEmail-account.dto';
import { Account } from '@prisma/client';
import { UpdatingBonusCountRequestDto, UpdatingBonusCountResponseDto } from './dto/updateBonusCount-account.dto';
import { UpdatePushTokenRequestDto, UpdatePushTokenResponseDto } from './dto/updatePushToken-account.dto';
import { UpdateGoogleIdRequestDto, UpdateGoogleIdResponseDto } from './dto/updateGoogleId-account.dto';
import { AxiosError } from 'axios';
import { UpdatingCourseTokensAccountRequestDto } from './dto/update-course-tokens-account.dto';
import { CourseService } from './course.service';
import { UpdateCourseStatusRequestDto } from './dto/updateCourseStatus-course';
import { CourseData } from './interfaces/course-data.interface';
import { ERROR_ACCOUNT_NOT_FOUND } from './constants/error.constant';
import { UpdatingCookieRequestDto, UpdatingCookieResponseDto } from './dto/updateCookie-account.dto';
import { DeviceInfoRequestDto, DeviceInfoResponseDto } from './dto/create-deviceInfo.dto';
import { DeviceInfoService } from './deviceInfo.service';
import { CourseIdAccountRequestDto } from './dto/course-account.dto';
import { UpdatingCourseStatusAccountRequestDto } from './dto/update-course-status-account.dto';

@Controller('account')
export class AccountController {
    constructor(
        private accountService: AccountService,
        private courseService: CourseService,
        private deviceInfoService: DeviceInfoService,
    ) {}

    @HasZenno()
    @Post()
    @HttpCode(200)
    async addAccount(@Body() dto: AddingAccountRequestDto): Promise<string> {
        const account = await this.accountService.addingAccount(dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Get(':accountId')
    @HttpCode(200)
    async getAccount(@Param() params: AccountIdParamsDto): Promise<Account> {
        const accountEntity = await this.accountService.getFullAccount(params.accountId);
        return {
            ...accountEntity,
            cookie: JSON.parse(accountEntity.cookie),
        };
    }

    @HasZenno()
    @Patch(':accountId/token')
    @HttpCode(200)
    async updateTokenAccount(@Body() dto: UpdatingAccountRequestDto, @Param() params: AccountIdParamsDto): Promise<string> {
        const account = await this.accountService.updateTokensAccount(params.accountId, dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Patch('/course/token/:accountId')
    @HttpCode(200)
    async updateCourseTokenAccount(
        @Body() dto: UpdatingCourseTokensAccountRequestDto,
        @Param() params: AccountIdParamsDto,
    ): Promise<string> {
        const account = await this.accountService.updateCourseTokensAccount(params.accountId, dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Patch('course/status/:accountId')
    @HttpCode(200)
    async updateCourseStatusAccount(
        @Body() dto: UpdatingCourseStatusAccountRequestDto,
        @Param() params: AccountIdParamsDto,
    ): Promise<string> {
        const account = await this.accountService.updateStatusAccountCourseDto(params.accountId, dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Post('course/activate/:accountId')
    @HttpCode(200)
    async activateCourseAccount(@Body() dto: CourseIdAccountRequestDto, @Param() params: AccountIdParamsDto): Promise<string> {
        const account = await this.accountService.activateCourseAccount(params.accountId, dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Get('courses/isconnection/:accountId')
    @HttpCode(200)
    async isCourseAddingAccount(@Param() params: AccountIdParamsDto): Promise<any> {
        const courses = await this.accountService.getAccountCoursesOrSynchronized(params.accountId);
        if (courses.length != 0) return;
        throw new NotFoundException(ERROR_ACCOUNT_NOT_FOUND);
    }

    @HasZenno()
    @Post('courses/connection/:accountId')
    @HttpCode(200)
    async connectionCourseAccount(@Param() params: AccountIdParamsDto): Promise<void> {
        await this.accountService.connectionCourseAccount(params.accountId);
    }

    @HasZenno()
    @Put(':accountId')
    @HttpCode(200)
    async updateAccount(@Body() dto: UpdateAccountRequestDto, @Param() params: AccountIdParamsDto): Promise<UpdateAccountResponseDto> {
        const account = await this.accountService.updateAccount(params.accountId, dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Post('isEmail')
    @HttpCode(200)
    async isEmail(@Body() dto: IsEmailRequestDto): Promise<IsEmailResponseDto> {
        const isEmail = await this.accountService.findAccountByEmail(dto.email);
        return { isEmail: !!isEmail };
    }

    @HasZenno()
    @Patch(':accountId/bonusCount')
    @HttpCode(200)
    async updateBonusCountAccount(
        @Body() dto: UpdatingBonusCountRequestDto,
        @Param() params: AccountIdParamsDto,
    ): Promise<UpdatingBonusCountResponseDto> {
        const account = await this.accountService.updateAccountBonusCount(params.accountId, dto);
        return account ? 'success' : 'error';
    }

    @HasZenno()
    @Patch(':accountId/pushToken')
    @HttpCode(200)
    async updatePushTokenAccount(
        @Body() dto: UpdatePushTokenRequestDto,
        @Param() params: AccountIdParamsDto,
    ): Promise<UpdatePushTokenResponseDto> {
        return await this.accountService.updatePushToken(params.accountId, dto);
    }

    @HasZenno()
    @Patch(':accountId/googleId')
    @HttpCode(200)
    async updateGoogleIdAccount(
        @Body() dto: UpdateGoogleIdRequestDto,
        @Param() params: AccountIdParamsDto,
    ): Promise<UpdateGoogleIdResponseDto> {
        return await this.accountService.updateGoogleId(params.accountId, dto);
    }

    @HasZenno()
    @Patch(':accountId/cookie')
    @HttpCode(200)
    async updateCookieAccount(
        @Body() dto: UpdatingCookieRequestDto,
        @Param() params: AccountIdParamsDto,
    ): Promise<UpdatingCookieResponseDto> {
        return await this.accountService.updateCookie(params.accountId, dto);
    }

    @Get('cookie/:accountId')
    @HttpCode(200)
    async getCookieAccount(@Param() params: AccountIdParamsDto) {
        const accountEntity = await this.accountService.getAccountCookie(params.accountId);
        return {
            cookie: JSON.parse(accountEntity.cookie),
        };
    }

    @HasZenno()
    @Get(':accountId/courses')
    @HttpCode(200)
    async getCoursesAccount(@Param() params: AccountIdParamsDto): Promise<any> {
        return await this.accountService.getCoursesList(params.accountId);
    }

    @Get('checking/:accountId')
    @HttpCode(200)
    async getBonusAccount(@Param() params: AccountIdParamsDto): Promise<any> {
        try {
            return await this.accountService.shortInfo(params.accountId);
        } catch (err: any) {
            return this.handleError(err);
        }
    }

    private handleError(err: any): { error: string } {
        let errorMessage = '';
        if (err instanceof NotFoundException) {
            errorMessage = `Не найден`;
        } else if (err instanceof AxiosError) {
            const errorResponse = err.response?.data?.error;
            errorMessage = errorResponse?.message || 'Ошибка запроса, повторите';
        } else {
            errorMessage = err.message || 'Неизвестная ошибка';
        }
        return { error: errorMessage };
    }

    @HasZenno()
    @Patch('courses/status/:accountId')
    @HttpCode(200)
    async courseUnblock(@Body() dto: UpdateCourseStatusRequestDto, @Param() params: AccountIdParamsDto): Promise<void> {
        await this.courseService.changeStatusCourse(params.accountId, dto.courseId, dto.status);
    }

    @HasZenno()
    @Post('courses/synchronization/:accountId')
    @HttpCode(200)
    async synchronizationCourse(@Body() data: CourseData, @Param() params: AccountIdParamsDto): Promise<string> {
        return this.courseService.synchronizationCourse(params.accountId, data);
    }

    @HasZenno()
    @Post(':accountId/device')
    @HttpCode(200)
    async addDeviceInfo(@Param() params: AccountIdParamsDto, @Body() deviceInfoDto: DeviceInfoRequestDto): Promise<DeviceInfoResponseDto> {
        return this.accountService.addDeviceInfo(params.accountId, deviceInfoDto);
    }

    @HasZenno()
    @Put(':accountId/device')
    @HttpCode(200)
    async updateDeviceInfo(
        @Param() params: AccountIdParamsDto,
        @Body() deviceInfoDto: DeviceInfoRequestDto,
    ): Promise<DeviceInfoResponseDto> {
        return this.deviceInfoService.updateDeviceInfo(params.accountId, deviceInfoDto);
    }
}

```

src/module/account/account.module.ts:
```
import { Module } from '@nestjs/common';
import { AccountController } from './account.controller';
import { AccountService } from './account.service';
import { AccountRepository } from './account.repository';
import { SportmasterHeadersService } from './entities/headers.entity';
import { ProxyModule } from '../proxy/proxy.module';
import { HttpModule } from '../http/http.module';
import { CourseService } from './course.service';
import { CourseRepository } from './course.repository';
import { DeviceInfoService } from './deviceInfo.service';
import { DeviceInfoRepository } from './deviceInfo.repository';

@Module({
    controllers: [AccountController],
    providers: [
        AccountService,
        AccountRepository,
        SportmasterHeadersService,
        CourseService,
        CourseRepository,
        DeviceInfoService,
        DeviceInfoRepository,
    ],
    exports: [AccountService, SportmasterHeadersService, CourseService],
    imports: [ProxyModule, HttpModule],
})
export class AccountModule {}

```

src/module/account/account.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { Account, CourseStatus, Order, Prisma } from '@prisma/client';
import { PrismaService } from '@common/database/prisma.service';
import { AccountEntity } from './entities/account.entity';
import { IAccountWithProxy, ICourseTokens, IEmailFromDb, IRefreshDataAccount, IUpdateAccount } from './interfaces/account.interface';
import { CitySMEntity } from './entities/citySM.entity';
import { IAccountCourseWLesson } from './interfaces/course.interface';

@Injectable()
export class AccountRepository {
    constructor(private prisma: PrismaService) {}

    async addingAccount(account: AccountEntity): Promise<Account> {
        const accountData: Prisma.AccountCreateInput = {
            accountId: account.accountId,
            email: account.email,
            passImap: account.passImap,
            passEmail: account.passEmail,
            cookie: account.cookie,
            accessToken: account.accessToken,
            refreshToken: account.refreshToken,
            xUserId: account.xUserId,
            deviceId: account.deviceId,
            installationId: account.installationId,
            googleId: account.googleId,
            pushToken: account.pushToken,
            expiresInAccess: account.expiresInAccess,
            expiresInRefresh: account.expiresInRefresh,
            accessTokenCourse: account.accessTokenCourse,
            refreshTokenCourse: account.refreshTokenCourse,
            userGateToken: account.userGateToken,
            statusCourse: account.statusCourse,
            isValidAccessTokenCourse: account.isValidAccessTokenCourse,
            isAccessMp: account.isAccessMp,
            isAccessCookie: account.isAccessCookie,
            isOnlyAccessOrder: account.isOnlyAccessOrder,
            bonusCount: account.bonusCount,
            isUpdateBonus: account.isUpdateBonus,
            createdAt: account.createdAt,
            updatedAt: account.updatedAt,
            citySM: {
                connect: {
                    cityId: account.cityId,
                },
            },
            ownerTelegram: {
                connect: {
                    telegramId: account.ownerTelegramId,
                },
            },
            proxy: account.proxyUuid
                ? {
                      connect: {
                          uuid: account.proxyUuid,
                      },
                  }
                : undefined,
        };

        return this.prisma.account.create({
            data: accountData,
        });
    }

    async getAccount(accountId: string): Promise<Account | null> {
        return this.prisma.account.findUnique({
            where: { accountId },
        });
    }

    async getOrder(orderNumber: string): Promise<Order | null> {
        return this.prisma.order.findFirst({
            where: { orderNumber },
        });
    }

    async getAccountWithProxy(accountId: string): Promise<IAccountWithProxy | null> {
        return this.prisma.account.findUnique({
            where: { accountId },
            include: {
                proxy: true,
                citySM: true,
            },
        });
    }

    async setProxyAccount(accountId: string, proxyUuid: string): Promise<IAccountWithProxy> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                proxy: {
                    connect: {
                        uuid: proxyUuid,
                    },
                },
            },
            include: {
                proxy: true,
                citySM: true,
            },
        });
    }

    async getAccountCookie(accountId: string) {
        return this.prisma.account.findUnique({
            where: { accountId },
            select: {
                cookie: true,
            },
        });
    }

    async getAccountEmail(accountId: string): Promise<IEmailFromDb | null> {
        return this.prisma.account.findUnique({
            where: { accountId },
            select: {
                email: true,
                passImap: true,
                passEmail: true,
            },
        });
    }

    async getEmail(email: string): Promise<Account | null> {
        return this.prisma.account.findFirst({
            where: { email },
        });
    }

    async updateAccount(
        accountId: string,
        {
            accessToken,
            refreshToken,
            xUserId,
            deviceId,
            installationId,
            expiresInAccess,
            expiresInRefresh,
            isAccessMp,
            userGateToken,
            accessTokenCourse,
            refreshTokenCourse,
            isValidAccessTokenCourse,
        }: IUpdateAccount,
    ): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                accessToken,
                refreshToken,
                xUserId,
                deviceId,
                installationId,
                expiresInAccess,
                expiresInRefresh,
                isAccessMp,
                userGateToken,
                accessTokenCourse,
                refreshTokenCourse,
                isValidAccessTokenCourse,
            },
        });
    }

    async updateTokensAccount(
        accountId: string,
        { accessToken, refreshToken, expiresInAccess, expiresInRefresh }: IRefreshDataAccount,
    ): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                accessToken,
                refreshToken,
                expiresInAccess,
                expiresInRefresh,
            },
        });
    }

    async updateCourseTokensAccount(
        accountId: string,
        { userGateToken, accessTokenCourse, refreshTokenCourse, isValidAccessTokenCourse }: ICourseTokens,
    ): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                userGateToken,
                accessTokenCourse,
                refreshTokenCourse,
                isValidAccessTokenCourse,
            },
        });
    }

    async updateStatusAccountCourse(accountId: string, statusCourse: CourseStatus): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                statusCourse,
            },
        });
    }

    async setBanMp(accountId: string): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                isAccessMp: false,
            },
        });
    }

    async updateUserGateToken(accountId: string, userGateToken: string): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                userGateToken,
            },
        });
    }

    async updateBonusCount(accountId: string, bonusCount: number): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                bonusCount,
            },
        });
    }

    async updatePushToken(accountId: string, pushToken: string): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                pushToken,
            },
        });
    }

    async updateGoogleId(accountId: string, googleId: string): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                googleId,
            },
        });
    }

    async updateCookie(accountId: string, cookie: string): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                cookie,
            },
        });
    }

    async promblemCourses(accountId: string): Promise<Account> {
        return this.prisma.account.update({
            where: {
                accountId,
            },
            data: {
                statusCourse: 'NONE',
            },
        });
    }

    // async finishedCourses(accountId: string): Promise<Account> {
    //     return this.prisma.account.update({
    //         where: {
    //             accountId,
    //         },
    //         data: {
    //             statusCourse: 'FINISHED',
    //         },
    //     });
    // }

    async setCityToAccount(accountId: string, cityId: string): Promise<Account> {
        return this.prisma.account.update({
            where: { accountId },
            data: { cityId },
        });
    }

    async addingCitySM(city: CitySMEntity): Promise<CitySMEntity> {
        return this.prisma.citySM.create({
            data: {
                cityId: city.cityId,
                name: city.name,
                fullName: city.fullName,
            },
        });
    }

    async addOrderNumber(accountId: string, orderNumber: string): Promise<Order> {
        return this.prisma.order.create({
            data: {
                orderNumber,
                accountId,
            },
        });
    }

    async getActiveCourseAccount() {
        const accounts = await this.prisma.account.findMany({
            where: {
                statusCourse: 'ACTIVE',
            },
            select: {
                accountId: true,
            },
        });

        return accounts.map(account => account.accountId);
    }

    async addAccountCourses(accountId: string): Promise<void> {
        const courses = await this.prisma.originalCourse.findMany();
        const data = courses.map(course => ({
            accountId,
            courseId: course.courseId,
            status: CourseStatus.BLOCKED,
        }));
        await this.prisma.accountCourse.createMany({
            data,
        });
    }

    async getAccountCoursesWithProgress(accountId: string): Promise<IAccountCourseWLesson[]> {
        const accountCourses = await this.prisma.accountCourse.findMany({
            where: {
                accountId: accountId,
            },
            include: {
                course: {
                    include: {
                        lessons: {
                            include: {
                                AccountLessonProgress: {
                                    where: {
                                        accountId: accountId,
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        return accountCourses
            .map(accountCourse => {
                return {
                    ...accountCourse,
                    course: {
                        ...accountCourse.course,
                        lessons: accountCourse.course.lessons
                            .map(lesson => ({
                                ...lesson,
                                AccountLessonProgress: lesson.AccountLessonProgress.filter(progress => progress.accountId === accountId),
                            }))
                            .sort((a, b) => a.position - b.position),
                    },
                };
            })
            .sort((a, b) => a.course.courseId.localeCompare(b.course.courseId));
    }
}

```

src/module/account/account.service.ts:
```
import { HttpException, HttpStatus, Injectable, Logger, NotFoundException } from '@nestjs/common';
import { AccountRepository } from './account.repository';
import { AddingAccountRequestDto } from './dto/create-account.dto';
import { AccountEntity } from './entities/account.entity';
import { AccountWDevice, IAccountWithProxy, IFindCitiesAccount, IRecipientOrder, IRefreshAccount } from './interfaces/account.interface';
import { CourseStatus, LessonStatus, Order } from '@prisma/client';
import { ProxyService } from '../proxy/proxy.service';
import {
    ERROR_ACCESS_TOKEN_COURSE,
    ERROR_ACCOUNT_NOT_FOUND,
    ERROR_COURSE_NOT_FOUND,
    ERROR_GET_ACCESS_TOKEN_COURSE,
    ERROR_LOGOUT_MP,
    ERROR_PROGRESS_ID,
} from './constants/error.constant';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '../http/http.service';
import { SocksProxyAgent } from 'socks-proxy-agent';
import { AccountWithProxyEntity } from './entities/accountWithProxy.entity';
import { CitySMEntity } from './entities/citySM.entity';
import { CartInterface } from './interfaces/cart.interface';
import { IItemsCart, selectMainFromCart } from '../telegram/utils/cart.utils';
import { SearchProductInterface } from './interfaces/search-product.interface';
import { PickupAvabilityInterface } from './interfaces/pickup-avability.interface';
import { OrdersInterface } from './interfaces/orders.interface';
import { OrderInfoInterface } from './interfaces/order-info.interface';
import { ShortInfoInterface } from './interfaces/short-info.interface';
import { PromocodeInterface } from './interfaces/promocode.interface';
import { RefreshTokensEntity } from './entities/refreshTokens.entity';
import { UpdateAccountRequestDto } from './dto/update-account.dto';
import { AccountUpdateEntity } from './entities/accountUpdate.entity';
import { UpdatingBonusCountRequestDto } from './dto/updateBonusCount-account.dto';
import { UpdatePushTokenRequestDto } from './dto/updatePushToken-account.dto';
import { UpdateGoogleIdRequestDto } from './dto/updateGoogleId-account.dto';
import { v4 as uuidv4 } from 'uuid';
import { SportmasterHeadersService } from './entities/headers.entity';
import { UserGateTokenInterface } from './interfaces/userGateToken.interface';
import { CourseList } from './interfaces/course-list.interface';
import { CourseService } from './course.service';
import { CourseWithLessons, IWatchLesson } from './interfaces/course.interface';
import { CourseTokensEntity } from './entities/courseTokens.entity';
import { UpdatingCourseTokensAccountRequestDto } from './dto/update-course-tokens-account.dto';
import { UpdatingCookieRequestDto } from './dto/updateCookie-account.dto';
import { DeviceInfoService } from './deviceInfo.service';
import { IDeviceInfo } from './interfaces/deviceInfo.interface';
import { DeviceInfoRequestDto } from './dto/create-deviceInfo.dto';
import { CourseIdAccountRequestDto } from './dto/course-account.dto';
import { UpdatingCourseStatusAccountRequestDto } from './dto/update-course-status-account.dto';
import { TlsProxyService } from '../http/tls-forwarder.service';

@Injectable()
export class AccountService {
    private readonly logger = new Logger(AccountService.name);
    private url = this.configService.getOrThrow('API_DONOR');
    private urlSite = this.configService.getOrThrow('API_DONOR_SITE');
    private adminsId: string[] = this.configService.getOrThrow('TELEGRAM_ADMIN_ID').split(',');
    private durationTimeProxyBlock = this.configService.getOrThrow('TIME_DURATION_PROXY_BLOCK_IN_MIN');

    constructor(
        private configService: ConfigService,
        private accountRep: AccountRepository,
        private proxyService: ProxyService,
        private readonly tlsForwarder: TlsProxyService,
        private httpService: HttpService,
        private courseService: CourseService,
        private deviceInfoService: DeviceInfoService,
        private sportmasterHeaders: SportmasterHeadersService,
    ) {}

    async addingAccount(accountDto: AddingAccountRequestDto): Promise<AccountEntity> {
        const {
            accountId,
            email,
            passImap,
            passEmail,
            cookie,
            accessToken,
            refreshToken,
            googleId,
            accessTokenCourse,
            refreshTokenCourse,
            userGateToken,
            xUserId,
            deviceId,
            installationId,
            expiresIn,
            bonusCount,
            isOnlyAccessOrder,
            statusCourse,
        } = accountDto;

        const refreshTokensEntity = new RefreshTokensEntity({ accessToken, refreshToken, expiresIn });

        const account = new AccountEntity({
            accountId,
            email,
            passImap,
            passEmail,
            cookie,
            accessToken: refreshTokensEntity.accessToken,
            refreshToken: refreshTokensEntity.refreshToken,
            accessTokenCourse,
            refreshTokenCourse,
            userGateToken,
            isValidAccessTokenCourse: true,
            statusCourse: statusCourse ? statusCourse : 'NONE',
            xUserId,
            deviceId,
            installationId,
            googleId,
            expiresInAccess: refreshTokensEntity.expiresInAccess,
            expiresInRefresh: refreshTokensEntity.expiresInRefresh,
            bonusCount: +bonusCount,
            isOnlyAccessOrder: Boolean(isOnlyAccessOrder),
            ownerTelegramId: this.adminsId[0],
        });
        await this.accountRep.addingAccount(account);
        await this.initializeAccountProgress(account.accountId);
        return account;
    }

    async initializeAccountProgress(accountId: string): Promise<void> {
        const courses = await this.courseService.getCoursesWithLessons();

        for (const course of courses) {
            await this.createAccountCourseAndLessons(accountId, course);
        }
    }

    async getAccountCoursesOrSynchronized(accountId: string): Promise<string[]> {
        const coursesInAccount = await this.courseService.getIsAccountCourses(accountId);
        if (coursesInAccount.length == 0) return [];
        const allCoursesId = this.courseService.coursesId;
        const notAvalibleCourses: string[] = [];

        for (const courseId of allCoursesId) {
            if (coursesInAccount.includes(courseId)) continue;
            notAvalibleCourses.push(courseId);
        }

        if (notAvalibleCourses.length != 0) {
            const courses = await this.courseService.getCoursesWithLessons();
            for (const courseId of notAvalibleCourses) {
                const course = courses.find(course => course.courseId == courseId);
                if (!course) throw new NotFoundException(ERROR_COURSE_NOT_FOUND);
                await this.createAccountCourseAndLessons(accountId, course);
            }
        }
        const isExist = await this.checkOnExistProgressLesson(accountId);

        if (!isExist) {
            const lessons = await this.courseService.getAllLesson();
            await this.courseService.createAccountLessonProgressFromExistCourses(accountId, lessons);
        }
        return coursesInAccount;
    }

    async checkOnExistProgressLesson(accountId: string) {
        const lessonsProgress = await this.courseService.getLessonsProgressByAccountId(accountId);
        return lessonsProgress.length != 0;
    }

    async createAccountCourseAndLessons(accountId: string, course: CourseWithLessons) {
        await this.courseService.createAccountCourse(accountId, course);
        await this.courseService.createAccountLessonProgress(accountId, course.lessons);
    }

    async getAccount(accountId: string): Promise<AccountEntity> {
        const account = await this.accountRep.getAccount(accountId);
        if (!account) throw new NotFoundException(ERROR_ACCOUNT_NOT_FOUND);

        return new AccountEntity(account);
    }

    async getAccountCookie(accountId: string) {
        const account = await this.accountRep.getAccountCookie(accountId);
        if (!account) throw new NotFoundException(ERROR_ACCOUNT_NOT_FOUND);

        return new AccountEntity(account);
    }

    async getFullAccount(accountId: string): Promise<AccountWDevice> {
        const account = await this.getAccount(accountId);

        let deviceInfo: IDeviceInfo | null = null;
        try {
            deviceInfo = await this.deviceInfoService.getDeviceInfo(accountId);
        } catch (error) {
            //null
        }

        return {
            ...account,
            deviceInfo,
        };
    }

    async findAccountEmail(accountId: string) {
        return await this.accountRep.getAccountEmail(accountId);
    }

    async findAccountByEmail(email: string) {
        return await this.accountRep.getEmail(email);
    }

    async findOrderNumber(orderNumber: string) {
        return await this.accountRep.getOrder(orderNumber);
    }

    async setBanMp(accountId: string) {
        return await this.accountRep.setBanMp(accountId);
    }

    async updateAccountBonusCount(accountId: string, data: UpdatingBonusCountRequestDto) {
        await this.getAccount(accountId);
        return await this.updateAccountBonusCountPrivate(accountId, data.bonusCount);
    }

    private async updateAccountBonusCountPrivate(accountId: string, bonusCount: number) {
        return await this.accountRep.updateBonusCount(accountId, bonusCount);
    }

    async updateAccount(accountId: string, dto: UpdateAccountRequestDto) {
        await this.getAccount(accountId);

        const updateAccountEntity = new AccountUpdateEntity(dto);
        return await this.accountRep.updateAccount(accountId, updateAccountEntity);
    }

    async updateTokensAccount(accountId: string, dataAccount: IRefreshAccount) {
        await this.getAccount(accountId);
        return await this.updateTokensAccountPrivate(accountId, dataAccount);
    }

    private async updateTokensAccountPrivate(accountId: string, dataAccount: IRefreshAccount): Promise<RefreshTokensEntity> {
        const refreshTokensEntity = new RefreshTokensEntity(dataAccount);
        await this.accountRep.updateTokensAccount(accountId, refreshTokensEntity);
        return refreshTokensEntity;
    }

    async updateCourseTokensAccount(accountId: string, data: UpdatingCourseTokensAccountRequestDto) {
        await this.getAccount(accountId);
        return await this.updateCourseTokensAccountPrivate(accountId, data);
    }

    async activateCourseAccount(accountId: string, { courseId }: CourseIdAccountRequestDto) {
        await this.getAccount(accountId);
        //активировать курс
        await this.courseService.changeStatusCourse(accountId, courseId, CourseStatus.ACTIVE);

        const progressIdFirstLesson = await this.courseService.getFirstLessonProgressId(accountId, courseId);
        if (!progressIdFirstLesson) throw new NotFoundException(ERROR_PROGRESS_ID);
        //активировать первый урок
        return this.courseService.updateViewLesson(progressIdFirstLesson, LessonStatus.NONE);
    }

    async updateStatusAccountCourseDto(accountId: string, { statusCourse }: UpdatingCourseStatusAccountRequestDto) {
        return await this.updateStatusAccountCourse(accountId, statusCourse);
    }

    async updateStatusAccountCourse(accountId: string, statusCourse: CourseStatus) {
        return await this.accountRep.updateStatusAccountCourse(accountId, statusCourse);
    }

    async connectionCourseAccount(accountId: string) {
        const account = await this.getAccount(accountId);

        const lessons = await this.courseService.getAllLesson();
        try {
            await this.accountRep.addAccountCourses(accountId);
            await this.courseService.createAccountLessonProgress(account.accountId, lessons);
        } catch (e) {
            await this.courseService.createAccountLessonProgressFromExistCourses(account.accountId, lessons);
        }
    }

    private async updateCourseTokensAccountPrivate(
        accountId: string,
        dataAccount: UpdatingCourseTokensAccountRequestDto,
    ): Promise<CourseTokensEntity> {
        const courseTokensEntity = new CourseTokensEntity({
            ...dataAccount,
            isValidAccessTokenCourse: true,
        });
        await this.accountRep.updateCourseTokensAccount(accountId, courseTokensEntity);
        return courseTokensEntity;
    }

    async addDeviceInfo(accountId: string, deviceInfoDto: DeviceInfoRequestDto) {
        await this.getAccount(accountId);
        return this.deviceInfoService.addDeviceInfo(accountId, deviceInfoDto);
    }

    async updateGoogleId(accountId: string, data: UpdateGoogleIdRequestDto): Promise<{ googleId: string }> {
        await this.getAccount(accountId);

        const googleId = data.googleId || uuidv4();
        await this.accountRep.updateGoogleId(accountId, googleId);
        return { googleId };
    }

    async updateCookie(accountId: string, data: UpdatingCookieRequestDto): Promise<{ cookie: string }> {
        await this.getAccount(accountId);

        return this.accountRep.updateCookie(accountId, data.cookie);
    }

    async updatePushToken(accountId: string, data: UpdatePushTokenRequestDto): Promise<{ pushToken: string }> {
        await this.getAccount(accountId);

        const pushToken = data.pushToken || this.generateFCMLikeToken();
        await this.accountRep.updatePushToken(accountId, pushToken);
        return { pushToken };
    }

    async createAccessTokenCourse(accountWithProxyEntity: AccountWithProxyEntity): Promise<{
        accessTokenCourse: string;
    }> {
        if (!accountWithProxyEntity.userGateToken) {
            const respUserGateToken = await this.getUserGateToken(accountWithProxyEntity);
            const userGateToken = respUserGateToken.data.userGateToken;
            await this.accountRep.updateUserGateToken(accountWithProxyEntity.accountId, userGateToken);
            accountWithProxyEntity = await this.getAccountEntity(accountWithProxyEntity.accountId);
        }

        const htmlCourse = await this.getCoursesHtml(accountWithProxyEntity);

        const accessTokenCourse = this.getAccessTokenCourseFromResponse(htmlCourse);
        return { accessTokenCourse };
    }

    async getCoursesList(accountId: string): Promise<CourseList> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const { accessTokenCourse } = await this.createAccessTokenCourse(accountWithProxyEntity);
        return this.getCourses(accessTokenCourse, accountWithProxyEntity);
    }

    private generateRandomString(length: number) {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }

    private generateFCMLikeToken() {
        const part1 = this.generateRandomString(10);
        const part2 = this.generateRandomString(7);
        const part3 = this.generateRandomString(150);

        return `${part1}:${part2}:${part3}`;
    }

    async addOrder(accountId: string, orderNumber: string): Promise<Order> {
        return await this.accountRep.addOrderNumber(accountId, orderNumber);
    }

    async setAccountCity(accountId: string, cityId: string) {
        return await this.accountRep.setCityToAccount(accountId, cityId);
    }

    async openForceRefresh(accountId: string) {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        await this.refreshForValidation(accountWithProxyEntity);
    }

    private async getHttpOptions(url: string, accountWithProxy: AccountWithProxyEntity): Promise<any> {
        const headers = this.sportmasterHeaders.getHeadersMobile(url, accountWithProxy);
        const httpsAgent = new SocksProxyAgent(accountWithProxy.proxy!.proxy);

        return { headers, httpsAgent };
    }

    private async getHttpOptionsSiteUserGate(accountWithProxy: AccountWithProxyEntity): Promise<any> {
        const headers = this.sportmasterHeaders.getHeadersUserGate(accountWithProxy.userGateToken!);
        const httpsAgent = new SocksProxyAgent(accountWithProxy.proxy!.proxy);

        return { headers, httpsAgent };
    }

    private async getHttpOptionsSiteCourse(accountWithProxy: AccountWithProxyEntity, accessTokenCourse: string): Promise<any> {
        const headers = this.sportmasterHeaders.getHeadersWithAccessToken(accessTokenCourse);
        const httpsAgent = new SocksProxyAgent(accountWithProxy.proxy!.proxy);

        return { headers, httpsAgent };
    }

    private async getHttpOptionsSiteCourseVideo(
        accessTokenCourse: string,
        proxy: string,
        videoId: string,
        lessonId: string,
        mnemocode: string,
    ): Promise<any> {
        const headers = this.sportmasterHeaders.getHeadersWithAccessToken(accessTokenCourse, videoId, lessonId, mnemocode);
        const httpsAgent = new SocksProxyAgent(proxy);

        return { headers, httpsAgent };
    }

    private async refreshPrivate(accountWithProxy: AccountWithProxyEntity) {
        const tokens = await this.refreshForValidation(accountWithProxy);
        const refreshTokensEntity = await this.updateTokensAccountPrivate(accountWithProxy.accountId, tokens);
        accountWithProxy.accessToken = refreshTokensEntity.accessToken;
        accountWithProxy.refreshToken = refreshTokensEntity.refreshToken;
        accountWithProxy.expiresInAccess = refreshTokensEntity.expiresInAccess;
        return refreshTokensEntity;
    }

    private async refreshForValidation(accountWithProxyEntity: AccountWithProxyEntity): Promise<IRefreshAccount> {
        const url = this.url + 'v1/auth/refresh';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            refreshToken: accountWithProxyEntity.refreshToken,
            deviceId: accountWithProxyEntity.deviceId,
        };

        const response = await this.httpService.post(url, payload, httpOptions);

        const accessToken = response.data.data.token.accessToken;
        const refreshToken = response.data.data.token.refreshToken;
        const expiresIn = response.data.data.token.expiresIn;

        return {
            accessToken,
            refreshToken,
            expiresIn,
        };
    }

    private async validationToken(accountWithProxy: AccountWithProxyEntity) {
        const isUpdate = accountWithProxy.updateTokensByTime();
        if (isUpdate) {
            await this.refreshPrivate(accountWithProxy);
        }
    }

    private async getAndValidateOrSetProxyAccount(accountWithProxy: IAccountWithProxy): Promise<AccountWithProxyEntity> {
        const currentTime = new Date();
        const timeBlockedAgo = new Date();
        timeBlockedAgo.setMinutes(currentTime.getMinutes() - +this.durationTimeProxyBlock);

        let accountWithProxyEntity: AccountWithProxyEntity;
        if (
            !accountWithProxy.proxy ||
            accountWithProxy.proxy.expiresAt < currentTime ||
            (accountWithProxy.proxy.blockedAt && accountWithProxy.proxy.blockedAt > timeBlockedAgo)
        ) {
            const proxy = await this.proxyService.getRandomProxy();
            const newAccountWithProxy = await this.accountRep.setProxyAccount(accountWithProxy.accountId, proxy.uuid);
            accountWithProxyEntity = new AccountWithProxyEntity(newAccountWithProxy);
        } else {
            accountWithProxyEntity = new AccountWithProxyEntity(accountWithProxy);
        }
        return accountWithProxyEntity;
    }

    private async getAccountEntity(accountId: string): Promise<AccountWithProxyEntity> {
        const accountWithProxy = await this.accountRep.getAccountWithProxy(accountId);

        if (!accountWithProxy) throw new NotFoundException(ERROR_ACCOUNT_NOT_FOUND);
        if (!accountWithProxy.isAccessMp) throw new HttpException(ERROR_LOGOUT_MP, HttpStatus.FORBIDDEN);
        const accountWithProxyEntity = await this.getAndValidateOrSetProxyAccount(accountWithProxy);
        await this.validationToken(accountWithProxyEntity);

        return accountWithProxyEntity;
    }

    async shortInfo(accountId: string): Promise<ShortInfoInterface> {
        const { bonusCount, qrCode, bonusDetails, citySMName } = await this.shortInfoPrivate(accountId);
        await this.updateAccountBonusCountPrivate(accountId, bonusCount);
        return { bonusCount, qrCode, bonusDetails, citySMName };
    }

    private async shortInfoPrivate(accountId: string): Promise<ShortInfoInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v2/bonus/shortInfo';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);

        const bonusCount: number = +response.data.data.info.totalAmount;
        const qrCode: string = response.data.data.info.clubCard.qrCode;
        const bonusDetails = response.data.data.info.details;
        return { bonusCount, qrCode, bonusDetails, citySMName: accountWithProxyEntity.citySM.name };
    }

    async sendSmsWithAnalytics(accountId: string, phoneNumber: string): Promise<string> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        await this.analyticsTags(accountWithProxyEntity);
        await new Promise<void>(resolve => setTimeout(resolve, 1000));

        return await this.sendSms(accountWithProxyEntity, phoneNumber);
    }

    async sendSms(accountOrId: string | AccountWithProxyEntity, phoneNumber: string): Promise<string> {
        const account = typeof accountOrId === 'string' ? await this.getAccountEntity(accountOrId) : accountOrId;

        const targetUrl = this.url + `v1/verify/sendSms`;

        const headers = this.sportmasterHeaders.getHeadersForSearchAccount(targetUrl, account);

        const payload = {
            phone: {
                countryCode: '7',
                nationalNumber: phoneNumber,
                isoCode: 'RU',
            },
            operation: 'change_phone',
            communicationChannel: 'SMS',
        };

        const responseData = await this.tlsForwarder.forwardRequest<{ data: { requestId: string } }>({
            requestUrl: targetUrl,
            requestMethod: 'POST',
            headers,
            requestBody: payload,
            proxyUrl: account.proxy!.proxy,
        });

        if (!responseData?.data?.requestId) {
            this.logger.error('Unexpected response from Sportmaster after TLS forwarding', responseData);
            throw new Error('Ошибка при проверке номера на стороне СМ');
        }

        return responseData.data.requestId;
    }

    async phoneChange(accountId: string, requestId: string, code: string) {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        await this.analyticsTags(accountWithProxyEntity);
        const token = await this.verifyCheck(accountWithProxyEntity, requestId, code);
        await this.changePhone(accountWithProxyEntity, token);
    }

    private async verifyCheck(accountWithProxyEntity: AccountWithProxyEntity, requestId: string, code: string): Promise<string> {
        const url = this.url + `v1/verify/check`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            requestId,
            code,
        };

        const response = await this.httpService.post(url, payload, httpOptions);
        return response.data.data.token;
    }

    private async changePhone(accountWithProxyEntity: AccountWithProxyEntity, token: string): Promise<boolean> {
        const url = this.url + `v1/profile/changePhone`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            token,
        };
        await this.httpService.post(url, payload, httpOptions);
        return true;
    }

    async analyticsTags(accountWithProxyEntity: string | AccountWithProxyEntity): Promise<boolean> {
        if (typeof accountWithProxyEntity == 'string') {
            accountWithProxyEntity = await this.getAccountEntity(accountWithProxyEntity);
        }
        const url = this.url + `v2/analytics/tags`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {};
        await this.httpService.post(url, payload, httpOptions);

        return true;
    }

    async findCity(accountId: string, city: string) {
        const findCities = await this.findCityPrivate(accountId, city);

        const cityEntities = findCities.map(city => new CitySMEntity(city));
        await Promise.allSettled(cityEntities.map(cityEntity => this.accountRep.addingCitySM(cityEntity)));
        return cityEntities;
    }

    private async findCityPrivate(accountId: string, city: string): Promise<IFindCitiesAccount[]> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const encodedCity = encodeURI(city.toUpperCase());
        const url = this.url + `v1/city?query=${encodedCity}`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);
        return response.data.data.list;
    }

    async getCart(accountWithProxyEntity: string | AccountWithProxyEntity): Promise<CartInterface> {
        if (typeof accountWithProxyEntity == 'string') {
            accountWithProxyEntity = await this.getAccountEntity(accountWithProxyEntity);
        }
        const url = this.url + 'v1/cart2';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const payload = { clearDeletedLines: 'true', cartResponse: 'FULL2' };
        const response = await this.httpService.post(url, payload, httpOptions);

        return response.data;
    }

    async applySnapshot(accountId: string, snapshotUrl: string): Promise<CartInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart/applySnapshot';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const payload = {
            snapshotUrl: snapshotUrl,
        };
        const response = await this.httpService.post(url, payload, httpOptions);

        return response.data;
    }

    async addPromocode(accountId: string, promocode: string): Promise<boolean> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart2/promoCode';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const payload = {
            promoCode: promocode,
        };
        const response = await this.httpService.post(url, payload, httpOptions);

        return response.data;
    }

    async createSnapshot(accountId: string): Promise<string> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart/createSnapshot';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const payload = {};
        const response = await this.httpService.post(url, payload, httpOptions);

        return response.data.data.snapshotUrl;
    }

    async deletePromocode(accountId: string): Promise<void> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + this.url + 'v1/cart/promoCode';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        await this.httpService.delete(url, httpOptions);
    }

    async removeAllCart(accountId: string) {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const cart = await this.getCart(accountWithProxyEntity);
        const mainFromCart = selectMainFromCart(cart);
        for (const item of mainFromCart) {
            const arr = [];
            arr.push(item);
            await this.removeFromCart(accountWithProxyEntity, arr);
        }
    }

    async removeFromCart(accountWithProxyEntity: string | AccountWithProxyEntity, removeList: IItemsCart[]): Promise<any> {
        if (typeof accountWithProxyEntity == 'string') {
            accountWithProxyEntity = await this.getAccountEntity(accountWithProxyEntity);
        }
        const url = this.url + 'v1/cart2/remove';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const ids = removeList.map((item: IItemsCart) => {
            return {
                productId: item.productId,
                sku: item.sku,
                linesIds: removeList[0].linesIds,
            };
        });

        const payload = {
            ids: ids,
            cartFormat: 'FULL2',
        };
        await this.httpService.post(url, payload, httpOptions);
    }

    async addInCart(accountId: string, { productId, sku }: IItemsCart): Promise<any> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart2/add';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const payload = {
            productList: [
                {
                    id: {
                        productId,
                        sku,
                    },
                    quantity: 1,
                },
            ],
            cartFormat: 'LITE',
        };
        const response = await this.httpService.post(url, payload, httpOptions);

        return response.data;
    }

    async searchProduct(accountId: string, article: string): Promise<SearchProductInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v2/products/search?limit=10&offset=0';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = { queryText: article, persGateTags: ['A_search', 'auth_login_call'] };

        const response = await this.httpService.post(url, payload, httpOptions);

        return response.data;
    }

    async internalPickupAvailability(accountId: string, internalPickupAvabilityItems: IItemsCart[]): Promise<PickupAvabilityInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart2/internalPickupAvailability';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            cartItemIds: internalPickupAvabilityItems,
        };
        const response = await this.httpService.post(url, payload, httpOptions);
        return response.data;
    }

    async internalPickup(accountId: string, shopId: string, internalPickupAvabilityItems: IItemsCart[]) {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart2/obtainPoint/internalPickup';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            shopNumber: shopId,
            cartItemsByOrders: [{ cartItemIds: internalPickupAvabilityItems }],
        };

        const response = await this.httpService.post(url, payload, httpOptions);
        const data = response.data.data.cart.obtainPoints[0];
        const potentialOrder = data.potentialOrder.id;
        const version = response.data.data.cart.version;

        return { potentialOrder, version };
    }

    async submitOrder(accountId: string, version: string): Promise<string> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/cart/submit';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            cartVersion: version,
        };

        const response = await this.httpService.post(url, payload, httpOptions);

        const orderNumber = response.data.data.orders[0];
        return orderNumber.orderNumber;
    }

    async approveRecipientOrder(accountId: string, recipient: IRecipientOrder): Promise<any> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + `v1/cart2/receiver`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            fio: `${recipient.firstName} ${recipient.lastName}`,
            phone: { countryCode: 7, nationalNumber: `${recipient.number}`, isoCode: 'RU' },
            email: `${recipient.email}`,
        };

        const response = await this.httpService.post(url, payload, httpOptions);
        return response.data.data.cart.version;
    }

    async orderHistory(accountId: string) {
        const data = await this.orderHistoryPrivate(accountId);
        for (const order of data.data.orders) {
            try {
                await this.addOrder(accountId, order.number);
            } catch (err) {}
        }
        return data;
    }

    private async orderHistoryPrivate(accountId: string): Promise<OrdersInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + `v3/orderHistory`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);
        return response.data;
    }

    async orderInfo(accountId: string, orderNumber: string): Promise<OrderInfoInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + `v4/order/${orderNumber}`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const payload = {};
        const response = await this.httpService.post(url, payload, httpOptions);
        return response.data;
    }

    async cancellOrder(accountId: string, orderNumber: string): Promise<NonNullable<unknown>> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const reasons = [103, 104, 105, 106];
        const randomIndex = Math.floor(Math.random() * reasons.length);
        const reason = reasons[randomIndex];
        const url = this.url + `v1/order/${orderNumber}`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            cancelReasonId: reason,
        };

        const response = await this.httpService.post(url, payload, httpOptions);
        return response.data;
    }

    async getPromocodeFromProfile(accountId: string): Promise<PromocodeInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + `v1/promo`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);
        return response.data;
    }

    async getProfile(accountId: string): Promise<PromocodeInterface> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + `v1/profile`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);
        return response.data;
    }

    async pushToken(accountId: string, pushToken: string): Promise<any> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);
        const url = this.url + 'v1/profile/pushToken';
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);

        const payload = {
            pushToken,
            pushService: 'fcm',
        };

        const response = await this.httpService.post(url, payload, httpOptions);
        return response.data;
    }

    private async getUserGateToken(accountWithProxyEntity: AccountWithProxyEntity): Promise<UserGateTokenInterface> {
        const url = this.url + `v1/profile/userGateToken`;
        const httpOptions = await this.getHttpOptions(url, accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);
        return response.data;
    }

    async getCoursesHtml(accountWithProxyEntity: AccountWithProxyEntity): Promise<string> {
        const url = this.urlSite + `courses/?webview=true`;
        const httpOptions = await this.getHttpOptionsSiteUserGate(accountWithProxyEntity);
        const response = await this.httpService.get(url, httpOptions);
        return response.data;
    }

    private getAccessTokenCourseFromResponse(html: string): string {
        const regex = /(?<=},token:")[\w\W]*?(?=")/;
        const match = html.match(regex);
        if (match) {
            return match[0];
        }
        throw new HttpException(ERROR_GET_ACCESS_TOKEN_COURSE, HttpStatus.BAD_REQUEST);
    }

    private async getCourses(accessTokenCourse: string, accountWithProxyEntity: AccountWithProxyEntity): Promise<CourseList> {
        const url = this.urlSite + `courses/api/courses?limit=10`;
        const httpOptions = await this.getHttpOptionsSiteCourse(accountWithProxyEntity, accessTokenCourse);
        const response = await this.httpService.get(url, httpOptions);
        return response.data;
    }

    async promblemCourses(accountId: string): Promise<void> {
        await this.accountRep.promblemCourses(accountId);
    }

    async getActiveCourseAccount(): Promise<string[]> {
        return await this.accountRep.getActiveCourseAccount();
    }

    async watchingLesson(lesson: IWatchLesson, accountId: string): Promise<boolean> {
        const accountWithProxyEntity = await this.getAccountEntity(accountId);

        const status = await this.privateWatchingLesson(lesson, accountWithProxyEntity);
        return status == 204;
    }

    private async privateWatchingLesson(
        { mnemocode, videoId, lessonId, duration }: IWatchLesson,
        accountWithProxyEntity: AccountWithProxyEntity,
    ): Promise<number> {
        if (!accountWithProxyEntity.accessTokenCourse) {
            await this.promblemCourses(accountWithProxyEntity.accountId);
            throw new HttpException(ERROR_ACCESS_TOKEN_COURSE, HttpStatus.FORBIDDEN);
        }

        const url = this.urlSite + `courses/api/courses/lessons/${mnemocode}/${lessonId}/watching`;
        const httpOptions = await this.getHttpOptionsSiteCourseVideo(
            accountWithProxyEntity.accessTokenCourse,
            accountWithProxyEntity.proxy!.proxy,
            videoId,
            lessonId,
            mnemocode,
        );
        const payload = {
            startTime: 0,
            endTime: duration,
        };
        try {
            const response = await this.httpService.post(url, payload, httpOptions);
            return response.status;
        } catch (e: any) {
            return 404;
        }
    }
}

```

src/module/account/course.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { CourseWithLessons } from './interfaces/course.interface';
import { AccountCourse, CourseStatus, Lesson, LessonStatus } from '@prisma/client';
import { LessonProgressData } from './interfaces/lesson-progress.interface';

@Injectable()
export class CourseRepository {
    firstLessons: string[] = [];

    constructor(private prisma: PrismaService) {
        this.loadFirstLessons();
    }

    async loadFirstLessons() {
        const firstLessons = await this.prisma.lesson.findMany({
            where: {
                position: 1,
            },
        });
        this.firstLessons = firstLessons.map(lesson => lesson.lessonId);
    }

    async createAccountCourse(accountId: string, course: CourseWithLessons): Promise<void> {
        await this.prisma.accountCourse.create({
            data: {
                accountId,
                courseId: course.courseId,
            },
        });
    }

    async getAllLesson(): Promise<Lesson[]> {
        return this.prisma.lesson.findMany();
    }

    async createAccountLessonProgress(accountId: string, lessons: Lesson[]): Promise<void> {
        const lessonProgressData = lessons.map(lesson => {
            return {
                accountId,
                accountCourseAccountCourseId: +lesson.courseId,
                lessonId: lesson.lessonId,
                nextViewAt: null,
            };
        });

        await this.prisma.accountLessonProgress.createMany({
            data: lessonProgressData,
        });
    }

    async createAccountLessonProgressByExistCourses(lessonProgressData: LessonProgressData[]): Promise<void> {
        await this.prisma.accountLessonProgress.createMany({
            data: lessonProgressData,
        });
    }

    async getCoursesWithLessons(): Promise<CourseWithLessons[]> {
        return this.prisma.originalCourse.findMany({
            include: {
                lessons: {
                    orderBy: {
                        position: 'asc',
                    },
                },
            },
        });
    }

    async getLessonsProgressByAccountId(accountId: string) {
        return this.prisma.accountLessonProgress.findMany({
            where: { accountId },
        });
    }

    async getLessonsWithProgressByAccountAndCourse(accountId: string, courseId: string) {
        const lessons = await this.prisma.lesson.findMany({
            where: {
                courseId: courseId,
            },
            include: {
                AccountLessonProgress: {
                    where: {
                        accountId: accountId,
                    },
                },
            },
            orderBy: {
                position: 'asc',
            },
        });

        return lessons.map(lesson => {
            const progress = lesson.AccountLessonProgress[0];

            return {
                ...lesson,
                progress,
            };
        });
    }

    async getFirstLessonProgressId(accountId: string, courseId: string): Promise<number | null> {
        const firstLesson = await this.prisma.lesson.findFirst({
            where: {
                courseId,
                position: 1,
            },
            include: {
                AccountLessonProgress: {
                    where: {
                        accountId,
                    },
                },
            },
        });

        if (!firstLesson || firstLesson.AccountLessonProgress.length === 0) {
            return null;
        }

        return firstLesson.AccountLessonProgress[0].progressId;
    }

    async getCoursesByAccountAndStatus(accountId: string, status: CourseStatus): Promise<AccountCourse[]> {
        return this.prisma.accountCourse.findMany({
            where: {
                accountId,
                status,
            },
            orderBy: {
                courseId: 'asc',
            },
        });
    }

    async updateViewLesson(progressId: number, status: LessonStatus) {
        return this.prisma.accountLessonProgress.update({
            where: {
                progressId,
            },
            data: {
                status,
            },
        });
    }

    async updateUnblockLesson(progressId: number, timeUnblock: Date) {
        await this.prisma.accountLessonProgress.update({
            where: {
                progressId,
            },
            data: {
                status: LessonStatus.NONE,
                nextViewAt: timeUnblock,
            },
        });
    }

    async changeStatusCourse(accountId: string, courseId: string, status: CourseStatus) {
        await this.prisma.accountCourse.update({
            where: {
                accountId_courseId: {
                    accountId,
                    courseId,
                },
            },
            data: {
                status,
            },
        });
    }

    async changeStatusLesson(accountId: string, lessonId: string, status: LessonStatus) {
        await this.prisma.accountLessonProgress.update({
            where: {
                accountId_lessonId: {
                    accountId,
                    lessonId,
                },
            },
            data: {
                status,
            },
        });
    }

    async getAllAvailableCoursesId() {
        return this.prisma.originalCourse.findMany({
            select: {
                courseId: true,
            },
        });
    }

    async getIsAccountCourses(accountId: string) {
        return this.prisma.accountCourse.findMany({
            where: {
                accountId: accountId,
            },
            select: {
                courseId: true,
            },
        });
    }

    async getAllCoursesIdAndMnemocode(): Promise<{ courseId: string; mnemocode: string }[]> {
        return this.prisma.originalCourse.findMany({
            select: {
                courseId: true,
                mnemocode: true,
            },
        });
    }

    async getAccountCoursesByAccountId(accountId: string) {
        return this.prisma.accountCourse.findMany({
            where: {
                accountId: accountId,
            },
        });
    }
}

```

src/module/account/course.service.ts:
```
import { Injectable, NotFoundException, OnModuleInit } from '@nestjs/common';
import { CourseWithLessons } from './interfaces/course.interface';
import { CourseRepository } from './course.repository';
import { AccountCourse, CourseStatus, Lesson, LessonStatus } from '@prisma/client';
import { CourseData } from './interfaces/course-data.interface';
import { LessonProgressData } from './interfaces/lesson-progress.interface';

@Injectable()
export class CourseService implements OnModuleInit {
    coursesId: string[] = [];
    coursesMnemocode: Record<string, string> = {};

    constructor(private courseRepository: CourseRepository) {
        this.loadAvailableCoursesId();
    }

    async onModuleInit() {
        await this.initializeCache();
    }

    async getCoursesWithLessons(): Promise<CourseWithLessons[]> {
        return this.courseRepository.getCoursesWithLessons();
    }

    async getAllLesson(): Promise<Lesson[]> {
        return this.courseRepository.getAllLesson();
    }

    async getCoursesByAccountAndStatus(accountId: string, status: CourseStatus) {
        return this.courseRepository.getCoursesByAccountAndStatus(accountId, status);
    }

    private async getAvailableCoursesIdFromDB() {
        return this.courseRepository.getAllAvailableCoursesId();
    }

    private async loadAvailableCoursesId(): Promise<void> {
        const coursesIdObj = await this.getAvailableCoursesIdFromDB();
        this.coursesId = coursesIdObj.map(course => course.courseId);
    }

    async getIsAccountCourses(accountId: string) {
        const coursesObj = await this.courseRepository.getIsAccountCourses(accountId);
        return coursesObj.map(course => course.courseId);
    }

    async createAccountCourse(accountId: string, course: CourseWithLessons): Promise<void> {
        return this.courseRepository.createAccountCourse(accountId, course);
    }

    async createAccountLessonProgress(accountId: string, lessons: Lesson[]): Promise<void> {
        return this.courseRepository.createAccountLessonProgress(accountId, lessons);
    }

    async createAccountLessonProgressFromExistCourses(accountId: string, lessons: Lesson[]): Promise<void> {
        const accountCourse = await this.courseRepository.getAccountCoursesByAccountId(accountId);
        const lessonProgressData: LessonProgressData[] = lessons.map(lesson => {
            const foundedCourse = accountCourse.find(course => {
                return course.courseId == lesson.courseId;
            });
            if (!foundedCourse) throw new NotFoundException('Не найден курс для createAccountLessonProgressFromExistCourses');

            return {
                accountId,
                accountCourseAccountCourseId: foundedCourse?.accountCourseId,
                lessonId: lesson.lessonId,
                nextViewAt: null,
            };
        });

        return this.courseRepository.createAccountLessonProgressByExistCourses(lessonProgressData);
    }

    async getFirstLessonProgressId(accountId: string, courseId: string) {
        return this.courseRepository.getFirstLessonProgressId(accountId, courseId);
    }

    async getLessonsWithProgressByAccountAndCourse(accountId: string, courseId: string) {
        return this.courseRepository.getLessonsWithProgressByAccountAndCourse(accountId, courseId);
    }

    async getLessonsProgressByAccountId(accountId: string) {
        return this.courseRepository.getLessonsProgressByAccountId(accountId);
    }

    async updateViewLesson(progressId: number, status: LessonStatus) {
        return this.courseRepository.updateViewLesson(progressId, status);
    }

    async updateUnblockLesson(progressId: number, timeUnblock: Date): Promise<void> {
        await this.courseRepository.updateUnblockLesson(progressId, timeUnblock);
    }

    async changeStatusCourse(accountId: string, courseId: string, status: CourseStatus): Promise<void> {
        await this.courseRepository.changeStatusCourse(accountId, courseId, status);
    }

    async changeStatusLesson(accountId: string, lessonId: string, status: LessonStatus): Promise<void> {
        await this.courseRepository.changeStatusLesson(accountId, lessonId, status);
    }

    async synchronizationCourse(accountId: string, data: CourseData): Promise<string> {
        const lessons = data.lessons;
        const courseId = data.id;

        const statusCourse: CourseStatus = this.mapCourseStatus(data.status);
        await this.changeStatusCourse(accountId, String(courseId), statusCourse);

        for (const lesson of lessons) {
            const statusLesson: LessonStatus = this.mapLessonStatus(lesson.status);
            const lessonId = lesson.id;
            await this.changeStatusLesson(accountId, String(lessonId), statusLesson);
        }
        return 'ok';
    }

    private mapCourseStatus(status: string): CourseStatus {
        const statusMap: Record<string, CourseStatus> = {
            finished: CourseStatus.FINISHED,
            blocked: CourseStatus.BLOCKED,
            none: CourseStatus.ACTIVE,
            active: CourseStatus.ACTIVE,
        };

        return statusMap[status.toLowerCase()] || CourseStatus.NONE;
    }

    private mapLessonStatus(status: string): LessonStatus {
        const statusMap: Record<string, LessonStatus> = {
            viewed: LessonStatus.VIEWED,
            blocked: LessonStatus.BLOCKED,
            none: LessonStatus.NONE,
        };

        return statusMap[status.toLowerCase()] || LessonStatus.NONE;
    }

    async initializeCache(): Promise<void> {
        const courses = await this.courseRepository.getAllCoursesIdAndMnemocode();

        this.coursesMnemocode = courses.reduce(
            (acc, course) => {
                acc[course.courseId] = course.mnemocode;
                return acc;
            },
            {} as Record<string, string>,
        );
    }

    getMnemocode(courseId: string): string | undefined {
        return this.coursesMnemocode[courseId];
    }
}

```

src/module/account/deviceInfo.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { DeviceInfoEntity } from './entities/deviceInfo.entity';
import { ICreateDeviceInfo, IUpdateDeviceInfo } from './interfaces/deviceInfo.interface';

@Injectable()
export class DeviceInfoRepository {
    constructor(private readonly prisma: PrismaService) {}

    async create(data: ICreateDeviceInfo): Promise<DeviceInfoEntity> {
        const deviceInfo = await this.prisma.deviceInfo.create({ data });
        return new DeviceInfoEntity(deviceInfo);
    }

    async update(accountId: string, data: IUpdateDeviceInfo): Promise<DeviceInfoEntity> {
        const deviceInfo = await this.prisma.deviceInfo.update({
            where: { accountId },
            data,
        });

        return new DeviceInfoEntity(deviceInfo);
    }

    async findByAccountId(accountId: string): Promise<DeviceInfoEntity | null> {
        const deviceInfo = await this.prisma.deviceInfo.findUnique({
            where: { accountId },
        });

        if (!deviceInfo) {
            return null;
        }

        return new DeviceInfoEntity(deviceInfo);
    }

    async exists(accountId: string): Promise<boolean> {
        const count = await this.prisma.deviceInfo.count({
            where: { accountId },
        });

        return count > 0;
    }

    async delete(accountId: string): Promise<DeviceInfoEntity> {
        const deviceInfo = await this.prisma.deviceInfo.delete({
            where: { accountId },
        });

        return new DeviceInfoEntity(deviceInfo);
    }
}

```

src/module/account/deviceInfo.service.ts:
```
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { DeviceInfoRequestDto, DeviceInfoResponseDto } from './dto/create-deviceInfo.dto';
import { DeviceInfoRepository } from './deviceInfo.repository';
import { IDeviceInfo } from './interfaces/deviceInfo.interface';

@Injectable()
export class DeviceInfoService {
    constructor(private readonly deviceInfoRepository: DeviceInfoRepository) {}

    async addDeviceInfo(accountId: string, dto: DeviceInfoRequestDto): Promise<DeviceInfoResponseDto> {
        const deviceInfoExists = await this.deviceInfoRepository.exists(accountId);
        if (deviceInfoExists) {
            throw new BadRequestException(`Информация об устройстве для аккаунта ${accountId} уже существует`);
        }

        const deviceInfo = await this.deviceInfoRepository.create({
            accountId,
            osVersion: dto.osVersion,
            buildVersion: dto.buildVersion,
            brand: dto.brand,
            model: dto.model,
            screenResolution: dto.screenResolution,
            browserVersion: dto.browserVersion,
            IP: dto.IP,
        });

        return deviceInfo.getDeviceParams();
    }

    async updateDeviceInfo(accountId: string, dto: DeviceInfoRequestDto): Promise<DeviceInfoResponseDto> {
        const deviceInfoExists = await this.deviceInfoRepository.exists(accountId);
        if (deviceInfoExists) {
            throw new BadRequestException(`Информация об устройстве для аккаунта ${accountId} уже существует`);
        }

        const deviceInfo = await this.deviceInfoRepository.update(accountId, {
            osVersion: dto.osVersion,
            buildVersion: dto.buildVersion,
            brand: dto.brand,
            model: dto.model,
            screenResolution: dto.screenResolution,
            browserVersion: dto.browserVersion,
            IP: dto.IP,
        });

        return deviceInfo.getDeviceParams();
    }

    async getDeviceInfo(accountId: string): Promise<IDeviceInfo> {
        const deviceInfo = await this.deviceInfoRepository.findByAccountId(accountId);

        if (!deviceInfo) {
            throw new NotFoundException(`Информация об устройстве для аккаунта ${accountId} не найдена`);
        }

        return deviceInfo.getDeviceParams();
    }
}

```

src/module/account/constants/error.constant.ts:
```
export const ERROR_LOGOUT_MP = 'Разлогин аккаунта, в боте не работает';
export const ERROR_LOGOUT_MP_BAN = 'Возможно бан, обновите аутентификацию';
export const ERROR_ACCOUNT_NOT_FOUND = 'Аккаунт не найден';
export const ERROR_COURSE_NOT_FOUND = 'Курс не найден';
export const ERROR_GET_ACCESS_TOKEN_COURSE = 'Ошибка в получении токена';
export const ERROR_UNKNOWN = 'Необработанная ошибка';
export const ERROR_PROXY = 'Ошибка с прокси. Обратитесь в поддержку';
export const ERROR_ACCESS_TOKEN_COURSE = 'Нет accessToken курса';
export const ERROR_PROGRESS_ID = 'Не найден progress id у аккаунта с курсом';

```

src/module/account/dto/course-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const CourseIdAccountRequestSchema = z.object({
    courseId: z.string(),
});

const CourseIdAccountResponseSchema = z.object({});

export namespace CourseIdAccountCommand {
    export const RequestSchema = CourseIdAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = CourseIdAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class CourseIdAccountRequestDto extends createZodDto(CourseIdAccountCommand.RequestSchema) {}
export class CourseIdAccountResponseDto extends createZodDto(CourseIdAccountCommand.ResponseSchema) {}

```

src/module/account/dto/course-status.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

export const AccountIdParamsSchema = z.object({
    accountId: z.string().uuid(),
});

export namespace AccountIdCommand {
    export const RequestSchema = AccountIdParamsSchema;
    export type Request = z.infer<typeof RequestSchema>;
}

export class AccountIdParamsDto extends createZodDto(AccountIdCommand.RequestSchema) {}

```

src/module/account/dto/create-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { CourseStatus } from '@prisma/client';

export const CourseStatusEnum = z.enum(Object.values(CourseStatus) as [keyof typeof CourseStatus]);

const AddingAccountRequestSchema = z.object({
    accountId: z.string().uuid(),
    email: z.string().email(),
    passImap: z.string(),
    passEmail: z.string(),
    cookie: z.preprocess(val => (typeof val === 'string' ? decodeURIComponent(val.replace(/\+/g, ' ')) : val), z.string()),
    accessToken: z.string(),
    refreshToken: z.string(),
    googleId: z.string().optional(),
    accessTokenCourse: z.string().optional(),
    refreshTokenCourse: z.string().optional(),
    statusCourse: CourseStatusEnum.optional(),
    userGateToken: z.string().optional(),
    xUserId: z.string(),
    deviceId: z.string().uuid(),
    installationId: z.string().uuid(),
    expiresIn: z.string(),
    bonusCount: z.string(),
    isOnlyAccessOrder: z.string(),
});

const AddingAccountResponseSchema = z.object({});

export namespace AddingAccountCommand {
    export const RequestSchema = AddingAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = AddingAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class AddingAccountRequestDto extends createZodDto(AddingAccountCommand.RequestSchema) {}
export class AddingAccountResponseDto extends createZodDto(AddingAccountCommand.ResponseSchema) {}

```

src/module/account/dto/create-deviceInfo.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const DeviceInfoRequestSchema = z.object({
    osVersion: z.string().min(1, 'Версия Android обязательна'),
    buildVersion: z.string().min(1, 'Версия сборки обязательна'),
    brand: z.string().min(1, 'Производитель устройства обязателен'),
    model: z.string().min(1, 'Модель устройства обязательна'),
    screenResolution: z.string().min(1, 'Разрешение экрана обязательно'),
    browserVersion: z.string().min(1, 'Версия браузера обязательна'),
    IP: z.string().min(1, 'IP обязателен'),
});

const DeviceInfoResponseSchema = z.object({});

export namespace DeviceInfoCommand {
    export const RequestSchema = DeviceInfoRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = DeviceInfoResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class DeviceInfoRequestDto extends createZodDto(DeviceInfoCommand.RequestSchema) {}
export class DeviceInfoResponseDto extends createZodDto(DeviceInfoCommand.ResponseSchema) {}

```

src/module/account/dto/getAccessTokenCourse-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const GetAccessTokenCourseResponseSchema = z.object({
    accessTokenCourse: z.string(),
});

export namespace GetUserGateTokenCommand {
    export const ResponseSchema = GetAccessTokenCourseResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class AccessTokenCourseResponseDto extends createZodDto(GetUserGateTokenCommand.ResponseSchema) {}

```

src/module/account/dto/isEmail-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const IsEmailRequestSchema = z.object({
    email: z.string().email(),
});

const IsEmailResponseSchema = z.object({
    isEmail: z.boolean(),
});

export namespace IsEmailCommand {
    export const RequestSchema = IsEmailRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = IsEmailResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class IsEmailRequestDto extends createZodDto(IsEmailCommand.RequestSchema) {}
export class IsEmailResponseDto extends createZodDto(IsEmailCommand.ResponseSchema) {}

```

src/module/account/dto/update-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { CourseStatusEnum } from './create-account.dto';

const UpdateAccountRequestSchema = z.object({
    accessToken: z.string(),
    refreshToken: z.string(),
    xUserId: z.string(),
    deviceId: z.string().uuid(),
    installationId: z.string().uuid(),
    expiresIn: z.string(),
    accessTokenCourse: z.string(),
    refreshTokenCourse: z.string(),
    statusCourse: CourseStatusEnum,
    userGateToken: z.string(),
});

const UpdateAccountResponseSchema = z.object({});

export namespace UpdateAccountCommand {
    export const RequestSchema = UpdateAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdateAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdateAccountRequestDto extends createZodDto(UpdateAccountCommand.RequestSchema) {}
export class UpdateAccountResponseDto extends createZodDto(UpdateAccountCommand.ResponseSchema) {}

```

src/module/account/dto/update-course-status-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { CourseStatusEnum } from './create-account.dto';

const UpdatingCourseStatusAccountRequestSchema = z.object({
    statusCourse: CourseStatusEnum,
});

const UpdatingCourseStatusAccountResponseSchema = z.object({});

export namespace UpdatingCourseStatusAccountCommand {
    export const RequestSchema = UpdatingCourseStatusAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdatingCourseStatusAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdatingCourseStatusAccountRequestDto extends createZodDto(UpdatingCourseStatusAccountCommand.RequestSchema) {}
export class UpdatingCourseStatusAccountResponseDto extends createZodDto(UpdatingCourseStatusAccountCommand.ResponseSchema) {}

```

src/module/account/dto/update-course-tokens-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const UpdatingCourseTokenAccountRequestSchema = z.object({
    accessTokenCourse: z.string(),
    refreshTokenCourse: z.string(),
    userGateToken: z.string(),
});

const UpdatingCourseTokenAccountResponseSchema = z.object({});

export namespace UpdatingCourseTokenAccountCommand {
    export const RequestSchema = UpdatingCourseTokenAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdatingCourseTokenAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdatingCourseTokensAccountRequestDto extends createZodDto(UpdatingCourseTokenAccountCommand.RequestSchema) {}
export class UpdatingCourseTokensAccountResponseDto extends createZodDto(UpdatingCourseTokenAccountCommand.ResponseSchema) {}

```

src/module/account/dto/update-tokens-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const UpdatingTokenAccountRequestSchema = z.object({
    accessToken: z.string(),
    refreshToken: z.string(),
    expiresIn: z.string(),
});

const UpdatingTokenAccountResponseSchema = z.object({});

export namespace UpdatingTokenAccountCommand {
    export const RequestSchema = UpdatingTokenAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdatingTokenAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdatingAccountRequestDto extends createZodDto(UpdatingTokenAccountCommand.RequestSchema) {}
export class UpdatingAccountResponseDto extends createZodDto(UpdatingTokenAccountCommand.ResponseSchema) {}

```

src/module/account/dto/updateBonusCount-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const UpdatingBonusCountAccountRequestSchema = z.object({
    bonusCount: z.preprocess(val => parseInt(val as string, 10), z.number()),
});

const UpdatingBonusCountAccountResponseSchema = z.object({});

export namespace UpdatingBonusCountAccountCommand {
    export const RequestSchema = UpdatingBonusCountAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdatingBonusCountAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdatingBonusCountRequestDto extends createZodDto(UpdatingBonusCountAccountCommand.RequestSchema) {}
export class UpdatingBonusCountResponseDto extends createZodDto(UpdatingBonusCountAccountCommand.ResponseSchema) {}

```

src/module/account/dto/updateCookie-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const UpdatingCookieAccountRequestSchema = z.object({
    cookie: z.preprocess(val => (typeof val === 'string' ? decodeURIComponent(val.replace(/\+/g, ' ')) : val), z.string()),
});

const UpdatingCookieAccountResponseSchema = z.object({});

export namespace UpdatingCookieAccountCommand {
    export const RequestSchema = UpdatingCookieAccountRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdatingCookieAccountResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdatingCookieRequestDto extends createZodDto(UpdatingCookieAccountCommand.RequestSchema) {}
export class UpdatingCookieResponseDto extends createZodDto(UpdatingCookieAccountCommand.ResponseSchema) {}

```

src/module/account/dto/updateCourseStatus-course.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { CourseStatusEnum } from './create-account.dto';

const UpdateCourseStatusRequestSchema = z.object({
    courseId: z.string(),
    status: CourseStatusEnum,
});

const UpdateCourseStatusResponseSchema = z.object({});

export namespace UpdatingCourseStatusAccountCommand {
    export const RequestSchema = UpdateCourseStatusRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdateCourseStatusResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdateCourseStatusRequestDto extends createZodDto(UpdatingCourseStatusAccountCommand.RequestSchema) {}
export class UpdateCourseStatusResponseDto extends createZodDto(UpdatingCourseStatusAccountCommand.ResponseSchema) {}

```

src/module/account/dto/updateGoogleId-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const UpdateGoogleIdRequestSchema = z.object({
    googleId: z.string().optional(),
});

const UpdateGoogleIdResponseSchema = z.object({
    googleId: z.string(),
});

export namespace UpdateGoogleIdCommand {
    export const RequestSchema = UpdateGoogleIdRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdateGoogleIdResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdateGoogleIdRequestDto extends createZodDto(UpdateGoogleIdCommand.RequestSchema) {}
export class UpdateGoogleIdResponseDto extends createZodDto(UpdateGoogleIdCommand.ResponseSchema) {}

```

src/module/account/dto/updatePushToken-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const UpdatePushTokenRequestSchema = z.object({
    pushToken: z.string().optional(),
});

const UpdatePushTokenResponseSchema = z.object({
    pushToken: z.string(),
});

export namespace UpdatePushTokenCommand {
    export const RequestSchema = UpdatePushTokenRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UpdatePushTokenResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class UpdatePushTokenRequestDto extends createZodDto(UpdatePushTokenCommand.RequestSchema) {}
export class UpdatePushTokenResponseDto extends createZodDto(UpdatePushTokenCommand.ResponseSchema) {}

```

src/module/account/dto/uuid-account.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

export const AccountIdParamsSchema = z.object({
    accountId: z.string().uuid(),
});

export namespace AccountIdCommand {
    export const RequestSchema = AccountIdParamsSchema;
    export type Request = z.infer<typeof RequestSchema>;
}

export class AccountIdParamsDto extends createZodDto(AccountIdCommand.RequestSchema) {}

```

src/module/account/entities/account.entity.ts:
```
import { Account, CourseStatus } from '@prisma/client';

export class AccountEntity implements Account {
    accountId: string;
    email: string;
    passImap: string;
    passEmail: string;
    cookie: string;
    accessToken: string;
    refreshToken: string;
    xUserId: string;
    deviceId: string;
    installationId: string;
    googleId: string | null;
    userGateToken: string | null;
    statusCourse: CourseStatus;
    accessTokenCourse: string | null;
    refreshTokenCourse: string | null;
    isValidAccessTokenCourse: boolean;
    pushToken: string | null;
    expiresInAccess: Date;
    expiresInRefresh: Date;
    bonusCount: number;
    isAccessMp: boolean;
    isAccessCookie: boolean;
    isOnlyAccessOrder: boolean;
    isUpdateBonus: boolean;
    ownerTelegramId: string;
    proxyUuid: string | null;
    cityId = '1720920299';
    cityName? = 'Москва';

    createdAt: Date;
    updatedAt: Date;

    constructor(account: Partial<Account>) {
        account = {
            ...account,
            cookie: this.formatedCookie(account.cookie!),
        };
        Object.assign(this, account);
        return this;
    }

    updateTokensByTime() {
        const nowDate = new Date();
        const oneHourNext = new Date(nowDate.getTime() + 60 * 60 * 1000);
        return !(this.expiresInAccess && oneHourNext < this.expiresInAccess);
    }

    setCity(cityId: string, cityName: string): void {
        this.cityId = cityId;
        this.cityName = cityName;
    }

    private formatedCookie(cookieString: string) {
        return cookieString;

        // const cookieInJson: any[] = JSON.parse(cookieString);
        // const smid = cookieInJson.find(cookie => {
        //     if (cookie.name == 'SMID') return true;
        // });
        //
        // const cookieObject: Cookie[] = [
        //     {
        //         domain: 'www.sportmaster.ru',
        //         hostOnly: true,
        //         httpOnly: true,
        //         name: 'SMID',
        //         path: '/',
        //         sameSite: 'lax',
        //         secure: false,
        //         session: false,
        //         storeId: null,
        //         value: smid.value,
        //     },
        // ];
        //
        // return JSON.stringify(cookieObject);
    }

    getBaseCookie(): string {
        const cookieInJson: any[] = JSON.parse(this.cookie);
        const cookieNames = ['SMID', 'SMAUTH', 'SMAID', 'smafauth', 'UDID'];

        const cookieObject = cookieNames
            .map(name => cookieInJson.find(cookie => cookie.name === name))
            .filter(cookie => cookie !== undefined);

        return JSON.stringify(cookieObject);
    }
}

```

src/module/account/entities/accountUpdate.entity.ts:
```
import { IUpdateAccount } from '../interfaces/account.interface';
import { RefreshTokensEntity } from './refreshTokens.entity';
import { UpdateAccountRequestDto } from '../dto/update-account.dto';
import { CourseStatus } from '@prisma/client';

export class AccountUpdateEntity extends RefreshTokensEntity implements IUpdateAccount {
    xUserId: string;
    deviceId: string;
    installationId: string;
    isAccessMp: boolean;
    userGateToken: string;
    accessTokenCourse: string;
    refreshTokenCourse: string;
    isValidAccessTokenCourse: boolean;
    statusCourse: CourseStatus;

    constructor(account: UpdateAccountRequestDto) {
        super(account);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        this.xUserId = account.xUserId;
        this.deviceId = account.deviceId;
        this.installationId = account.installationId;
        this.isAccessMp = true;
        this.userGateToken = account.userGateToken;
        this.accessTokenCourse = account.accessTokenCourse;
        this.refreshTokenCourse = account.refreshTokenCourse;
        this.isValidAccessTokenCourse = true;
        this.statusCourse = account.statusCourse;

        Object.assign(this, account);
        return this;
    }
}

```

src/module/account/entities/accountWithProxy.entity.ts:
```
import { CitySM, Proxy } from '@prisma/client';
import { AccountEntity } from './account.entity';
import { IAccountWithProxy } from '../interfaces/account.interface';

export class AccountWithProxyEntity extends AccountEntity implements IAccountWithProxy {
    proxy: Proxy | null;
    citySM: CitySM;

    constructor(account: Partial<AccountWithProxyEntity>) {
        super(account);
        Object.assign(this, account);
        return this;
    }
}

```

src/module/account/entities/citySM.entity.ts:
```
import { CitySM } from '@prisma/client';
import { IFindCitiesAccount } from '../interfaces/account.interface';

export class CitySMEntity implements CitySM {
    cityId: string;
    name: string;
    fullName: string;

    createdAt: Date;
    updatedAt: Date;

    constructor(city: Partial<IFindCitiesAccount>) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        this.cityId = city.id;
        Object.assign(this, city);
        return this;
    }
}

```

src/module/account/entities/courseTokens.entity.ts:
```
import { ICourseTokens } from '../interfaces/account.interface';

export class CourseTokensEntity implements ICourseTokens {
    userGateToken: string;
    accessTokenCourse: string;
    refreshTokenCourse: string;
    isValidAccessTokenCourse: boolean;

    constructor(tokens: ICourseTokens) {
        Object.assign(this, tokens);
        return this;
    }
}

```

src/module/account/entities/deviceInfo.entity.ts:
```
import { IDeviceInfo } from '../interfaces/deviceInfo.interface';

export class DeviceInfoEntity {
    id: string;
    accountId: string;
    osVersion: string;
    buildVersion: string;
    brand: string;
    model: string;
    screenResolution: string;
    browserVersion: string;
    IP: string;

    createdAt: Date;
    updatedAt: Date;

    constructor(partial: Partial<DeviceInfoEntity>) {
        Object.assign(this, partial);
    }

    getDalvikUserAgent(): string {
        return `Dalvik/2.1.0 (Linux; U; Android ${this.osVersion}; ${this.model} Build/${this.buildVersion})`;
    }

    getBrowserUserAgent(): string {
        return `Mozilla/5.0 (Linux; Android ${this.osVersion}; ${this.model} Build/${this.buildVersion}; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/${this.browserVersion} Mobile Safari/537.36`;
    }

    getDeviceParams(): IDeviceInfo {
        return {
            id: this.id,
            osVersion: this.osVersion,
            deviceModel: `${this.brand} ${this.model}`,
            buildVersion: this.buildVersion,
            screenResolution: this.screenResolution,
            browserVersion: this.browserVersion,
            IP: this.IP,
            uaDalvik: this.getDalvikUserAgent(),
            uaBrowser: this.getBrowserUserAgent(),
        };
    }
}

```

src/module/account/entities/headers.entity.ts:
```
import md5 from 'md5';
import { IRequestHeadersCourse, IRequestHeadersUserGate, ISportmasterRequestHeaders } from '../interfaces/headers.interface';
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class SportmasterHeadersService {
    private prefixHash = 'eb1a3e30291bc971c4da0e86375961a4';
    private userAgentMobile: string = 'android-4.70.0-google(56380)';
    private userAgentMobileWeb: string =
        'Mozilla/5.0 (Linux; Android 7.1.2; ASUS_Z01QD Build/N2G48H; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.70 Mobile Safari/537.36 android-4.52.0-google(48799)';
    private locale: string = 'ru';
    private country: string = 'RU';
    private eutc: string = 'UTC+3';
    private acceptEncoding: string = 'gzip, deflate';
    private acceptLanguage: string = 'ru-RU,en-US;q=0.9';
    private contentType: string = 'application/json; charset=utf-8';
    private accept: string = 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8';
    private acceptCourse: string = 'application/json, text/plain, */*';
    private aplautBuild: string = '2';
    private secFetchSite: string = 'same-origin';
    private secFetchMode: string = 'cors';
    private secFetchDest: string = 'empty';

    private host: string = this.configService.getOrThrow('HOST_DONOR');
    private hostSite: string = 'www.' + this.configService.getOrThrow('HOST_DONOR_SITE');
    private xRequestedWith: string = this.configService.getOrThrow('X_REQUESTED_WITH');
    private onlineCourses: string = this.configService.getOrThrow('ONLINE_COURSES');

    constructor(private configService: ConfigService) {}

    getHeadersMobile(url: string, { deviceId, accountId, installationId, cityId, xUserId, accessToken }: any): ISportmasterRequestHeaders {
        const timestamp = String(Math.floor(Date.now() / 1000));
        return {
            'User-Agent': this.userAgentMobile,
            Host: this.host,
            Locale: this.locale,
            Country: this.country,
            'Device-Id': deviceId,
            'Account-Id': accountId,
            'Installation-Id': installationId,
            'City-Id': cityId,
            Eutc: this.eutc,
            'x-user-id': xUserId,
            Authorization: accessToken,
            //Host: this.host,
            'Accept-Encoding': this.acceptEncoding,
            'Content-Type': this.contentType,
            Timestamp: timestamp,
            'Aplaut-Id': this.generateHash(url, xUserId, timestamp),
            'Aplaut-Build': this.aplautBuild,
        };
    }

    getHeadersForSearchAccount(url: string, { deviceId, installationId, cityId, xUserId, accessToken }: any): Record<string, string> {
        const timestamp = String(Math.floor(Date.now() / 1000));

        return {
            'User-Agent': this.userAgentMobile,
            Locale: 'ru',
            Country: 'RU',
            'Device-Id': deviceId,
            'X-Device-Id': deviceId,
            'Installation-Id': installationId,
            'X-Request-Id': crypto.randomUUID(),
            'City-Id': cityId,
            'X-User-Id': xUserId,
            Timestamp: timestamp,
            'Aplaut-Id': this.generateHash(url, xUserId, timestamp),
            'Aplaut-Build': '2',
            Accept: 'application/json',
            Authorization: accessToken,
            'Content-Type': 'application/json; charset=UTF-8',
            'Accept-Encoding': 'gzip, deflate, br',
        };
    }

    getHeadersUserGate(userGateToken: string): IRequestHeadersUserGate {
        return {
            'User-Agent': this.userAgentMobileWeb,
            Host: this.hostSite,
            'Upgrade-Insecure-Requests': 1,
            Accept: this.accept,
            'Ug-Token': userGateToken,
            'Accept-Encoding': this.acceptEncoding + ', br',
            'Accept-Language': this.acceptLanguage,
            'X-Requested-With': this.xRequestedWith,
            Referer: this.onlineCourses,
        };
    }

    getHeadersWithAccessToken(accessToken: string, videoId?: string, lessonId?: string, mnemocode?: string): IRequestHeadersCourse {
        let referer;
        if (!mnemocode) {
            referer = this.onlineCourses;
        } else {
            referer = `https://${this.hostSite}courses/mobile-player/?videoId=${videoId}&type=video&lessonId=${lessonId}&mnemocode=${mnemocode}`;
        }

        return {
            'User-Agent': this.userAgentMobileWeb,
            Host: this.hostSite,
            Accept: this.acceptCourse,
            Accesstoken: accessToken,
            'X-Requested-With': this.xRequestedWith,
            'Sec-Fetch-Site': this.secFetchSite,
            'Sec-Fetch-Mode': this.secFetchMode,
            'Sec-Fetch-Dest': this.secFetchDest,
            'Accept-Encoding': this.acceptEncoding + ', br',
            'Accept-Language': this.acceptLanguage,
            Referer: referer,
        };
    }

    private generateHash(url: string, xUserId: string, timestamp: string): string {
        const combinedString = this.prefixHash + url + timestamp + xUserId;
        return md5(combinedString);
    }
}

```

src/module/account/entities/lesson.entity.ts:
```
import { Lesson, LessonStatus, OriginalCourse } from '@prisma/client';

export class LessonEntity implements Lesson {
    lessonId: string;
    title: string;
    duration: number;
    position: number;
    status: LessonStatus;
    videoId: string;
    courseId: string;
    mnemocode: string;

    constructor(lesson: Lesson & { course: OriginalCourse }) {
        Object.assign(this, lesson);
        this.mnemocode = lesson.course.mnemocode;
    }
}

```

src/module/account/entities/refreshTokens.entity.ts:
```
import { IRefreshAccount, IRefreshDataAccount } from '../interfaces/account.interface';

export class RefreshTokensEntity implements IRefreshDataAccount {
    accessToken: string;
    refreshToken: string;
    expiresInAccess: Date;
    expiresInRefresh: Date;

    constructor(tokens: IRefreshAccount) {
        const expiresInTimestamp = Date.now() + +tokens.expiresIn * 1000;
        const expiresInDateAccess = new Date(expiresInTimestamp);

        const now = new Date();
        const expiresInRefresh = new Date(now.getFullYear(), now.getMonth() + 1, now.getDate());
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        this.accessToken = tokens.accessToken;
        this.refreshToken = tokens.refreshToken;
        this.expiresInAccess = expiresInDateAccess;
        this.expiresInRefresh = expiresInRefresh;

        Object.assign(this, tokens);
        return this;
    }
}

```

src/module/account/guard/zenno.guard.ts:
```
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class ZennoGuard implements CanActivate {
    constructor(private configService: ConfigService) {}

    canActivate(context: ExecutionContext): boolean {
        try {
            const request = context.switchToHttp().getRequest();
            const zennoHashRequest = request.headers['zenno'];
            const ZENNO_HASH = this.configService.getOrThrow('ZENNO_HASH');
            return zennoHashRequest == ZENNO_HASH;
        } catch {
            return false;
        }
    }
}

```

src/module/account/interfaces/account.interface.ts:
```
import { Account, CitySM, CourseStatus, Proxy } from '@prisma/client';
import { SearchProductInterface } from './search-product.interface';
import { CartInterface } from './cart.interface';
import { PickupAvabilityInterface, Shop } from './pickup-avability.interface';
import { IItemsCart } from '../../telegram/utils/cart.utils';
import { IDeviceInfo } from './deviceInfo.interface';

export interface IRefreshAccount {
    accessToken: string;
    refreshToken: string;
    expiresIn: string;
}

export interface ICourseTokens {
    userGateToken: string;
    accessTokenCourse: string;
    refreshTokenCourse: string;
    isValidAccessTokenCourse: boolean;
}

export interface ICourseStatus {
    statusCourse: CourseStatus;
}

export interface IRefreshDataAccount {
    accessToken: string;
    refreshToken: string;
    expiresInAccess: Date;
    expiresInRefresh: Date;
}

export interface IUpdateAccount {
    accessToken: string;
    refreshToken: string;
    xUserId: string;
    deviceId: string;
    installationId: string;
    expiresInAccess: Date;
    expiresInRefresh: Date;
    isAccessMp: boolean;
    userGateToken: string | null;
    statusCourse: CourseStatus;
    accessTokenCourse: string;
    refreshTokenCourse: string;
    isValidAccessTokenCourse: boolean;
}

export interface AccountWDevice extends Account {
    deviceInfo: IDeviceInfo | null;
}

export interface IEmailFromDb {
    email: string;
    passImap: string;
    passEmail: string;
}

export interface IAccountCashing {
    accountId: string;
    email: string;
    requestId: string;
    foundedProduct?: SearchProductInterface;
    cartResponse?: CartInterface;
    accessItemsPickupAvailability: PickupAvabilityInterface;
    internalPickupAvabilityItems: IItemsCart[];
    shop?: Shop;
    version?: string;
    potentialOrder?: string;
}

export interface IAccountWithProxy extends Account {
    proxy: Proxy | null;
    citySM: CitySM;
}

export interface IFindCitiesAccount {
    id: string;
    name: string;
    fullName: string;
    eutc: string;
    macrocityId: string;
    hasMetro: boolean;
}

export interface IRecipient {
    firstName: string;
    lastName: string;
    number: string;
    email: string;
}

export interface IRecipientOrder extends IRecipient {
    potentialOrder: string;
}

```

src/module/account/interfaces/cart.interface.ts:
```
export interface CartInterface {
    data: Cart;
}

export interface Cart {
    cartFull: CartFull;
    cartLite?: any;
}

export interface CartFull {
    version: number;
    availableItems: AvailableItem[];
    unselectedItems?: any;
    unallocatedItems: CartItemId[];
    deletedItems: any[];
    soldOutLines: SoldOutLine[];
    promoCodes: any[];
    obtainPoints: any[];
    owner: Owner;
    banners: any[];
    bankProducts: BankProducts;
    totals: Totals;
    dailyOfferExpiresIn?: any;
    deliveryInfo: DeliveryInfo2;
    bonusesInfo: BonusesInfo;
    altPotentialOrders: AltPotentialOrders;
    receiver?: any;
}

export interface AltPotentialOrders {
    intPickup?: any;
    courierDelivery?: any;
}

export interface BonusesInfo {
    bonusApplied: boolean;
    isBonusAvailable: boolean;
    bonusInfoDocumentId: string;
    potentialBonuses: number;
}

export interface DeliveryInfo2 {
    unallocatedItemsDeliveryTypes: string[];
    allocatedItemsDeliveryTypes: any[];
}

export interface Totals {
    productsAmount: number;
    catalogDiscount: ItemPrice;
    priceWoDiscount: ItemPrice;
    bonuses: ItemPrice;
    promo: ItemPrice;
    total: ItemPrice;
    totalDeliveryCost: ItemPrice;
    totalWoDelivery: ItemPrice;
    pendingPotentialBonuses: number;
    pendingPotentialBonusesPromo: PendingPotentialBonusesPromo[];
}

export interface PendingPotentialBonusesPromo {
    mdmId: number;
    name: string;
    amount: number;
}

export interface BankProducts {
    installmentBanner: InstallmentBanner;
    creditBanner: InstallmentBanner;
    bnplSovcombankBanner: InstallmentBanner;
    isCreditAvailable: boolean;
    isInstallmentAvailable: boolean;
    isBnplSovcombankAvailable: boolean;
}

export interface InstallmentBanner {
    id: string;
    bannerHeader: string;
    bannerText: string;
    image: string;
    url: string;
    slot: string;
}

export interface Owner {
    profileId: string;
    fio: string;
    phone: Phone;
    email: string;
}

export interface Phone {
    countryCode: number;
    nationalNumber: number;
    isoCode: string;
}

export interface AvailableItem {
    cartItemId: CartItemId;
    name: string;
    image: string;
    params: Param[];
    quantity: number;
    availableAmount: number;
    itemPrice: ItemPrice;
    itemPriceWoDiscount: ItemPrice;
    totalPrice: ItemPrice;
    totalPriceWoDiscount: ItemPrice;
    badges: Badge[];
    hasInstallment: boolean;
    deliveryInfo: DeliveryInfo;
    wareAdditionDate: string;
    catalogPrice: ItemPrice;
    catalogDiscount: ItemPrice;
}

export interface SoldOutLine {
    cartItemId: CartItemId;
    name: string;
    image: string;
    params: Param[];
    quantity: number;
    itemPrice: ItemPrice;
    itemPriceWoDiscount: ItemPrice;
    totalPrice: ItemPrice;
    totalPriceWoDiscount: ItemPrice;
    catalogPrice: ItemPrice;
    catalogDiscount: ItemPrice;
}

export interface DeliveryInfo {
    deliveryTypes: DeliveryType[];
    onlyIntPickup: boolean;
    isExpressDeliveryEnabled: boolean;
    isDeliveryServicesEnabled: boolean;
}

export interface DeliveryType {
    title: string;
    value: string;
}

export interface Badge {
    id: string;
    title: string;
    bgColor: string;
    textColor: string;
    type: string;
    description: string;
    url?: any;
}

export interface ItemPrice {
    value: number;
    currency: string;
}

export interface Param {
    name: string;
    value: string;
}

export interface CartItemId {
    productId: string;
    sku: number;
    linesIds: string[];
}

export interface ICartItemsInfo {
    cartItemId: CartItemId;
    name: string;
}

```

src/module/account/interfaces/cookie.interface.ts:
```
export interface Cookie {
    domain: string;
    hostOnly: boolean;
    httpOnly: boolean;
    name: string;
    path: string;
    sameSite: string;
    secure: boolean;
    session: boolean;
    storeId: null;
    value: string;
}

```

src/module/account/interfaces/course-data.interface.ts:
```
export interface CourseData {
    id: number;
    mnemocode: string;
    title: string;
    image: string;
    tag: string;
    duration: number;
    points: number;
    stats: Stats;
    status: string;
    cover: string;
    lessons: Lesson[];
    test: Test;
    selection?: any;
    content: string;
}

export interface Test {
    id: number;
    questions: Question[];
    timeToRespond: number;
    status: string;
    timer?: any;
}

export interface Question {
    id: number;
    title: string;
    image?: any;
    answers: Answer[];
}

export interface Answer {
    id: number;
    text: string;
}

export interface Lesson {
    id: number;
    title: string;
    description: string;
    image: string;
    duration: number;
    videoId: string;
    status: string;
    timer?: any;
}

export interface Stats {
    countLessons: number;
    countLessonsLearned?: any;
}

```

src/module/account/interfaces/course-list.interface.ts:
```
export interface CourseList {
    list: Course[];
    pagination: Pagination;
}

export interface Pagination {
    limit: number;
    offset: number;
    total: number;
}

export interface Course {
    id: number;
    title: string;
    image: string;
    tag: string;
    duration: number;
    points: number;
    stats: Stats;
    status: string;
}

export interface Stats {
    countLessons: number;
    countLessonsLearned: number;
}

```

src/module/account/interfaces/course.interface.ts:
```
import { AccountCourse, AccountLessonProgress, Lesson, OriginalCourse } from '@prisma/client';

export interface CourseWithLessons extends OriginalCourse {
    lessons: Lesson[];
}

export interface IAccountCourse {
    accountId: string;
    statusCourse: string;
    AccountCourse: IAccountCourseWLesson[];
}

export interface ICourseWLesson extends OriginalCourse {
    lessons: IAccountCourseWProgress[];
}

export interface IAccountCourseWLesson extends AccountCourse {
    course: ICourseWLesson;
}

export interface IAccountCourseWProgress extends Lesson {
    AccountLessonProgress: AccountLessonProgress[];
}

export interface IWatchLesson {
    mnemocode: string;
    videoId: string;
    lessonId: string;
    duration: number;
}

```

src/module/account/interfaces/deviceInfo.interface.ts:
```
export interface IBaseDeviceInfo {
    osVersion: string;
    screenResolution: string;
    browserVersion: string;
    IP: string;
}

export interface ICreateDeviceInfo extends IBaseDeviceInfo {
    accountId: string;
    buildVersion: string;
    brand: string;
    model: string;
}

export type IUpdateDeviceInfo = Omit<ICreateDeviceInfo, 'accountId'>;

export interface IDeviceInfo extends IBaseDeviceInfo {
    id: string;
    deviceModel: string;
    buildVersion: string;
    uaDalvik: string;
    uaBrowser: string;
}

```

src/module/account/interfaces/headers.interface.ts:
```
interface IRequestHeaders {
    'User-Agent': string;
    Locale: string;
    Country: string;
    'Device-Id': string;
    'Account-Id': string;
    'Installation-Id': string;
    'City-Id': string;
    Eutc: string;
    'x-user-id': string;
    Authorization: string;
    Host: string;
    'Accept-Encoding': string;
    'Content-Type': string;
    Timestamp: string;
    'Aplaut-Id': string;
    'Aplaut-Build': string;
}

export type ISportmasterRequestHeaders = Partial<IRequestHeaders>;

export interface IRequestHeadersUserGate {
    'User-Agent': string;
    Host: string;
    'Upgrade-Insecure-Requests': number;
    Accept: string;
    'Ug-Token': string;
    'Accept-Encoding': string;
    'Accept-Language': string;
    'X-Requested-With': string;
    Referer: string;
}

export interface IRequestHeadersCourse {
    'User-Agent': string;
    Host: string;
    Accept: string;
    Accesstoken: string;
    'Sec-Fetch-Site': string;
    'Sec-Fetch-Mode': string;
    'Sec-Fetch-Dest': string;
    'X-Requested-With': string;
    'Accept-Encoding': string;
    'Accept-Language': string;
    Referer: string;
}

```

src/module/account/interfaces/lesson-progress.interface.ts:
```
export interface LessonProgressData {
    accountId: string;
    accountCourseAccountCourseId: number;
    lessonId: string;
    nextViewAt: null;
}

```

src/module/account/interfaces/order-info.interface.ts:
```
export interface OrderInfoInterface {
    data: Data;
}

export interface Data {
    order: Order;
}

export interface Order {
    number: string;
    createdDate: string;
    status: Status;
    needPrepay: boolean;
    deliveryInfo: DeliveryInfo;
    payment: Payment;
    totals: Totals;
    items: Item[];
    services?: any;
    possibleActions: string[];
    cancelReasons: CancelReason[];
    isCancelled: boolean;
    promoCodes: any[];
    statusHistory: StatusHistory[];
    orderCancelNotification?: any;
    isCancelling: boolean;
    authCode?: any;
    showQrCode: boolean;
}

export interface StatusHistory {
    status: string;
    statusText: string;
    statusDate: string;
    textColor?: any;
    backgroundColor?: any;
}

export interface CancelReason {
    reasonId: string;
    reasonName: string;
    allowComment: boolean;
}

export interface Item {
    productId: string;
    skuId: number;
    amount: number;
    name: string;
    totalPrice: TotalCatalogCost;
    priceWoDiscount: TotalCatalogCost;
    catalogDiscount: TotalCatalogCost;
    sumTotalPrice: TotalCatalogCost;
    sumPriceWoDiscount: TotalCatalogCost;
    sumDiscount: TotalCatalogCost;
    image: string;
    params: Param[];
}

export interface Param {
    name: string;
    value: string;
}

export interface Totals {
    totalCatalogCost: TotalCatalogCost;
    totalDeliveryCost: TotalCatalogCost;
    totalServicesCost: TotalCatalogCost;
    totalBonusesUsed: TotalCatalogCost;
    totalCost: TotalCatalogCost;
    promocodeDiscount: TotalCatalogCost;
    catalogDiscount: TotalCatalogCost;
    egcPaid?: any;
    egcToPay?: any;
}

export interface TotalCatalogCost {
    value: number;
    currency: string;
}

export interface Payment {
    needPayment: boolean;
    prepayLimitTime?: any;
    isPayed: boolean;
    paymentMethod: PaymentMethod;
    paymentTools: string[];
    promoList: any[];
    eCheckUrl?: any;
}

export interface PaymentMethod {
    id: string;
    name: string;
    paymentMethod: string;
}

export interface DeliveryInfo {
    type: Type;
    delivery?: any;
    extPickup?: any;
    intPickup: IntPickup;
    receivingDateFrom?: any;
    planReceivingDateTimeFrom: string;
    receivingDateTo?: any;
    receivingTimeSlot?: any;
    territoryDate?: any;
    storagePeriod?: any;
    receiver: Receiver;
    shippingMethod: string;
    shippingMethodLevel: string;
    deliveryServiceCancellingMessage?: any;
    deliveryClickInfo?: any;
}

export interface Receiver {
    fio: string;
    phone: ShopPhone;
    email: string;
}

export interface IntPickup {
    shopId: string;
    shopAddress: string;
    shopName: string;
    shopPhone: ShopPhone;
    geoPoint: GeoPoint;
    weekSchedule: WeekSchedule[];
    convenienceShop: boolean;
    inventory?: any;
    isPickUpAutoAvailable: boolean;
}

export interface WeekSchedule {
    dayNumber: number;
    dayName: string;
    workTime: WorkTime;
}

export interface WorkTime {
    workStartTime: string;
    workEndTime: string;
}

export interface GeoPoint {
    lat: number;
    lng: number;
}

export interface ShopPhone {
    countryCode: number;
    nationalNumber: number;
    isoCode: string;
}

export interface Type {
    title: string;
    value: string;
}

export interface Status {
    status: string;
    statusText: string;
    statusDate?: any;
    textColor: string;
    backgroundColor: string;
}

```

src/module/account/interfaces/orders.interface.ts:
```
export interface OrdersInterface {
    data: Data;
}

export interface Data {
    orders: Order[];
    filters: Filter[];
}

export interface Filter {
    id: string;
    name: string;
    isSelected: boolean;
}

export interface Order {
    number: string;
    receiptCode?: string;
    date: string;
    status: Status;
    totalSum: TotalSum;
    deliveryType: DeliveryType;
    showQrCode: boolean;
    needPayment?: boolean;
    prepayLimitTime?: any;
}

export interface DeliveryType {
    title: string;
    value: string;
}

export interface TotalSum {
    value: number;
    currency: string;
}

export interface Status {
    status: string;
    statusText: string;
    statusDate?: any;
    textColor: string;
    backgroundColor: string;
}

```

src/module/account/interfaces/pickup-avability.interface.ts:
```
export interface PickupAvabilityInterface {
    data: Data;
}

export interface Data {
    list: ShopList[];
}

export interface ShopList {
    shop: Shop;
    potentialOrders: PotentialOrder[];
    unavailableItems: any[];
}

export interface PotentialOrder {
    totalAvailabilityDate: string;
    totalAvailabilityDateTime: string;
    territoryDate: string;
    totalPrepay: boolean;
    availability: string;
    availableItems: AvailableItem[];
    storeDays: number;
    deliveryPrice: DeliveryPrice;
}

export interface DeliveryPrice {
    value: number;
    currency: string;
}

export interface AvailableItem {
    productId: string;
    sku: number;
    linesIds: string[];
}

export interface Shop {
    id: string;
    address: string;
    shopNumber: number;
    name: string;
    weekSchedule: WeekSchedule[];
    shopFormat: ShopFormat;
    geoPoint: GeoPoint;
    metroStations: any[];
    isConvenience: boolean;
    shopCondition: string;
    phone: Phone;
    city: City;
    shopWay?: any;
    inventory?: any;
}

export interface City {
    id: string;
    name: string;
    eutc?: any;
    macrocityId?: any;
    hasMetro?: any;
}

export interface Phone {
    countryCode: number;
    nationalNumber: number;
    isoCode: string;
}

export interface GeoPoint {
    lat: number;
    lng: number;
}

export interface ShopFormat {
    id: string;
    onlineShopName: string;
    image: string;
}

export interface WeekSchedule {
    dayNumber: number;
    dayName: string;
    workTime: WorkTime;
}

export interface WorkTime {
    workStartTime: string;
    workEndTime: string;
}

```

src/module/account/interfaces/promocode.interface.ts:
```
export interface PromocodeInterface {
    data: Data;
}

export interface Data {
    list: Promocode[];
}

export interface Promocode {
    issueDate?: string;
    startDate: string;
    dateEnd: string;
    actionName: string;
    promoId: string;
    image: string;
    textLegal: string;
    textDetail: string;
    refDetail: string;
    color?: string;
}

```

src/module/account/interfaces/search-product.interface.ts:
```
export interface SearchProductInterface {
    data: Data;
}

export interface Data {
    list: List[];
    hasMore: boolean;
    meta: Meta;
}

export interface Meta {
    facets: Facet[];
    sorts: Sort[];
    category?: any;
    count: number;
    subqueryReference: string;
    subqueryRefWoFacets: string;
    queryTextCorrection: QueryTextCorrection;
    productRedirect: boolean;
    mediaRedirect: boolean;
    mediaLink: string;
    dailyOfferExpiresIn?: any;
}

export interface QueryTextCorrection {
    initQueryText: string;
    correctedQueryText?: any;
}

export interface Sort {
    value: string;
    isAvailable: boolean;
    selectedByUser: boolean;
    subqueryReference: string;
    subqueryColorModelCount: number;
    uiCaption: string;
    color?: any;
    availableShops?: any;
    range?: any;
    badge?: any;
    siteTip?: any;
}

export interface Facet {
    facetId: string;
    caption: string;
    facetValues: FacetValue[];
    displayType: string;
    subqueryWoFacetVals?: any;
    siteTip?: any;
}

export interface FacetValue {
    value: string;
    isAvailable: boolean;
    selectedByUser: boolean;
    subqueryReference: string;
    subqueryColorModelCount: number;
    uiCaption: string;
    color?: any;
    availableShops?: AvailableShop[];
    range?: any;
    badge?: any;
    siteTip?: any;
}

export interface AvailableShop {
    shopId: string;
    selectedByUser: boolean;
    subqueryReference: string;
}

export interface List {
    id: string;
    name: string;
    code: string;
    skus: Skus[];
    price: Price;
    rating: number;
    reviews: number;
    markers: Marker[];
    richMarker?: any;
    richIcon?: any;
    dailyOfferExpiresIn?: any;
    primaryPhotoUrl: string;
    medias: Media[];
    brand: Brand;
    linkedColorModels: LinkedColorModel[];
    sizeScale: SizeScale;
    shareLink: string;
    archived: boolean;
    productSetAvailable: boolean;
    personalPrice?: any;
    onSaleSoon: boolean;
    hasAssociatedAttributes: boolean;
    sizeTableName: string;
}

export interface SizeScale {
    name: string;
    tableHtml: string;
    jpgImageUrl?: any;
}

export interface LinkedColorModel {
    id: string;
    compositeColor: CompositeColor;
    photoUrl: string;
}

export interface CompositeColor {
    text: string;
    hexColor: string;
}

export interface Brand {
    name: string;
    image: string;
    url: string;
    imageBreadCrumbs: string;
}

export interface Media {
    type: string;
    urls: string[];
}

export interface Marker {
    id: string;
    title: string;
    backgroundColor: string;
    textColor: string;
    icon?: any;
    type: string;
    description?: any;
    url?: any;
}

export interface Price {
    catalog: Catalog;
    retail: Catalog;
    discountRate: number;
    discountAmount: Catalog;
}

export interface Catalog {
    value: number;
    currency: string;
}

export interface Skus {
    id: string;
    code: string;
    availability: Availability;
    sizes: Size[];
    sizeFacetValue: string;
    isReplenishment: boolean;
    associatedAttributes: any[];
}

export interface Size {
    id: number;
    value: string;
    name?: string;
}

export interface Availability {
    isOnlineAvailable: boolean;
    isOfflineAvailable: boolean;
}

```

src/module/account/interfaces/short-info.interface.ts:
```
export interface ShortInfoInterface {
    bonusCount: number;
    qrCode: string;
    bonusDetails: Detail[];
    citySMName: string;
}

interface Detail {
    bonusType: string;
    amount: number;
    dateEnd: string;
}

```

src/module/account/interfaces/userGateToken.interface.ts:
```
export interface UserGateTokenInterface {
    data: Data;
}

export interface Data {
    userGateToken: string;
}

```

src/module/auth/auth.controller.ts:
```
import { Body, Controller, HttpCode, Post, UnauthorizedException } from '@nestjs/common';
import { LoginDto, LoginResponseDto } from './dto/login.dto';
import { ConfigService } from '@nestjs/config';

@Controller('auth')
export class AuthController {
    private ZENNO_HASH = this.configService.getOrThrow('ZENNO_HASH');

    // constructor(private readonly authService: AuthService) {}
    constructor(private configService: ConfigService) {}

    //
    // @Post('register')
    // async register(@Body() regDto: RegisterDto): Promise<RegisterResponseDto> {
    //     return await this.authService.register(regDto);
    // }
    //
    @HttpCode(200)
    @Post('login')
    async login(@Body() authDto: LoginDto): Promise<LoginResponseDto> {
        const status = this.ZENNO_HASH == authDto.key;
        if (status) return { key: this.ZENNO_HASH };
        throw new UnauthorizedException('Не правильный ключ');
    }
}

```

src/module/auth/auth.module.ts:
```
import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';

@Module({
    // imports: [CqrsModule, PassportModule.register({ defaultStrategy: 'jwt' }), JwtModule.registerAsync(getJWTConfig())],
    // providers: [AuthService, AccessStrategy],
    controllers: [AuthController],
    // exports: [PassportModule, AuthService],
})
export class AuthModule {}

```

src/module/auth/auth.provider.ts:
```
import * as argon2 from 'argon2';

export class AuthenticationProvider {
    static async generateHash(password: string): Promise<string> {
        return await argon2.hash(password);
    }

    static async validateHash(password: string, passwordHash: string): Promise<boolean> {
        return await argon2.verify(passwordHash, password);
    }
}

```

src/module/auth/auth.service.ts:
```
import { Injectable } from '@nestjs/common';

@Injectable()
export class AuthService {
    // constructor(
    //     private readonly commandBus: CommandBus,
    //     private readonly queryBus: QueryBus,
    //     private jwtService: JwtService,
    // ) {}
    //
    // private createJwtPayload(user: IUserJwtPayload): IJWTPayload {
    //     return {
    //         sub: user.uuid,
    //         role: user.role,
    //     };
    // }
    //
    // private createJwtToken(payload: object): string {
    //     return this.jwtService.sign(payload);
    // }
    //
    // async register(regDto: RegisterDto): Promise<RegisterResponseDto> {
    //     const { email, password, name, birthDay } = regDto;
    //
    //     const existUser = await this.queryBus.execute<GetUserByEmailQuery, UserEntity>(new GetUserByEmailQuery(email));
    //     if (existUser) {
    //         throw new BadRequestException(ALREADY_REGISTERED_ERROR);
    //     }
    //     const passwordHash = await AuthenticationProvider.generateHash(password);
    //
    //     const createdUser = await this.commandBus.execute<CreateUserCommand, User>(
    //         new CreateUserCommand(email, name, passwordHash, birthDay),
    //     );
    //     const payload = this.createJwtPayload(createdUser);
    //
    //     const accessToken = this.createJwtToken(payload);
    //     return { accessToken };
    // }
    //
    // async login(logDto: LoginDto): Promise<LoginResponseDto> {
    //     const { email, password } = logDto;
    //
    //     const existUser = await this.queryBus.execute<GetUserByEmailQuery, UserEntity>(new GetUserByEmailQuery(email));
    //     if (!existUser) {
    //         throw new BadRequestException(USER_NOT_FOUND_ERROR);
    //     }
    //     const passwordHashUser = existUser.passwordHash;
    //
    //     const isPasswordValid = await AuthenticationProvider.validateHash(password, passwordHashUser);
    //     if (!isPasswordValid) {
    //         throw new BadRequestException(WRONG_PASSWORD_ERROR);
    //     }
    //     const payload = this.createJwtPayload(existUser);
    //
    //     const accessToken = this.createJwtToken(payload);
    //     return { accessToken };
    // }
}

```

src/module/auth/constants/auth.constants.ts:
```
export const ALREADY_REGISTERED_ERROR = 'Такой пользователь уже был зарегистрирован';
export const USER_NOT_FOUND_ERROR = 'Пользователь с таким email не найден';
export const WRONG_PASSWORD_ERROR = 'Неверный пароль';

```

src/module/auth/dto/login.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

// const UserLoginRequestSchema = z.object({
//     email: z.string().email(),
//     password: z.string(),
// });

const UserLoginRequestSchema = z.object({
    key: z.string(),
});

// const UserLoginResponseSchema = z.object({
//     accessToken: z.string(),
// });

const UserLoginResponseSchema = z.object({
    key: z.string(),
});

export namespace UserLoginCommand {
    export const RequestSchema = UserLoginRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UserLoginResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class LoginDto extends createZodDto(UserLoginCommand.RequestSchema) {}

export class LoginResponseDto extends createZodDto(UserLoginCommand.ResponseSchema) {}

```

src/module/auth/dto/register.dto.ts:
```
import { z } from 'zod';
import { createZodDto } from 'nestjs-zod';

const minAge = 7;
const currentYear = new Date().getFullYear();

const UserRegisterRequestSchema = z.object({
    email: z.string().email(),
    name: z.string().optional(),
    birthDay: z
        .string()
        .optional()
        .refine(
            date => {
                if (date) {
                    const formDateBirthDay = new Date(date);
                    const age = currentYear - formDateBirthDay.getFullYear();
                    return age >= 7;
                }
                return true;
            },
            { message: `Пользователь должен быть старше ${minAge} лет` },
        )
        .transform(date => (date ? new Date(date) : null)),
    password: z
        .string()
        .min(8)
        .regex(/^(?=.*\d).+$/),
});

const UserRegisterResponseSchema = z.object({
    accessToken: z.string(),
});

export namespace UserRegisterCommand {
    export const RequestSchema = UserRegisterRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = UserRegisterResponseSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class RegisterDto extends createZodDto(UserRegisterCommand.RequestSchema) {}

export class RegisterResponseDto extends createZodDto(UserRegisterCommand.ResponseSchema) {}

```

src/module/auth/guard/accessToken.guard.ts:
```
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class AccessTokenGuard extends AuthGuard('accessToken') {}

```

src/module/auth/guard/roles.guard.ts:
```
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
    constructor(
        private readonly reflector: Reflector,
    ) {}

    canActivate(context: ExecutionContext): boolean {
        try {
            const accessRoles = this.reflector.get('roles', context.getHandler());
            if (!accessRoles) {
                return false;
            }
            const request = context.switchToHttp().getRequest();
            const userRole = request.user?.userRole;
            return accessRoles.includes(userRole);
        } catch {
            return false;
        }
    }
}

```

src/module/auth/strategy/access.strategy.ts:
```
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { IJWTPayload } from '../types/auth.interface';
import { UserContext } from '../types/user.context.interface';

@Injectable()
export class AccessStrategy extends PassportStrategy(Strategy, 'accessToken') {
    constructor(private readonly configService: ConfigService) {
        super({
            jwtFromRequest: ExtractJwt.fromExtractors([
                request => {
                    return request.headers['authorization'];
                },
            ]),
            ignoreExpiration: false,
            secretOrKey: configService.getOrThrow('ACCESS_TOKEN_JWT_SECRET'),
            signOptions: {
                expiresIn: configService.getOrThrow('ACCESS_TOKEN_EXPIRATION'),
            },
        });
    }

    async validate(payload: IJWTPayload): Promise<UserContext> {
        return {
            sub: payload.sub,
            userRole: payload.role,
        };
    }
}

```

src/module/auth/types/auth.interface.ts:
```
export interface IJWTPayload {
    sub: string;
    role: string;
}

export interface IUserJwtPayload {
    uuid: string;
    role: string;
}

export interface TokenResponseDto {
    accessToken: string;
}

```

src/module/auth/types/user.context.interface.ts:
```
export interface UserContext {
    sub: string;
    userRole: string;
}

```

src/module/bott/bott.module.ts:
```
import { Module } from '@nestjs/common';
import { BottService } from './bott.service';
import { BotTHeadersService } from './headers.service';
import { HttpModule } from '../http/http.module';
import { ProxyModule } from '../proxy/proxy.module';

@Module({
    providers: [BottService, BotTHeadersService],
    exports: [BottService, BotTHeadersService],
    imports: [HttpModule, ProxyModule],
})
export class BottModule {}

```

src/module/bott/bott.service.ts:
```
import { BadRequestException, Inject, Injectable, Logger, UseInterceptors } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '../http/http.service';
import { BotTHeadersService } from './headers.service';
import { Html, ISearchByTelegramId } from './interfaces/bot-t.interface';
import { IReplenishmentUsersBotT } from './interfaces/replenishment-bot-t.interface';
import qs from 'qs';
import { ERROR_GET_STATISTICS } from '../payment/constants/error.constants';
import dayjs from 'dayjs';
import sleep from 'sleep-promise';
import { WrapWithLoading } from './decorators/wrap-with-loading.decorator';
import { Cache, CACHE_MANAGER, CacheInterceptor, CacheKey, CacheTTL } from '@nestjs/cache-manager';
import { getCouponPageKey } from '../cache/cache.keys';

@UseInterceptors(CacheInterceptor)
@Injectable()
export class BottService {
    private readonly logger = new Logger(BottService.name);

    private urlBotT: string = this.configService.getOrThrow('HOST_BOTT_W_PROTOCOL');
    private apiUrlBotT: string = this.configService.getOrThrow('API_BOTT_W_PROTOCOL');
    private sellerTradeBotId: string = this.configService.getOrThrow('SELLER_TRADE_BOT_ID');
    private sellerTradeBotToken: string = this.configService.getOrThrow('SELLER_TRADE_TOKEN');

    constructor(
        private configService: ConfigService,
        private httpService: HttpService,
        private botTHeaders: BotTHeadersService,
        @Inject(CACHE_MANAGER) private cacheManager: Cache,
    ) {}

    private async wrapperFuncLoading<T>(funcToExecute: () => Promise<T>): Promise<T> {
        const MAX_RETRIES = 5;
        const RETRY_DELAY_MS = 1000;

        await this.botTHeaders.ensureTokenUpdated();

        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                if (attempt > 1 || this.botTHeaders.getIsUpdating()) {
                    await this.botTHeaders.ensureTokenUpdated();
                }
                return await funcToExecute();
            } catch (error: any) {
                const isTokenError = this.isCloudflareOrAuthError(error);

                if (isTokenError && attempt < MAX_RETRIES) {
                    this.logger.warn(`Попытка запроса с Bot-t: ${attempt} провалена. Обновляю токен.`);
                    try {
                        await this.botTHeaders.updateTokenClaudeFlare();
                    } catch (updateError: any) {
                        this.logger.error(`Ошибка обновления токена на попытке: ${attempt} : ${updateError.message}`);
                        throw new Error(`Critical: Ошибка при обновлении токена. Ошибка: ${updateError.message}`);
                    }
                    await sleep(RETRY_DELAY_MS * attempt);
                } else if (attempt < MAX_RETRIES) {
                    this.logger.warn(
                        `Попытка ${attempt} провалена, но не связана с обновлением токена: ${error.message}. Пытаюсь еще раз...`,
                    );
                    await sleep(RETRY_DELAY_MS * attempt);
                } else {
                    this.logger.error(`Все ${MAX_RETRIES} попытки провалены. Последняя ошибка: ${error.message}`);
                    throw new Error(`Провалено максимально попыток ${MAX_RETRIES}: ${error.message}`);
                }
            }
        }
        throw new Error('Неизвестная ошибка в wrapperFuncLoading');
    }

    private isCloudflareOrAuthError(error: any): boolean {
        if (error.isAxiosError && error.response) {
            const status = error.response.status;
            return [401, 403].includes(status) || (status === 503 && error.response.data?.includes('Cloudflare'));
        }
        return !!(error.message?.includes('challenge') || error.message?.includes('captcha'));
    }

    @CacheKey('bott:searchIdByTelegramId')
    @CacheTTL(86_400_1000)
    async searchSearchIdByTelegramId(telegramId: string): Promise<ISearchByTelegramId> {
        const params = {
            bot_id: this.sellerTradeBotId,
            token: this.sellerTradeBotToken,
            is_hide: '1',
            term: telegramId,
            _type: 'query',
            q: telegramId,
        };

        const url = `${this.apiUrlBotT}v2/ajax/bot/user/name`;

        const response = await this.httpService.get<ISearchByTelegramId>(url, { params });
        return response.data;
    }

    @WrapWithLoading()
    @CacheKey('bott:getUserBotId')
    @CacheTTL(86_400_1000)
    async getUserBotId(searchId: string): Promise<string> {
        const headers = this.botTHeaders.getHeaders();

        const params = {
            bot_id: this.sellerTradeBotId,
            'BotUserSearch[user_id]': searchId,
        };
        const url = this.urlBotT + `lk/common/users/users/index`;
        const response = await this.httpService.get(url, { headers, params });
        return response.data;
    }

    @WrapWithLoading()
    async userBalanceEdit(userBotId: string, csrfToken: string, amount: string, isPositive: boolean): Promise<string> {
        const headers = this.botTHeaders.getHeaders();

        const params = {
            id: userBotId,
            bot_id: this.sellerTradeBotId,
        };
        const payload = qs.stringify({
            '_csrf-frontend': this.botTHeaders.getCSRFToken(),
            'UserEditBalanceForm[balance]': amount,
            'UserEditBalanceForm[is_positive]': +isPositive,
        });

        const url = this.urlBotT + `lk/common/users/user/balance-edit`;
        const response = await this.httpService.post(url, payload, { headers, params });
        await this.cacheManager.del('bott:getStatistics');
        return response.data;
    }

    async getReplenishment(isPositive: boolean | null = null): Promise<IReplenishmentUsersBotT> {
        const params = {
            token: this.sellerTradeBotToken,
        };

        const payload = {
            bot_id: this.sellerTradeBotId,
            user_id: null,
            is_positive: isPositive,
        };

        const url = this.apiUrlBotT + `v1/bot/replenishment/user/index`;
        const response = await this.httpService.post(url, payload, { params });
        return response.data;
    }

    @WrapWithLoading()
    @CacheKey('bott:getStatistics')
    @CacheTTL(3_600_1000)
    async getStatistics(): Promise<Html> {
        const params = {
            bot_id: this.sellerTradeBotId,
        };

        const url = this.urlBotT + `lk/common/replenishment/main/statistics`;
        const headers = this.botTHeaders.getHeaders();

        try {
            const response = await this.httpService.get(url, { headers, params });
            return response.data;
        } catch (err) {
            throw new BadRequestException(ERROR_GET_STATISTICS);
        }
    }

    @WrapWithLoading()
    async getCouponPage(page = 1): Promise<Html> {
        const cacheKey = getCouponPageKey(page);
        const cached = await this.cacheManager.get<Html>(cacheKey);
        if (cached) {
            this.logger.log(`Отдал данные по ключу ${cacheKey}`);
            return cached;
        }

        const headers = this.botTHeaders.getHeaders();
        const params = {
            bot_id: this.sellerTradeBotId,
            page,
        };

        const url = this.urlBotT + `lk/common/shop/coupon/index`;
        const response = await this.httpService.get(url, { headers, params });

        await this.cacheManager.set(cacheKey, response.data, 300_1000);
        this.logger.log(`Сохранил данные по ключу ${cacheKey}`);

        return response.data;
    }

    @WrapWithLoading()
    async createPromocode(csrfToken: string, promoName: string, discountPercent: number, countActivation = 5, activateAt?: string) {
        const headers = this.botTHeaders.getHeaders();
        const params = {
            bot_id: this.sellerTradeBotId,
            type: '0',
        };

        if (!activateAt) {
            activateAt = dayjs().add(1, 'month').format('YYYY-MM-DDTHH:mm');
        }

        const payload = qs.stringify({
            '_csrf-frontend': this.botTHeaders.getCSRFToken(),
            'ShopCouponCreateForm[code]': promoName,
            'ShopCouponCreateForm[count]': countActivation,
            'ShopCouponCreateForm[min_price]': 50,
            'ShopCouponCreateForm[only_first]': 0,
            'ShopCouponCreateForm[only_one_user_one_coupon]': 0,
            'ShopCouponCreateForm[activate_at]': activateAt,
            'ShopCouponCreateForm[discount]': discountPercent,
        });

        const url = this.urlBotT + `lk/common/shop/coupon/create`;
        const response = await this.httpService.post(url, payload, { headers, params });
        if (response.status === 200 || response.status === 201) {
            this.logger.log(`Удалил данные промокодов на страницах`);
            await Promise.all(
                Array.from({ length: 9 }, (_, index) => {
                    const page = index + 1;
                    const cacheKey = getCouponPageKey(page);
                    return this.cacheManager.del(cacheKey);
                }),
            );
        }

        return response.status;
    }

    @WrapWithLoading()
    async createReplenishPromocode(csrfToken: string, promoName: string, discount: number, countActivation = 1, activateAt?: string) {
        const headers = this.botTHeaders.getHeaders();

        const params = {
            bot_id: this.sellerTradeBotId,
            type: '2',
        };

        if (!activateAt) {
            activateAt = dayjs().add(1, 'month').format('YYYY-MM-DDTHH:mm');
        }

        const payload = qs.stringify({
            '_csrf-frontend': this.botTHeaders.getCSRFToken(),
            'ShopCouponReplenishmentCreate[code]': promoName,
            'ShopCouponReplenishmentCreate[discount]': discount,
            'ShopCouponReplenishmentCreate[count]': countActivation,
            'ShopCouponReplenishmentCreate[only_one_user_one_coupon]': 0,
            'ShopCouponReplenishmentCreate[activate_at]': activateAt,
        });

        const url = this.urlBotT + `lk/common/shop/coupon/replenish`;
        const response = await this.httpService.post(url, payload, { headers, params });
        if (response.status === 200 || response.status === 201) {
            this.logger.log(`Удалил данные промокодов на страницах`);
            await Promise.all(
                Array.from({ length: 9 }, (_, index) => {
                    const page = index + 1;
                    const cacheKey = getCouponPageKey(page);
                    this.cacheManager.del(cacheKey);
                }),
            );
        }
        return response.status;
    }
}

```

src/module/bott/headers.service.ts:
```
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { chromium, Cookie } from 'patchright';
import { extractCsrf } from '../telegram/utils/payment.utils';

@Injectable()
export class BotTHeadersService implements OnModuleInit {
    private readonly logger = new Logger(BotTHeadersService.name);

    private isUpdatingToken = false;
    private tokenUpdatePromise: Promise<void> | null = null;

    private userAgentWeb: string =
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36';

    private identificationCookie = [
        {
            name: '_identity',
            value: '43de6ff6f603486a1d96939938761bc7002cccdfb0d932abad726ef0a43ef1d9a%3A2%3A%7Bi%3A0%3Bs%3A9%3A%22_identity%22%3Bi%3A1%3Bs%3A51%3A%22%5B722008%2C%22qVxIcyWHT2XUY5Ea-DeBfpyeJL3tTJmU%22%2C2592000%5D%22%3B%7D',
            domain: 'bot-t.com',
            path: '/',
            httpOnly: true,
            secure: true,
        },
    ];

    private cookie: string;
    private csrfToken: string;

    async onModuleInit() {
        await this.updateTokenClaudeFlare();
    }

    public getIsUpdating(): boolean {
        return this.isUpdatingToken;
    }

    getHeaders() {
        return {
            'User-Agent': this.userAgentWeb,
            Cookie: this.cookie,
        };
    }

    getCSRFToken() {
        return this.csrfToken;
    }

    ensureTokenUpdated(): Promise<void> {
        if (!this.isUpdatingToken) {
            return Promise.resolve();
        }
        return this.tokenUpdatePromise || Promise.resolve();
    }

    async updateTokenClaudeFlare() {
        if (this.tokenUpdatePromise) {
            return this.tokenUpdatePromise;
        }
        this.isUpdatingToken = true;
        this.tokenUpdatePromise = (async () => {
            try {
                const browser = await chromium.launch({ headless: false });
                const context = await browser.newContext({ userAgent: this.userAgentWeb });
                await context.addCookies(this.identificationCookie);

                const page = await context.newPage();
                await page.goto('https://bot-t.com/lk/common/replenishment/main/statistics?bot_id=25624', {
                    waitUntil: 'networkidle',
                    timeout: 30000,
                });

                await page.waitForSelector('div.card-header:has-text("Топ 20 пользователей по сумме за период")', { timeout: 15000 });

                const html = await page.content();
                this.csrfToken = extractCsrf(html);

                const cookieContext = await context.cookies();
                this.cookie = cookieContext.map((c: Cookie) => `${c.name}=${c.value}`).join('; ');

                await browser.close();
                this.logger.log('Токены Bot-T обновлены успешно');
            } catch (error: any) {
                this.logger.error('Ошибка обновления Cloudflare токена:', error);
                throw new Error(`Ошибка обновления Bot-T токена: ${error.message}`);
            } finally {
                this.isUpdatingToken = false;
                this.tokenUpdatePromise = null;
            }
        })();
        return this.tokenUpdatePromise;
    }
}

```

src/module/bott/decorators/wrap-with-loading.decorator.ts:
```
export function WrapWithLoading() {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;

        if (typeof originalMethod !== 'function') {
            throw new TypeError(
                `Декоратор @WrapWithLoading может быть применен только к методам, не к ${typeof originalMethod} '${propertyKey}'.`,
            );
        }

        descriptor.value = async function (...args: any[]) {
            if (typeof (this as any).wrapperFuncLoading !== 'function') {
                throw new Error(
                    `Метод 'wrapperFuncLoading' не определен или это не функция на инстансе для '${propertyKey}'. Проверь BottService класс.`,
                );
            }
            return (this as any).wrapperFuncLoading(() => originalMethod.apply(this, args));
        };

        return descriptor;
    };
}

```

src/module/bott/interfaces/bot-t.interface.ts:
```
export interface ISearchByTelegramId {
    results: Result[];
}

export interface Result {
    id: string;
    text: string;
}

export type Html = string;

```

src/module/bott/interfaces/replenishment-bot-t.interface.ts:
```
export interface IReplenishmentUsersBotT {
    result: boolean;
    data: Datum[];
}

export interface Datum {
    id: number;
    bot_id: number;
    user: User;
    is_positive: boolean;
    status: number;
    item_id?: number;
    itemData: string;
    balanceType: BalanceType;
    amount: number;
    created_at: number;
    created_time: string;
    comment: string;
}

export interface BalanceType {
    id: number;
    title: string;
    image?: string;
}

export interface User {
    id: number;
    telegram_id: number;
    username: string;
    first_name: string;
    last_name: string;
    link: string;
    type: string;
}

```

src/module/cache/cache.keys.ts:
```
export const getCouponPageKey = (page: string | number) => {
    return `bott:getCouponPage:${page}`;
};

```

src/module/coupon/coupon.module.ts:
```
import { Module } from '@nestjs/common';
import { FortuneCouponService } from './fortune-coupon.service';
import { FortuneCouponRepository } from './forune-coupon.repository';
import { BottModule } from '../bott/bott.module';

@Module({
    imports: [BottModule],
    exports: [FortuneCouponService],
    providers: [FortuneCouponService, FortuneCouponRepository],
})
export class CouponModule {}

```

src/module/coupon/fortune-coupon.service.ts:
```
import { BadRequestException, Injectable, Logger, NotFoundException } from '@nestjs/common';
import { FortuneCouponRepository } from './forune-coupon.repository';
import { FortuneCoupon, FortuneSurpriseType } from '@prisma/client';
import { Prize } from './interfaces/fortune.interface';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';
import { BottService } from '../bott/bott.service';
import { extractCsrf, extractUsersStatistics } from '../telegram/utils/payment.utils';
import { ConfigService } from '@nestjs/config';
import { SenderTelegram } from '../telegram/interfaces/telegram.context';

dayjs.extend(utc);
dayjs.extend(timezone);

@Injectable()
export class FortuneCouponService {
    private readonly logger = new Logger(FortuneCouponService.name);

    private readonly prizes: Prize[] = [
        // { name: 'Купон на счет 200р. Активация в Спортивном боте', chance: 7, code: 'Replenish_200' },
        // { name: 'Купон на счет 500р. Активация в Спортивном боте', chance: 5, code: 'Replenish_500' },
        { name: 'Купон на счет 10р. Активация в Спортивном боте', chance: 30, code: 'Replenish_10' },
        // { name: 'Купон на счет 100р. Активация в Спортивном боте', chance: 23, code: 'Replenish_100' },
        { name: 'Пополнение 5%. Активация в профиле при пополнении', chance: 5, code: 'Payment_5' },
        // { name: 'Пополнение 25%. Активация в профиле при пополнении', chance: 3, code: 'Payment_25' },
        // { name: 'Пополнение 30%. Активация в профиле при пополнении', chance: 3, code: 'Payment_30' },
        { name: 'Пополнение 10%. Активация в профиле при пополнении', chance: 5, code: 'Payment_10' },
        // { name: 'Скидка 25%. Активация в Спортивном боте', chance: 13, code: 'Discount_25' },
        { name: 'Скидка 5%. Активация в Спортивном боте', chance: 60, code: 'Discount_5' },
        // { name: 'Скидка 30%. Активация в Спортивном боте', chance: 11, code: 'Discount_30' },
        // { name: 'Скидка 30%. Активация в Спортивном боте', chance: 16, code: 'Discount_30' },
        // { name: 'Скидка 50%. Активация в Спортивном боте', chance: 8, code: 'Discount_50' },
    ];

    // private readonly smallPrizes: Prize[] = [
    //     { name: 'Пополнение 25%. Активация в профиле при пополнении', chance: 8, code: 'Payment_25' },
    //     { name: 'Пополнение 30%. Активация в профиле при пополнении', chance: 5, code: 'Payment_30' },
    //     { name: 'Скидка 10%. Активация в Спортивном боте', chance: 35, code: 'Discount_10' },
    //     { name: 'Скидка 15%. Активация в Спортивном боте', chance: 26, code: 'Discount_15' },
    //     { name: 'Скидка 20%. Активация в Спортивном боте', chance: 26, code: 'Discount_20' },
    // ];

    private tgNamesExceptionStatistic = this.configService.getOrThrow<string>('TELEGRAM_NAMES_EXCEPTION_STATISTIC').split(',');

    constructor(
        private readonly couponRepository: FortuneCouponRepository,
        private readonly bottService: BottService,
        private configService: ConfigService,
    ) {}

    getRandomPrize(sender: SenderTelegram): Prize {
        return this.getRandomPrizeFromPool(this.prizes);
        // try {
        //     // const userPosition = await this.getUserPositionInStatistics(sender);
        //
        //     // if (userPosition > 15) {
        //     //     return this.getRandomPrizeFromPool(this.smallPrizes);
        //     // }
        //
        //     return this.getRandomPrizeFromPool(this.prizes);
        // } catch (error) {
        //     this.logger.error('Ошибка при получении позиции пользователя:', error);
        //     // return this.getRandomPrizeFromPool(this.smallPrizes);
        // }
    }

    private async getUserPositionInStatistics(sender: SenderTelegram): Promise<number> {
        try {
            const responseStatistics = await this.bottService.getStatistics();

            const usersStatistic = extractUsersStatistics(responseStatistics, this.tgNamesExceptionStatistic);

            const userStat = usersStatistic.find(user => user.name === sender.username || user.name === `@${sender.username}`);

            return userStat ? userStat.row : 999;
        } catch (error) {
            this.logger.error('Ошибка при получении позиции пользователя:', error);
            return 999;
        }
    }

    private getRandomPrizeFromPool(prizePool: Prize[]): Prize {
        const random = Math.random() * 100;
        let cumulative = 0;

        for (const prize of prizePool) {
            cumulative += prize.chance;
            if (random < cumulative) {
                return prize;
            }
        }

        return prizePool[prizePool.length - 1];
    }

    async getPrizeForToday(telegramId: string): Promise<FortuneCoupon | null> {
        return this.couponRepository.getPrizeForToday(telegramId);
    }

    private generateCouponCode(): string {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = '';
        for (let i = 0; i < 8; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    async awardPrizeToUser(prize: Prize, telegramId: string): Promise<FortuneCoupon> {
        const generatedCode = this.generateCouponCode();
        const expiresAt = dayjs().tz('Europe/Moscow').set('hour', 23).set('minute', 59).set('second', 59).set('millisecond', 999).toDate();

        let type: FortuneSurpriseType;
        let value: number;
        if (prize.code.startsWith('Replenish')) {
            type = FortuneSurpriseType.Replenish;
            value = parseInt(prize.code.split('_')[1], 10);
        } else if (prize.code.startsWith('Payment')) {
            type = FortuneSurpriseType.Payment;
            value = parseInt(prize.code.split('_')[1], 10);
        } else if (prize.code.startsWith('Discount')) {
            type = FortuneSurpriseType.Discount;
            value = parseInt(prize.code.split('_')[1], 10);
        } else {
            throw new NotFoundException('Неизвестный тип приза');
        }

        if (type === FortuneSurpriseType.Replenish) {
            const responseStatistics = await this.bottService.getStatistics();
            const csrfToken = extractCsrf(responseStatistics);
            const activateAt = dayjs(expiresAt).format('YYYY-MM-DDTHH:mm');
            const promoStatus = await this.bottService.createReplenishPromocode(csrfToken, generatedCode, value, 1, activateAt);
            if (promoStatus !== 302 && promoStatus !== 200) {
                throw new BadRequestException('Не удалось создать промокод для начисления');
            }
            return this.couponRepository.createCoupon({
                coupon: generatedCode,
                type: type,
                value: value,
                isActive: true,
                expiresAt: expiresAt,
                usageCount: 0,
                maxUsage: 1,
                description: prize.name,
                owner: telegramId,
            });
        } else if (type === FortuneSurpriseType.Discount) {
            const responseStatistics = await this.bottService.getStatistics();
            const csrfToken = extractCsrf(responseStatistics);
            const activateAt = dayjs(expiresAt).format('YYYY-MM-DDTHH:mm');
            const promoStatus = await this.bottService.createPromocode(csrfToken, generatedCode, value, 1, activateAt);
            if (promoStatus !== 200) {
                throw new BadRequestException('Не удалось создать промокод для скидки');
            }
            return this.couponRepository.createCoupon({
                coupon: generatedCode,
                type: type,
                value: value,
                isActive: true,
                expiresAt: expiresAt,
                usageCount: 0,
                maxUsage: 1,
                description: prize.name,
                owner: telegramId,
            });
        } else {
            return this.couponRepository.createCoupon({
                coupon: generatedCode,
                type: type,
                value: value,
                isActive: true,
                expiresAt: expiresAt,
                usageCount: 0,
                maxUsage: 1,
                description: prize.name,
                owner: telegramId,
            });
        }
    }

    async validateAndRedeemCoupon(couponCode: string, telegramId: string) {
        const coupon = await this.couponRepository.getCouponByCode(couponCode);
        if (!coupon) {
            throw new NotFoundException('Купон не найден');
        }
        if (coupon.type !== FortuneSurpriseType.Payment) {
            throw new BadRequestException('Купон не для пополнения');
        }
        if (!coupon.isActive) {
            throw new BadRequestException('Купон уже использован или не активен');
        }
        if (coupon.expiresAt < new Date()) {
            throw new BadRequestException('Купон просрочен');
        }
        if (coupon.owner && coupon.owner !== telegramId) {
            throw new BadRequestException('Купон не принадлежит этому пользователю');
        }
        return await this.couponRepository.redeemCoupon(couponCode);
    }

    async restoreCoupon(couponId: string): Promise<FortuneCoupon> {
        return this.couponRepository.restoreCoupon(couponId);
    }
}

```

src/module/coupon/forune-coupon.repository.ts:
```
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { FortuneCoupon, FortuneSurpriseType } from '@prisma/client';

@Injectable()
export class FortuneCouponRepository {
    constructor(private readonly prisma: PrismaService) {}

    async getCouponByCode(coupon: string): Promise<FortuneCoupon | null> {
        return this.prisma.fortuneCoupon.findUnique({
            where: { coupon },
        });
    }

    async redeemCoupon(couponId: string): Promise<FortuneCoupon> {
        const coupon = await this.getCouponByCode(couponId);
        if (!coupon) {
            throw new NotFoundException('Купон не найден');
        }
        const newUsageCount = coupon.usageCount + 1;
        const updateData: any = { usageCount: newUsageCount };
        if (newUsageCount >= coupon.maxUsage) {
            updateData.isActive = false;
            updateData.redeemedAt = new Date();
        }
        return this.prisma.fortuneCoupon.update({
            where: { id: coupon.id },
            data: updateData,
        });
    }

    async restoreCoupon(couponId: string): Promise<FortuneCoupon> {
        return this.prisma.fortuneCoupon.update({
            where: { id: couponId },
            data: {
                isActive: true,
                usageCount: { decrement: 1 },
                updatedAt: new Date(),
            },
        });
    }

    async getPrizeForToday(telegramId: string): Promise<FortuneCoupon | null> {
        const startOfToday = new Date();
        startOfToday.setHours(0, 0, 0, 0);
        return this.prisma.fortuneCoupon.findFirst({
            where: {
                owner: telegramId,
                createdAt: { gte: startOfToday },
            },
        });
    }

    async createCoupon(data: {
        coupon: string;
        type: FortuneSurpriseType;
        value: number;
        isActive: boolean;
        expiresAt: Date;
        usageCount?: number;
        maxUsage?: number;
        description?: string;
        owner: string;
    }): Promise<FortuneCoupon> {
        return this.prisma.fortuneCoupon.create({
            data: {
                coupon: data.coupon,
                type: data.type,
                value: data.value,
                isActive: data.isActive,
                expiresAt: data.expiresAt,
                usageCount: data.usageCount ?? 0,
                maxUsage: data.maxUsage ?? 1,
                description: data.description,
                owner: data.owner,
            },
        });
    }
}

```

src/module/coupon/interfaces/fortune.interface.ts:
```
export interface Prize {
    name: string;
    chance: number;
    code: string;
}

```

src/module/cron/cron.module.ts:
```
import { Module } from '@nestjs/common';
import { CronService } from './cron.service';
import { AccountModule } from '../account/account.module';

@Module({
    imports: [AccountModule],
    providers: [CronService],
})
export class CronModule {}

```

src/module/cron/cron.service.ts:
```
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from '../account/account.service';
import { CourseStatus, Lesson, LessonStatus } from '@prisma/client';
import { CourseService } from '../account/course.service';
import { IWatchLesson } from '../account/interfaces/course.interface';
import { Cron } from '@nestjs/schedule';

@Injectable()
export class CronService {
    private readonly logger = new Logger(CronService.name);

    private isRunning = false;

    constructor(
        private accountService: AccountService,
        private courseService: CourseService,
    ) {}

    @Cron('*/2 * * * *')
    async processLessons(): Promise<void> {
        if (this.isRunning) {
            return;
        }
        this.isRunning = true;
        try {
            const accounts = await this.accountService.getActiveCourseAccount();
            if (accounts.length === 0) return;

            accountsLoop: for (const accountId of accounts) {
                this.logger.log('In accountsLoop by', accountId);
                const accountActiveCourses = await this.courseService.getCoursesByAccountAndStatus(accountId, CourseStatus.ACTIVE);

                //здесь проверка, все курсы просмотрены, но нет статуса финиш аккаунт (после синхрона)
                const allCoursesFinished = accountActiveCourses.every(course => course.status === CourseStatus.FINISHED);
                if (allCoursesFinished) {
                    // Помечаем Аккаунт как завершённый
                    await this.accountService.updateStatusAccountCourse(accountId, CourseStatus.FINISHED);
                    continue;
                }

                for (let i = 0; i < accountActiveCourses.length; i++) {
                    const accountCourse = accountActiveCourses[i];
                    const lessonsWithProgress = await this.courseService.getLessonsWithProgressByAccountAndCourse(
                        accountId,
                        accountCourse.courseId,
                    );

                    //здесь проверка, все просмотрено, но нет статуса финиш курса (после синхрона)
                    const allLessonsFinished = lessonsWithProgress.every(lesson =>
                        lesson.AccountLessonProgress.some(progress => progress.status === LessonStatus.VIEWED),
                    );

                    if (allLessonsFinished) {
                        // Помечаем курс как завершённый
                        await this.courseService.changeStatusCourse(accountCourse.accountId, accountCourse.courseId, CourseStatus.FINISHED);
                        continue;
                    }

                    for (let j = 0; j < lessonsWithProgress.length; j++) {
                        const lesson = lessonsWithProgress[j];

                        if (lesson.progress.status === LessonStatus.VIEWED) continue;

                        // Проверяем, наступило ли время для просмотра лекции
                        if (!lesson.progress.nextViewAt || new Date(lesson.progress.nextViewAt).toISOString() <= new Date().toISOString()) {
                            const accountId = lesson.progress.accountId;
                            const progressId = lesson.progress.progressId;

                            let mnemocode = this.courseService.getMnemocode(accountCourse.courseId);
                            if (!mnemocode) {
                                await this.courseService.initializeCache();
                                mnemocode = this.courseService.getMnemocode(accountCourse.courseId);
                            }
                            const lessonView = this.mapLesson(lesson, mnemocode!);

                            try {
                                const isWatched = await this.viewLesson(lessonView, progressId, accountId);
                                if (!isWatched) continue accountsLoop;
                                lesson.progress.status = LessonStatus.VIEWED;
                                this.logger.log('просмотрел', lessonView.mnemocode, lesson.position);
                            } catch (err: any) {
                                await this.accountService.promblemCourses(accountCourse.accountId);
                                this.logger.error('Проблема с курсом isWatched', accountCourse.accountId);
                            }

                            // Если это последняя лекция в курсе
                            if (j === lessonsWithProgress.length - 1) {
                                // Помечаем курс как завершённый
                                const allLessonsFinished = lessonsWithProgress.every(lesson =>
                                    lesson.AccountLessonProgress.some(progress => progress.status === LessonStatus.VIEWED),
                                );

                                if (allLessonsFinished) {
                                    // Помечаем курс как завершённый
                                    await this.courseService.changeStatusCourse(
                                        accountCourse.accountId,
                                        accountCourse.courseId,
                                        CourseStatus.FINISHED,
                                    );
                                }

                                // Если есть следующий курс, разблокируем первую лекцию
                                if (i < accountActiveCourses.length - 1) {
                                    const nextCourse = accountActiveCourses[i + 1];
                                    const lessonsWithProgressNextCourse = await this.courseService.getLessonsWithProgressByAccountAndCourse(
                                        accountId,
                                        nextCourse.courseId,
                                    );
                                    const firstLessonProgress = lessonsWithProgressNextCourse[0];
                                    if (firstLessonProgress) {
                                        const timeUnblock = this.getTimeUnblock(firstLessonProgress.duration);
                                        await this.courseService.updateUnblockLesson(firstLessonProgress.progress.progressId, timeUnblock);
                                        //переход к другому акку
                                    }
                                } else {
                                    //аккаунт FINISHED
                                    await this.accountService.updateStatusAccountCourse(accountId, CourseStatus.FINISHED);
                                }
                                continue accountsLoop;
                            } else {
                                // Если не последняя лекция, разблокируем следующую
                                const nextLesson = lessonsWithProgress[j + 1];

                                const timeUnblock = this.getTimeUnblock(nextLesson.duration);
                                await this.courseService.updateUnblockLesson(nextLesson.progress.progressId, timeUnblock);
                                continue accountsLoop;
                            }
                        } else {
                            continue accountsLoop;
                        }
                    }
                }
            }
        } catch (err: any) {
            this.logger.error(err);
        } finally {
            this.isRunning = false;
        }
    }

    async viewLesson(lesson: IWatchLesson, progressId: number, accountId: string): Promise<boolean> {
        const timeout = new Promise<boolean>((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000));

        const isWatchingPromise = this.accountService.watchingLesson(lesson, accountId);

        let isWatching: boolean;
        try {
            isWatching = await Promise.race([isWatchingPromise, timeout]);
        } catch (error) {
            this.logger.error('ОШИБКА В ПРОСМОТРЕ', accountId, error);
            isWatching = false;
        }

        if (isWatching) {
            await this.courseService.updateViewLesson(progressId, LessonStatus.VIEWED);
        } else {
            const plusTimeUnblock = this.getTimeUnblock(400);
            await this.courseService.updateUnblockLesson(progressId, plusTimeUnblock);
        }

        return isWatching;
    }

    private getTimeUnblock(duration: number) {
        return new Date(Date.now() + (duration / 2) * 1000);
    }

    private mapLesson(lesson: Lesson, mnemocode: string): IWatchLesson {
        return {
            mnemocode,
            videoId: lesson.videoId,
            lessonId: lesson.lessonId,
            duration: lesson.duration,
        };
    }
}

```

src/module/http/http.module.ts:
```
import { Module } from '@nestjs/common';
import { HttpService } from './http.service';
import { TlsProxyService } from './tls-forwarder.service';

@Module({
    providers: [HttpService, TlsProxyService],
    exports: [HttpService, TlsProxyService],
})
export class HttpModule {}

```

src/module/http/http.service.ts:
```
import axios, { AxiosResponse } from 'axios';
import { Injectable, Logger } from '@nestjs/common';
import { IHttpInterface } from './interfaces/http.interface';

@Injectable()
export class HttpService implements IHttpInterface {
    private readonly logger = new Logger(HttpService.name);
    private timeout = 10000;

    constructor() {}

    async get<T = any>(url: string, options: any = {}): Promise<AxiosResponse<T>> {
        try {
            return axios.get<T>(url, { timeout: this.timeout, ...options });
        } catch (error: any) {
            this.logger.error(`HTTP GET error on url ${url}:`, error.message);
            throw error;
        }
    }

    async post<T = any>(url: string, payload: any, options: any = {}): Promise<AxiosResponse<T>> {
        try {
            return axios.post<T>(url, payload, { timeout: this.timeout, ...options });
        } catch (error: any) {
            this.logger.error(`HTTP POST error on url ${url}:`, error.message);
            throw error;
        }
    }

    async delete<T = any>(url: string, options: any = {}): Promise<AxiosResponse<T>> {
        try {
            return axios.delete<T>(url, { timeout: this.timeout, ...options });
        } catch (error: any) {
            this.logger.error(`HTTP DELETE error on url ${url}:`, error.message);
            throw error;
        }
    }
}

```

src/module/http/tls-forwarder.service.ts:
```
import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from './http.service';
import { randomUUID } from 'crypto';
import { ConfigService } from '@nestjs/config'; // ИЗМЕНЕНИЕ 1: Импортируем ConfigService

interface TlsForwardPayload {
    sessionId: string;
    tlsClientIdentifier: string;
    followRedirects: boolean;
    insecureSkipVerify: boolean;
    timeoutSeconds: number;
    proxyUrl?: string;
    headers: Record<string, string>;
    requestUrl: string;
    requestMethod: 'GET' | 'POST' | 'PUT' | 'DELETE';
    requestBody: string;
}

@Injectable()
export class TlsProxyService {
    private readonly logger = new Logger(TlsProxyService.name);
    private readonly tlsApiUrl: string;
    private readonly tlsApiKey: string;
    private readonly tlsClientIdentifier: string;

    constructor(
        private readonly httpService: HttpService,
        private readonly configService: ConfigService,
    ) {
        this.tlsApiUrl = this.configService.getOrThrow<string>('TLS_FORWARDER_URL');
        this.tlsApiKey = this.configService.getOrThrow<string>('TLS_FORWARDER_API_KEY');
        this.tlsClientIdentifier = this.configService.getOrThrow<string>('TLS_CLIENT_IDENTIFIER');
    }

    async forwardRequest<T = any>(params: {
        requestUrl: string;
        requestMethod: TlsForwardPayload['requestMethod'];
        headers: Record<string, string>;
        headerOrder?: string[];
        requestBody: object;
        proxyUrl?: string;
    }): Promise<T> {
        this.logger.log(`Forwarding request to ${params.requestUrl} via TLS proxy`);

        const payload: TlsForwardPayload = {
            sessionId: `sm_${Date.now()}_${randomUUID()}`,
            tlsClientIdentifier: this.tlsClientIdentifier,
            followRedirects: false,
            insecureSkipVerify: false,
            timeoutSeconds: 60,
            proxyUrl: params.proxyUrl || '',
            headers: params.headers,
            requestUrl: params.requestUrl,
            requestMethod: params.requestMethod,
            requestBody: JSON.stringify(params.requestBody),
        };

        try {
            const response = await this.httpService.post(this.tlsApiUrl, payload, {
                headers: {
                    'x-api-key': this.tlsApiKey,
                },
            });

            if (response.data && response.data.body) {
                if (typeof response.data.body === 'string' && response.data.headers['Content-Type']?.includes('application/json')) {
                    return JSON.parse(response.data.body);
                }
                return response.data.body;
            }

            if (response.data && response.data.status >= 400) {
                this.logger.error('TLS Proxy returned an error status:', response.data.status, response.data.body);
                throw new Error(`TLS Proxy forward error: ${response.data.body}`);
            }

            throw new Error('Invalid response structure from TLS proxy');
        } catch (error: any) {
            this.logger.error(`Error forwarding request to ${params.requestUrl}:`, error.message);
            if (error.response?.data) {
                this.logger.error('TLS Proxy Error Response:', error.response.data);
            }
            throw error;
        }
    }
}

```

src/module/http/interfaces/http.interface.ts:
```
import { ISportmasterRequestHeaders } from '../../account/interfaces/headers.interface';
import { SocksProxyAgent } from 'socks-proxy-agent';

export interface IHttpInterface {
    post: (url: string, payload: any, httpOptions: HttpOptions) => Promise<any>;
    get: (url: string, httpOptions: HttpOptions) => Promise<any>;
    delete: (url: string, httpOptions: HttpOptions) => Promise<any>;
    // patch: () => any;
}

export interface HttpOptions {
    headers: ISportmasterRequestHeaders;
    httpsAgent: SocksProxyAgent;
}

```

src/module/logger/index.ts:
```
export * from './pino.service';
export * from './strategies';

```

src/module/logger/pino.service.ts:
```
import { LoggerService } from '@nestjs/common';
import koffi from 'koffi';
import pino from 'pino';

export class PinoService implements LoggerService {
    private readonly pino: pino.Logger;

    constructor(strategy: pino.LoggerOptions | pino.Logger) {
        if (process.platform === 'win32') {
            const CP_UTF8 = 65001;
            const kernel32 = koffi.load('Kernel32');
            const setConsoleOutputCP = kernel32.func('SetConsoleOutputCP', 'bool', ['int']);
            const setConsoleCP = kernel32.func('SetConsoleCP', 'bool', ['int']);
            setConsoleOutputCP(CP_UTF8);
            setConsoleCP(CP_UTF8);
        }
        this.pino = pino(strategy);
    }

    public log(message: string, context: string): void {
        this.pino.info({ message, context });
    }

    public error(messageOrError: string | Error, context: string): void {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let message: string | Record<string, any> = messageOrError;

        if (messageOrError instanceof Error) {
            message = {
                message: messageOrError.message,
                stack: messageOrError.stack,
            };
        }

        this.pino.error({ message, context });
    }

    public warn(message: string, context: string): void {
        this.pino.warn({ message, context });
    }

    public debug(message: string, context: string): void {
        this.pino.debug({ message, context });
    }
}

```

src/module/logger/strategies/base.strategy.ts:
```
import { LoggerOptions } from 'pino';

export const BASE_STRATEGY: LoggerOptions = {
    messageKey: 'message',
    errorKey: 'message',
    timestamp: false,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializers: { err: (value: any) => value },
    formatters: {
        level: level => {
            return { level: level.toLocaleUpperCase() };
        },
    },
    mixin: () => {
        return { timestamp: new Date().toISOString() };
    },
};

```

src/module/logger/strategies/development.strategy.ts:
```
import pino from 'pino';
import { BASE_STRATEGY } from './base.strategy';

export const DEVELOPMENT_STRATEGY: pino.LoggerOptions = {
    ...BASE_STRATEGY,
    formatters: {
        ...BASE_STRATEGY.formatters,
        bindings: () => ({}),
    },
    transport: {
        target: 'pino-pretty',
        options: {
            colorize: true,
            timestampKey: 'timestamp',
            messageKey: 'message',
        },
    },
};

```

src/module/logger/strategies/index.ts:
```
export * from './development.strategy';
export * from './base.strategy';
export * from './production.strategy';

```

src/module/logger/strategies/production.strategy.ts:
```
import { LoggerOptions } from 'pino';
import { BASE_STRATEGY } from './base.strategy';
import { APP_VERSION } from '../../../app.constants';

export const PRODUCTION_STRATEGY: LoggerOptions = {
    ...BASE_STRATEGY,
    formatters: {
        ...BASE_STRATEGY.formatters,
        bindings: () => ({ appVersion: APP_VERSION }),
    },
};

```

src/module/mirror/mirror.controller.ts:
```
import { BadRequestException, Controller, Get, Query, Req, Res } from '@nestjs/common';
import { Request, Response } from 'express';
import { MirrorService } from './mirror.service';

@Controller('mirror')
export class MirrorController {
    constructor(private mirrorService: MirrorService) {}

    @Get('auth')
    async accessMirror(@Query('token') mirrorToken: string, @Res({ passthrough: true }) res: Response, @Req() request: Request) {
        if (!mirrorToken) {
            throw new BadRequestException('Неверный запрос');
        }
        const mirrorEntry = await this.mirrorService.validateMirrorToken(mirrorToken);
        const ipAddress = Array.isArray(request.headers['x-forwarded-for'])
            ? request.headers['x-forwarded-for'][0]
            : request.headers['x-forwarded-for'] || request.ip;

        if (!ipAddress || mirrorEntry.userIp !== ipAddress) {
            throw new BadRequestException('Неверный запрос');
        }

        const { jwtToken, smid, domain, expiry } = await this.mirrorService.createJwt(mirrorEntry);
        res.clearCookie('SMID');
        res.clearCookie('jwt');

        const twoYearsFromNow = new Date();
        twoYearsFromNow.setFullYear(twoYearsFromNow.getFullYear() + 2);

        res.cookie('SMID', smid, {
            domain,
            httpOnly: true,
            path: '/',
            sameSite: 'lax',
            secure: true,
            expires: twoYearsFromNow,
        });

        res.cookie('jwt', jwtToken, {
            domain,
            httpOnly: true,
            path: '/',
            sameSite: 'lax',
            secure: true,
            expires: expiry,
        });

        return res.redirect('/');
    }
}

```

src/module/mirror/mirror.module.ts:
```
import { Module } from '@nestjs/common';
import { MirrorController } from './mirror.controller';
import { AccountModule } from '../account/account.module';
import { JwtService } from '@nestjs/jwt';
import { MirrorService } from './mirror.service';
import { MirrorRepository } from './mirror.repository';
import { ConfigService } from '@nestjs/config';

@Module({
    imports: [AccountModule],
    controllers: [MirrorController],
    providers: [JwtService, MirrorService, MirrorRepository, ConfigService],
    exports: [MirrorService, JwtService, ConfigService],
})
export class MirrorModule {}

```

src/module/mirror/mirror.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { AccountMirror } from '@prisma/client';

@Injectable()
export class MirrorRepository {
    constructor(private readonly prisma: PrismaService) {}

    async createAccountMirror(telegramId: string, telegramName: string): Promise<AccountMirror> {
        return this.prisma.accountMirror.create({
            data: {
                telegramId,
                telegramName,
            },
        });
    }
    async updateAccountMirror(id: string, data: Partial<AccountMirror>): Promise<AccountMirror | null> {
        return this.prisma.accountMirror.update({
            where: { id },
            data,
        });
    }

    async findAccountMirrorByMirrorToken(mirrorToken: string): Promise<AccountMirror | null> {
        return this.prisma.accountMirror.findUnique({
            where: { mirrorToken },
        });
    }
}

```

src/module/mirror/mirror.service.ts:
```
import { BadRequestException, Injectable } from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { AccountMirror } from '@prisma/client';
import { AccountService } from '../account/account.service';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { MirrorRepository } from './mirror.repository';

interface JwtPayload {
    smid: string;
    ip: string;
    exp: number;
}

@Injectable()
export class MirrorService {
    private hash = this.configService.getOrThrow('ZENNO_HASH');
    private domain = this.configService.getOrThrow('DOMAIN').split('://')[1];

    constructor(
        private readonly mirrorRepository: MirrorRepository,
        private readonly accountService: AccountService,
        private readonly jwtService: JwtService,
        private configService: ConfigService,
    ) {}

    async createAccountMirror(telegramId: string, telegramName: string): Promise<AccountMirror> {
        return this.mirrorRepository.createAccountMirror(telegramId, telegramName);
    }

    async updateAccountMirror(id: string, data: Partial<AccountMirror>): Promise<AccountMirror | null> {
        return this.mirrorRepository.updateAccountMirror(id, data);
    }

    async findAccountMirrorByMirrorToken(mirrorToken: string): Promise<AccountMirror | null> {
        return this.mirrorRepository.findAccountMirrorByMirrorToken(mirrorToken);
    }

    async generateMirrorToken(id: string): Promise<{ mirrorToken: string; mirrorTokenExpiry: Date }> {
        const mirrorToken = uuidv4();
        const mirrorTokenExpiry = new Date(Date.now() + 60 * 60 * 1000);
        await this.updateAccountMirror(id, { mirrorToken, mirrorTokenExpiry });
        return { mirrorToken, mirrorTokenExpiry };
    }

    async validateMirrorToken(mirrorToken: string): Promise<AccountMirror> {
        const mirrorEntry = await this.findAccountMirrorByMirrorToken(mirrorToken);
        if (!mirrorEntry || !mirrorEntry.accountId) {
            throw new BadRequestException('Неверный токен');
        }
        if (!mirrorEntry.mirrorTokenExpiry || mirrorEntry.mirrorTokenExpiry < new Date()) {
            throw new BadRequestException('Время действия ссылки истекло');
        }
        return mirrorEntry;
    }

    async createJwt(mirrorEntry: AccountMirror): Promise<{ jwtToken: string; smid: string; domain: string; expiry: Date }> {
        if (!mirrorEntry.accountId) {
            throw new BadRequestException('Нет id');
        }

        if (!mirrorEntry.mirrorTokenExpiry) {
            throw new BadRequestException('Нет токена');
        }
        if (!mirrorEntry.userIp) {
            throw new BadRequestException('Неверный запрос');
        }

        const accountEntity = await this.accountService.getAccount(mirrorEntry.accountId);
        const cookies: any[] = JSON.parse(accountEntity.cookie);

        const smidCookie = cookies.find(cookie => cookie.name === 'SMID');
        if (!smidCookie) {
            throw new BadRequestException('Cookie SMID не найден.');
        }
        const smid = smidCookie.value;
        const shortSmid = smid.slice(-50);
        const payload: JwtPayload = {
            smid: shortSmid,
            ip: mirrorEntry.userIp,
            exp: Math.floor(mirrorEntry.mirrorTokenExpiry.getTime() / 1000),
        };
        const jwtToken = await this.jwtService.signAsync(payload, { secret: this.hash });
        return { jwtToken, smid: smid, domain: this.domain, expiry: mirrorEntry.mirrorTokenExpiry };
    }
}

```

src/module/order/order.controller.ts:
```
import { Controller, Get, Param, Render } from '@nestjs/common';
import { OrderParamsDto } from './dto/get-order-page.dto';
import { OrderService } from './order.service';

@Controller('order')
export class OrderController {
    constructor(private orderService: OrderService) {}

    @Get(':accountId/:orderNumber')
    @Render('order')
    async getOrder(@Param() params: OrderParamsDto): Promise<any> {
        const resp = await this.orderService.getOrder(params.accountId, params.orderNumber);
        return { order: resp.data.order };
    }
}

```

src/module/order/order.module.ts:
```
import { Module } from '@nestjs/common';
import { OrderController } from './order.controller';
import { OrderService } from './order.service';
import { AccountModule } from '../account/account.module';
import { ProxyModule } from '../proxy/proxy.module';

@Module({
    controllers: [OrderController],
    providers: [OrderService],
    imports: [AccountModule, ProxyModule],
})
export class OrderModule {}

```

src/module/order/order.service.ts:
```
import { Injectable } from '@nestjs/common';
import { AccountService } from '../account/account.service';

@Injectable()
export class OrderService {
    constructor(private accountService: AccountService) {}

    async getOrder(accountId: string, orderNumber: string) {
        return await this.accountService.orderInfo(accountId, orderNumber);
    }
}

```

src/module/order/dto/get-order-page.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

export const OrderParamsSchema = z.object({
    accountId: z.string().uuid(),
    orderNumber: z.string().regex(/^\d{7,9}-\d{6}$/, { message: 'Invalid numberOrder format' }),
});

export namespace GetOrderCommand {
    export const RequestSchema = OrderParamsSchema;
    export type Request = z.infer<typeof RequestSchema>;
}

export class OrderParamsDto extends createZodDto(GetOrderCommand.RequestSchema) {}

```

src/module/payment/payment.controller.ts:
```
import { Body, Controller, Get, HttpCode, Param, Patch, Query } from '@nestjs/common';
import { HasZenno } from '@common/decorators/zenno.decorator';
import { AccountIdParamsDto } from '../account/dto/uuid-account.dto';
import { PaymentService } from './payment.service';
import { StatusRequestDto } from './dto/updateStatus.dto';
import { GetPaymentOrdersQueryDto } from './dto/queryFilter.dto';
import { PaymentStatsQueryDto } from './dto/stats.query.dto';

@Controller('payment')
export class PaymentController {
    constructor(private paymentService: PaymentService) {}

    @HasZenno()
    @Get()
    @HttpCode(200)
    async getPaymentOrders(@Query() query: GetPaymentOrdersQueryDto) {
        return this.paymentService.getPaymentOrders({ page: query.page, limit: query.limit }, { status: query.status });
    }

    @HasZenno()
    @Patch(':accountId')
    @HttpCode(200)
    async updatePaymentOrder(@Body() dto: StatusRequestDto, @Param() params: AccountIdParamsDto) {
        await this.paymentService.updatePaymentOrderStatus(params.accountId, dto.status);
        return await this.paymentService.getPaymentOrders({ page: undefined, limit: undefined }, { status: undefined });
    }

    @HasZenno()
    @Get('stats')
    @HttpCode(200)
    async getStats(@Query() q: PaymentStatsQueryDto) {
        return this.paymentService.getPaymentStats({
            dayFrom: q.dayFrom,
            dayTo: q.dayTo,
            monthFrom: q.monthFrom,
            monthTo: q.monthTo,
            status: q.status,
        });
    }
}

```

src/module/payment/payment.module.ts:
```
import { Module } from '@nestjs/common';
import { PaymentController } from './payment.controller';
import { PaymentService } from './payment.service';
import { PaymentRepository } from './payment.repository';
import { HttpModule } from '../http/http.module';
import { BottModule } from '../bott/bott.module';
import { CouponModule } from '../coupon/coupon.module';

@Module({
    controllers: [PaymentController],
    providers: [PaymentService, PaymentRepository],
    exports: [PaymentService],
    imports: [BottModule, HttpModule, CouponModule],
})
export class PaymentModule {}

```

src/module/payment/payment.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { PaymentOrder, PaymentOrderStatusHistory, Prisma, StatusPayment } from '@prisma/client';
import { ConfigService } from '@nestjs/config';
import { FilterStatusPayment, Pagination } from './dto/queryFilter.dto';

type StatsRow = {
    bucket: Date;
    count: number;
    sum_amount: number;
};

@Injectable()
export class PaymentRepository {
    constructor(private prisma: PrismaService) {}

    private statusSQL(status?: StatusPayment) {
        if (status) return Prisma.sql`AND p.status::text = ${status}`;
        return Prisma.sql`AND p.status::text IN (${Prisma.join([StatusPayment.Transfered, StatusPayment.Completed])})`;
    }

    async createPaymentOrder(data: { amount: number; amountCredited: number; userTelegramId: string }): Promise<PaymentOrder> {
        return this.prisma.paymentOrder.create({
            data: {
                amount: data.amount,
                amountCredited: data.amountCredited,
                userTelegramId: data.userTelegramId,
            },
        });
    }

    async getPaymentOrderById(id: string): Promise<PaymentOrder | null> {
        return this.prisma.paymentOrder.findUnique({
            where: { id },
        });
    }

    async updatePaymentOrderStatus(id: string, status: StatusPayment): Promise<PaymentOrder | null> {
        return this.prisma.paymentOrder.update({
            where: { id },
            data: { status },
        });
    }

    async getPaymentOrdersByUserTelegramId(userTelegramId: string): Promise<PaymentOrder[]> {
        return this.prisma.paymentOrder.findMany({
            where: { userTelegramId },
        });
    }

    async completeTransferedPaymentOrder(id: string, receiptUrl: string): Promise<PaymentOrder> {
        return this.prisma.paymentOrder.update({
            where: { id },
            data: {
                status: StatusPayment.Transfered,
                receiptUrl,
            },
        });
    }

    async updatePaymentOrderInformation(id: string, transactionId: number, isPositive: boolean, completedAt: Date): Promise<PaymentOrder> {
        return this.prisma.paymentOrder.update({
            where: { id },
            data: {
                transactionId,
                isPositive,
                completedAt,
            },
        });
    }

    async createPaymentOrderStatusHistory(id: string, status: StatusPayment): Promise<PaymentOrderStatusHistory> {
        return this.prisma.paymentOrderStatusHistory.create({
            data: {
                paymentOrderId: id,
                status,
            },
        });
    }

    async getPaymentOrders(
        pagination: Pagination,
        filters: FilterStatusPayment,
    ): Promise<{
        data: any[];
        meta: { total: number; page: number; limit: number; pages: number };
        sumAmount: number;
    }> {
        const page = Math.max(1, pagination?.page ?? 1);
        const limit = Math.min(200, Math.max(1, pagination?.limit ?? 50));
        const skip = (page - 1) * limit;

        const where: Prisma.PaymentOrderWhereInput = {};
        if (filters?.status) where.status = filters.status;

        const [total, sumAgg, rows] = await this.prisma.$transaction([
            this.prisma.paymentOrder.count({ where }),
            this.prisma.paymentOrder.aggregate({
                where,
                _sum: { amount: true },
            }),
            this.prisma.paymentOrder.findMany({
                where,
                include: {
                    userTelegram: { select: { telegramName: true } },
                    statusHistory: {
                        select: { status: true, changedAt: true },
                        orderBy: { changedAt: 'asc' },
                    },
                },
                orderBy: { createdAt: 'desc' },
                skip,
                take: limit,
            }),
        ]);

        return {
            data: rows,
            meta: {
                total,
                page,
                limit,
                pages: Math.max(1, Math.ceil(total / limit)),
            },
            sumAmount: sumAgg._sum.amount ?? 0,
        };
    }

    async applyCouponToPaymentOrder(paymentId: string, newAmountCredited: number, couponId: string): Promise<PaymentOrder> {
        return this.prisma.paymentOrder.update({
            where: { id: paymentId },
            data: {
                amountCredited: newAmountCredited,
                couponId: couponId,
                couponApplied: true,
                updatedAt: new Date(),
            },
        });
    }

    async getStatsDaily(from: Date, toExclusive: Date, status?: StatusPayment) {
        return this.prisma.$queryRaw<StatsRow[]>(Prisma.sql`
    WITH series AS (
      SELECT gs::date AS bucket
      FROM generate_series(
        date_trunc('day', ${from}::timestamp),
        date_trunc('day', ${toExclusive}::timestamp) - interval '1 day',
        interval '1 day'
      ) AS gs
    ),
    agg AS (
      SELECT date_trunc('day', p.completed_at)::date AS bucket,
             COUNT(*)::int                          AS count,
             COALESCE(SUM(p.amount), 0)             AS sum_amount
      FROM "payment_order" p
      WHERE p.completed_at IS NOT NULL
        AND p.completed_at >= ${from}
        AND p.completed_at <  ${toExclusive}
        ${this.statusSQL(status)}
      GROUP BY 1
    )
    SELECT s.bucket, COALESCE(a.count, 0) AS count, COALESCE(a.sum_amount, 0) AS sum_amount
    FROM series s
    LEFT JOIN agg a ON a.bucket = s.bucket
    ORDER BY s.bucket ASC
  `);
    }

    private async getMonthlyBounds(status?: StatusPayment) {
        const [row] = await this.prisma.$queryRaw<
            Array<{
                min_bucket: Date | null;
                max_bucket: Date | null;
            }>
        >(Prisma.sql`
      SELECT date_trunc('month', MIN(p.completed_at)) AS min_bucket,
             date_trunc('month', MAX(p.completed_at)) AS max_bucket
      FROM "payment_order" p
      WHERE p.completed_at IS NOT NULL
        ${this.statusSQL(status)}
    `);

        const now = new Date();
        if (!row?.min_bucket || !row?.max_bucket) {
            const from = new Date(now);
            from.setMonth(now.getMonth() - 11, 1);
            from.setHours(0, 0, 0, 0);

            const to = new Date(now);
            to.setMonth(now.getMonth() + 1, 1);
            to.setHours(0, 0, 0, 0);

            return { from, to };
        }

        const from = new Date(row.min_bucket);
        const to = new Date(row.max_bucket);
        to.setMonth(to.getMonth() + 1, 1); // правая граница — начало след. месяца
        return { from, to };
    }

    async getStatsMonthly(fromMonthStart: Date, toMonthStartNext: Date, status?: StatusPayment) {
        return this.prisma.$queryRaw<StatsRow[]>(Prisma.sql`
    WITH series AS (
      SELECT date_trunc('month', gs)::date AS bucket
      FROM generate_series(
        date_trunc('month', ${fromMonthStart}::timestamp),
        date_trunc('month', ${toMonthStartNext}::timestamp) - interval '1 month',
        interval '1 month'
      ) AS gs
    ),
    agg AS (
      SELECT date_trunc('month', p.completed_at)::date AS bucket,
             COUNT(*)::int                            AS count,
             COALESCE(SUM(p.amount), 0)               AS sum_amount
      FROM "payment_order" p
      WHERE p.completed_at IS NOT NULL
        AND p.completed_at >= ${fromMonthStart}
        AND p.completed_at <  ${toMonthStartNext}
        ${this.statusSQL(status)}
      GROUP BY 1
    )
    SELECT s.bucket, COALESCE(a.count, 0) AS count, COALESCE(a.sum_amount, 0) AS sum_amount
    FROM series s
    LEFT JOIN agg a ON a.bucket = s.bucket
    ORDER BY s.bucket ASC
  `);
    }

    async getStatsTotals(from: Date, toExclusive: Date, status?: StatusPayment) {
        const [row] = await this.prisma.$queryRaw<Array<{ count: number; sum_amount: number }>>(Prisma.sql`
    SELECT COUNT(*)::int AS count, COALESCE(SUM(p.amount), 0) AS sum_amount
    FROM "payment_order" p
    WHERE p.completed_at IS NOT NULL
      AND p.completed_at >= ${from}
      AND p.completed_at <  ${toExclusive}
      ${this.statusSQL(status)}
  `);
        return row ?? { count: 0, sum_amount: 0 };
    }
}

```

src/module/payment/payment.service.ts:
```
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { PaymentOrderEntity } from './entities/payment.entities';
import { PaymentOrder as PaymentOrderModel } from '.prisma/client';
import { StatusPayment } from '@prisma/client';
import { PaymentRepository } from './payment.repository';
import { BottService } from '../bott/bott.service';
import {
    ERROR_CHANGE_BALANCE,
    ERROR_GET_BOT_ID,
    ERROR_GET_SEARCH_ID,
    ERROR_GET_TRANSACTIONS,
    ERROR_NOT_FOUND_TRANSACTION,
} from './constants/error.constants';
import { extractCsrf, extractUserBotId, extractUsersStatistics, getPromoCodeDetailsFromHtml } from '../telegram/utils/payment.utils';
import { IReplenishmentUsersBotT } from '../bott/interfaces/replenishment-bot-t.interface';
import { UserStatistic } from './interfaces/statistic.interface';
import { ConfigService } from '@nestjs/config';
import { Payment } from './interfaces/payment.interface';
import { FilterStatusPayment, Pagination } from './dto/queryFilter.dto';

@Injectable()
export class PaymentService {
    private tgNamesExceptionStatistic: string[] = this.configService.getOrThrow('TELEGRAM_NAMES_EXCEPTION_STATISTIC').split(',');
    private tgIdVipCoef: string[] = this.configService.getOrThrow('TELEGRAM_ID_VIP_COEF').split(',');
    private domain: string = this.configService.getOrThrow('DOMAIN');

    constructor(
        private paymentRepository: PaymentRepository,
        private bottService: BottService,
        private configService: ConfigService,
    ) {}

    async changeUserBalance(id: string, telegramId: string, amount: number, isPositive: boolean = true) {
        let searchId;
        let csrfToken;
        try {
            const response = await this.bottService.searchSearchIdByTelegramId(telegramId);
            searchId = response.results[0].id;
        } catch (err) {
            throw new NotFoundException(ERROR_GET_SEARCH_ID);
        }
        let userBotId;
        try {
            const response = await this.bottService.getUserBotId(searchId);
            userBotId = extractUserBotId(response);
            csrfToken = extractCsrf(response);
        } catch (err) {
            throw new NotFoundException(ERROR_GET_BOT_ID);
        }

        try {
            await this.bottService.userBalanceEdit(userBotId, csrfToken, String(amount), isPositive);
        } catch (err) {
            throw new BadRequestException(ERROR_CHANGE_BALANCE);
        }
        try {
            const response = await this.bottService.getReplenishment();
            const { transactionId, completedAt } = this.getDataFromReplenishment(response, +telegramId, +amount);

            const unixtimeMsc = completedAt * 1000;
            const formDate = new Date(unixtimeMsc);

            const paymentOrderModel: PaymentOrderModel = await this.paymentRepository.updatePaymentOrderInformation(
                id,
                transactionId,
                isPositive,
                formDate,
            );
            return new PaymentOrderEntity(paymentOrderModel);
        } catch (err) {
            throw new BadRequestException(ERROR_GET_TRANSACTIONS);
        }
    }

    async createPaymentOrder(amount: number, userTelegramId: string): Promise<PaymentOrderEntity> {
        const amountCredited = this.calculateAmountWithBonus(amount, userTelegramId);

        const paymentOrderModel: PaymentOrderModel = await this.paymentRepository.createPaymentOrder({
            amount,
            amountCredited,
            userTelegramId,
        });
        await this.paymentRepository.createPaymentOrderStatusHistory(paymentOrderModel.id, paymentOrderModel.status);
        return new PaymentOrderEntity(paymentOrderModel);
    }

    private calculateAmountWithBonus(amount: number, userTelegramId: string): number {
        switch (true) {
            // case this.tgIdVipCoef.includes(userTelegramId):
            //     return Math.floor(amount * 1.25);
            case amount >= 5000:
                return Math.floor(amount * 1.05);
            case amount >= 2000:
                return Math.floor(amount * 1.02);
            default:
                return amount;
        }
    }

    async getPaymentOrder(id: string): Promise<PaymentOrderEntity | null> {
        const paymentOrderModel: PaymentOrderModel | null = await this.paymentRepository.getPaymentOrderById(id);
        return paymentOrderModel ? new PaymentOrderEntity(paymentOrderModel) : null;
    }

    async getPaymentOrders(
        pagination: Pagination,
        filters: FilterStatusPayment,
    ): Promise<{
        data: Payment[];
        meta: { total: number; page: number; limit: number; pages: number };
        sumAmount: number;
    }> {
        const res = await this.paymentRepository.getPaymentOrders(pagination, filters);

        const data: Payment[] = res.data.map(order => ({
            id: order.id,
            transactionId: order.transactionId ?? null,
            userTelegramName: order.userTelegram?.telegramName ?? null,
            completedAt: order.completedAt ?? null,
            amount: order.amount,
            amountCredited: order.amountCredited,
            status: order.status,
            receiptUrl: order.receiptUrl ? `${this.domain}/receipts/${order.receiptUrl}` : null,
            statusHistory: order.statusHistory.map((h: { status: any; changedAt: { toISOString: () => any } }) => ({
                status: h.status,
                date: h.changedAt.toISOString(),
            })),
        }));

        return {
            data,
            meta: res.meta,
            sumAmount: res.sumAmount,
        };
    }

    async updatePaymentOrderStatus(id: string, status: StatusPayment): Promise<PaymentOrderEntity> {
        const paymentOrderModel = await this.paymentRepository.updatePaymentOrderStatus(id, status);
        if (!paymentOrderModel) throw new NotFoundException(ERROR_NOT_FOUND_TRANSACTION);
        await this.paymentRepository.createPaymentOrderStatusHistory(id, status);
        return new PaymentOrderEntity(paymentOrderModel);
    }

    async getUserPaymentOrders(userTelegramId: string): Promise<PaymentOrderEntity[]> {
        const paymentOrderModels: PaymentOrderModel[] = await this.paymentRepository.getPaymentOrdersByUserTelegramId(userTelegramId);
        if (!paymentOrderModels || paymentOrderModels.length === 0) {
            return [];
        }
        return paymentOrderModels.map(paymentOrderModel => new PaymentOrderEntity(paymentOrderModel));
    }

    async makeDepositUserBalance(id: string, receiptUrl: string): Promise<PaymentOrderEntity> {
        const entityTrans = await this.completeTransferedPaymentOrder(id, receiptUrl);
        return await this.changeUserBalance(id, entityTrans.userTelegramId, entityTrans.amountCredited);
    }

    private async completeTransferedPaymentOrder(id: string, receiptUrl: string): Promise<PaymentOrderEntity> {
        const paymentOrderModel: PaymentOrderModel = await this.paymentRepository.completeTransferedPaymentOrder(id, receiptUrl);
        await this.paymentRepository.createPaymentOrderStatusHistory(paymentOrderModel.id, paymentOrderModel.status);
        return new PaymentOrderEntity(paymentOrderModel);
    }

    private getDataFromReplenishment(data: IReplenishmentUsersBotT, telegramId: number, amount: number) {
        const transaction = data.data.find(transact => transact.user.telegram_id === telegramId && transact.amount / 100 == amount);
        if (!transaction) throw new NotFoundException(ERROR_NOT_FOUND_TRANSACTION);

        return {
            transactionId: transaction.id,
            completedAt: transaction.created_at,
        };
    }

    async findRemainingActivations(telegramId: string, userName: string) {
        let promoCodeDetails = null;

        for (let page = 1; page <= 5; page++) {
            const responseCouponsPage = await this.bottService.getCouponPage(page);

            promoCodeDetails = getPromoCodeDetailsFromHtml(responseCouponsPage, userName);
            if (promoCodeDetails) {
                return promoCodeDetails;
            }

            promoCodeDetails = getPromoCodeDetailsFromHtml(responseCouponsPage, telegramId);
            if (promoCodeDetails) {
                return promoCodeDetails;
            }
        }
        return null;
    }

    // async createPromocode(telegramId: string, userName: string) {
    //     const responseStatistics = await this.bottService.getStatistics();
    //     const csrfToken = extractCsrf(responseStatistics);
    //     const usersStatistic = extractUsersStatistics(responseStatistics, this.tgNamesExceptionStatistic);
    //     const promoName = userName || telegramId;
    //     const discountPercent = this.getDiscountFromStatistic(telegramId, userName, usersStatistic);
    //     const responseStatus = await this.bottService.createPromocode(csrfToken, promoName, discountPercent);
    //     if (responseStatus != 200) throw new BadRequestException(ERROR_CREATE_PROMOCODE);
    //     return { promoName, discountPercent };
    // }

    async getInfoAboutPromocode(telegramId: string, userName: string) {
        const responseStatistics = await this.bottService.getStatistics();
        const usersStatistic = extractUsersStatistics(responseStatistics, this.tgNamesExceptionStatistic);
        return this.getDiscountFromStatistic(telegramId, userName, usersStatistic);
    }

    private getDiscountFromStatistic(telegramId: string, userName: string, usersStatistic: UserStatistic[]) {
        const user = usersStatistic.find(user => telegramId === user.tgId || userName === user.name);
        if (!user) return 5;

        switch (true) {
            case user.row === 1:
                return 25;
            case [2, 3, 4, 5].includes(user.row):
                return 20;
            case [6, 7, 8, 9, 10].includes(user.row):
                return 15;
            case [11, 12, 13, 14, 15].includes(user.row):
                return 10;
            default:
                return 5;
        }
    }

    async applyCouponToPaymentOrder(paymentId: string, newAmountCredited: number, couponId: string): Promise<PaymentOrderEntity> {
        const paymentOrderModel = await this.paymentRepository.applyCouponToPaymentOrder(paymentId, newAmountCredited, couponId);
        return new PaymentOrderEntity(paymentOrderModel);
    }

    startOfDay(d: Date) {
        const x = new Date(d);
        x.setHours(0, 0, 0, 0);
        return x;
    }
    addDays(d: Date, n: number) {
        const x = new Date(d);
        x.setDate(x.getDate() + n);
        return x;
    }
    startOfMonth(d: Date) {
        const x = new Date(d);
        x.setDate(1);
        x.setHours(0, 0, 0, 0);
        return x;
    }
    addMonths(d: Date, n: number) {
        const x = new Date(d);
        x.setMonth(x.getMonth() + n, 1);
        return this.startOfMonth(x);
    }
    toISODate(d: Date) {
        return d.toISOString().slice(0, 10);
    }

    async getPaymentStats(params: { dayFrom?: Date; dayTo?: Date; monthFrom?: Date; monthTo?: Date; status?: StatusPayment }) {
        const now = new Date();

        // ---- ДНИ: дефолт последние 7 дат, включая сегодня ----
        const df = this.startOfDay(params.dayFrom ?? this.addDays(now, -6));
        const dt = this.startOfDay(params.dayTo ?? now);
        const dToExclusive = this.addDays(dt, 1);

        // ---- МЕСЯЦЫ: дефолт последние 12 месяцев, включая текущий ----
        const thisMonth = this.startOfMonth(now);
        const mf = this.startOfMonth(params.monthFrom ?? this.addMonths(thisMonth, -11));
        const mt = this.startOfMonth(params.monthTo ?? thisMonth);
        const mToExclusive = this.addMonths(mt, 1);

        const [byDay, byMonth, totalsDay, totalsMonth] = await Promise.all([
            this.paymentRepository.getStatsDaily(df, dToExclusive, params.status),
            this.paymentRepository.getStatsMonthly(mf, mToExclusive, params.status),
            this.paymentRepository.getStatsTotals(df, dToExclusive, params.status),
            this.paymentRepository.getStatsTotals(mf, mToExclusive, params.status),
        ]);

        const byDayOut = byDay.map(r => ({
            date: this.toISODate(r.bucket),
            count: r.count,
            sumAmount: Number(r.sum_amount) || 0,
        }));

        const byMonthOut = byMonth.map(r => ({
            month: this.toISODate(r.bucket).slice(0, 7),
            count: r.count,
            sumAmount: Number(r.sum_amount) || 0,
        }));

        return {
            range: {
                day: { from: this.toISODate(df), to: this.toISODate(dt) },
                month: { from: this.toISODate(mf), to: this.toISODate(mt) },
            },
            byDay: byDayOut,
            byMonth: byMonthOut,
            totalsDay: { count: totalsDay.count, sumAmount: Number(totalsDay.sum_amount) || 0 },
            totalsMonth: { count: totalsMonth.count, sumAmount: Number(totalsMonth.sum_amount) || 0 },
        };
    }
}

```

src/module/payment/constants/error.constants.ts:
```
export const ERROR_GET_SEARCH_ID = 'Ошибка поиска searchId клиента';
export const ERROR_GET_BOT_ID = 'Ошибка в поиске botId клиента';
export const ERROR_GET_TOKEN = 'Ошибка в получении токена платежа';
export const ERROR_CHANGE_BALANCE = 'Ошибка изменения баланса пользователя';
export const ERROR_NOT_FOUND_TRANSACTION = 'Не найдена транзакция на пополнение';
export const ERROR_GET_TRANSACTIONS = 'Ошибка в получении списка транзакций';
export const ERROR_GET_STATISTICS = 'Ошибка в получении статистики пользователей';
export const ERROR_CREATE_PROMOCODE = 'Ошибка в создании промокода';

```

src/module/payment/dto/queryFilter.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { StatusPayment } from '@prisma/client';

export const PaginationSchema = z.object({
    page: z.coerce.number().int().min(1).optional(),
    limit: z.coerce.number().int().min(1).optional(),
});
export type Pagination = z.infer<typeof PaginationSchema>;
export class PaginationDto extends createZodDto(PaginationSchema) {}

export const FilterStatusPaymentSchema = z.object({
    status: z.nativeEnum(StatusPayment).optional(),
});
export type FilterStatusPayment = z.infer<typeof FilterStatusPaymentSchema>;
export class FilterStatusPaymentDto extends createZodDto(FilterStatusPaymentSchema) {}

export const GetPaymentOrdersQuerySchema = PaginationSchema.merge(FilterStatusPaymentSchema);
export class GetPaymentOrdersQueryDto extends createZodDto(GetPaymentOrdersQuerySchema) {}

```

src/module/payment/dto/stats.query.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { StatusPayment } from '@prisma/client';

export const PaymentStatsQuerySchema = z.object({
    dayFrom: z.coerce.date().optional(),
    dayTo: z.coerce.date().optional(),

    monthFrom: z.coerce.date().optional(),
    monthTo: z.coerce.date().optional(),

    status: z.nativeEnum(StatusPayment).optional(),
});

export class PaymentStatsQueryDto extends createZodDto(PaymentStatsQuerySchema) {}

```

src/module/payment/dto/updateStatus.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';
import { StatusPayment } from '@prisma/client';

const StatusRequestSchema = z.object({
    status: z.nativeEnum(StatusPayment),
});

export namespace StatusCommand {
    export const RequestSchema = StatusRequestSchema;
    export type Request = z.infer<typeof RequestSchema>;
}

export class StatusRequestDto extends createZodDto(StatusCommand.RequestSchema) {}

```

src/module/payment/entities/payment.entities.ts:
```
import { PaymentOrder as PaymentOrderModel, StatusPayment } from '@prisma/client';

export class PaymentOrderEntity implements PaymentOrderModel {
    id: string; // UUID
    transactionId: number | null;
    amount: number;
    amountCredited: number;
    status: StatusPayment;
    receiptUrl: string | null;
    isPositive: boolean | null;
    completedAt: Date | null;
    couponId: string | null;
    couponApplied: boolean;
    userTelegramId: string;
    createdAt: Date;
    updatedAt: Date;

    constructor(paymentOrder: PaymentOrderModel) {
        Object.assign(this, paymentOrder);
        return this;
    }
}

```

src/module/payment/interfaces/payment.interface.ts:
```
import { StatusPayment } from '@prisma/client';

export interface Payment {
    id: string;
    transactionId: number | null;
    userTelegramName: string;
    completedAt: Date | null;
    amount: number;
    amountCredited: number;
    status: StatusPayment;
    receiptUrl: string | null;
    statusHistory: StatusHistory[];
}

export interface StatusHistory {
    status: StatusPayment;
    date: string;
}

```

src/module/payment/interfaces/statistic.interface.ts:
```
export interface UserStatistic {
    row: number;
    name: string;
    tgId: string | null;
}

export interface USerPromocodeActivations {
    activationsLeft: number;
    discount: number;
}

```

src/module/proxy/proxy.controller.ts:
```
import { Controller, Get, Patch, Param, Query, Body, HttpCode } from '@nestjs/common';
import { HasZenno } from '@common/decorators/zenno.decorator';
import { ProxyService } from './proxy.service';
import { GetProxiesQueryDto } from './dto/query.dto';
import { UpdateProxyDto } from './dto/update-proxy.dto';

@Controller('proxies')
export class ProxyController {
    constructor(private readonly service: ProxyService) {}

    @HasZenno()
    @Get()
    @HttpCode(200)
    async list(@Query() q: GetProxiesQueryDto) {
        return this.service.listProxies({ page: q.page, limit: q.limit });
    }

    @HasZenno()
    @Patch(':uuid')
    @HttpCode(200)
    async update(@Param('uuid') uuid: string, @Body() dto: UpdateProxyDto) {
        return this.service.updateProxy(uuid, dto);
    }
}

```

src/module/proxy/proxy.module.ts:
```
import { Module } from '@nestjs/common';
import { ProxyService } from './proxy.service';
import { ProxyRepository } from './proxy.repository';
import { ProxyController } from './proxy.controller';

@Module({
    controllers: [ProxyController],
    providers: [ProxyService, ProxyRepository],
    exports: [ProxyService],
})
export class ProxyModule {}

```

src/module/proxy/proxy.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { Prisma, Proxy } from '@prisma/client';
import { PrismaService } from '@common/database/prisma.service';

@Injectable()
export class ProxyRepository {
    constructor(private prisma: PrismaService) {}

    async getAllAvailableProxy(currentTime: Date, timeBlockedMinute: number = 5): Promise<Proxy[]> {
        const timeBlockedAgo = new Date();
        timeBlockedAgo.setMinutes(currentTime.getMinutes() - timeBlockedMinute);

        return this.prisma.proxy.findMany({
            where: {
                OR: [{ blockedAt: null }, { blockedAt: { lte: timeBlockedAgo } }],
                expiresAt: {
                    gte: currentTime,
                },
            },
        });
    }

    async list(page = 1, limit = 50) {
        const skip = (page - 1) * limit;
        const where: Prisma.ProxyWhereInput = {};

        const [total, items] = await this.prisma.$transaction([
            this.prisma.proxy.count({ where }),
            this.prisma.proxy.findMany({
                orderBy: { createdAt: 'desc' },
                skip,
                take: limit,
                select: {
                    uuid: true,
                    proxy: true,
                    expiresAt: true,
                },
            }),
        ]);

        return {
            items,
            meta: {
                total,
                page,
                limit,
                pages: Math.max(1, Math.ceil(total / limit)),
            },
        };
    }

    async update(uuid: string, data: Prisma.ProxyUpdateInput) {
        return this.prisma.proxy.update({
            where: { uuid },
            data,
            select: {
                uuid: true,
                proxy: true,
                expiresAt: true,
                blockedAt: true,
                createdAt: true,
                updatedAt: true,
            },
        });
    }
}

```

src/module/proxy/proxy.service.ts:
```
import { Injectable } from '@nestjs/common';
import { ProxyRepository } from './proxy.repository';
import { ProxyEntity } from './entities/proxy.entity';
import { ERROR_FREE_PROXY } from './error/error.constant';

@Injectable()
export class ProxyService {
    constructor(private proxyRepository: ProxyRepository) {}

    async getRandomProxy(): Promise<ProxyEntity> {
        const proxies = await this.proxyRepository.getAllAvailableProxy(new Date());
        if (proxies.length == 0) throw new Error(ERROR_FREE_PROXY);
        const index = Math.floor(Math.random() * proxies.length);
        const proxy = proxies[index];
        return new ProxyEntity(proxy);
    }

    async listProxies(pagination: { page?: number; limit?: number }) {
        const page = Math.max(1, pagination?.page ?? 1);
        const limit = Math.min(200, Math.max(1, pagination?.limit ?? 50));
        return this.proxyRepository.list(page, limit);
    }

    async updateProxy(uuid: string, dto: { proxy?: string; expiresAt?: Date; blockedAt?: Date | null }) {
        return this.proxyRepository.update(uuid, dto);
    }
}

```

src/module/proxy/dto/query.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

export const GetProxiesQuerySchema = z.object({
    page: z.coerce.number().int().min(1).optional(),
    limit: z.coerce.number().int().min(1).max(200).optional(),
});
export class GetProxiesQueryDto extends createZodDto(GetProxiesQuerySchema) {}

```

src/module/proxy/dto/update-proxy.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

export const UpdateProxySchema = z.object({
    proxy: z.string().trim().min(1).optional(),
    // ожидаем ISO-дату или timestamp -> превратим в Date
    expiresAt: z.coerce.date().optional(),
    // опционально: разблокировка/блокировка
    blockedAt: z.coerce.date().nullable().optional(),
});
export class UpdateProxyDto extends createZodDto(UpdateProxySchema) {}

```

src/module/proxy/entities/proxy.entity.ts:
```
import { Proxy } from '@prisma/client';

export class ProxyEntity implements Proxy {
    uuid: string;
    proxy: string;
    expiresAt: Date;
    blockedAt: Date | null;

    createdAt: Date;
    updatedAt: Date;

    constructor(proxy: Partial<Proxy>) {
        Object.assign(this, proxy);
        return this;
    }
}

```

src/module/proxy/error/error.constant.ts:
```
export const ERROR_FREE_PROXY = 'Нет свободных прокси, подождите пару минут';

```

src/module/proxy/interfaces/proxy.interface.ts:
```

```

src/module/shared/file.service.ts:
```
import { Injectable, Logger } from '@nestjs/common';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { HttpService } from '../http/http.service';
import { fromBuffer } from 'pdf2pic';

@Injectable()
export class FileService {
    private readonly logger = new Logger(FileService.name);

    private uploadDir = './public/receipts';

    constructor(private httpService: HttpService) {
        if (!fs.existsSync(this.uploadDir)) {
            fs.mkdirSync(this.uploadDir, { recursive: true });
        }
    }

    /**
     * Сохраняет файл из буфера в указанную директорию.
     * @param fileName Имя файла для сохранения.
     * @param fileBuffer Буфер с данными файла.
     */
    async saveFile(fileName: string, fileBuffer: Buffer): Promise<void> {
        const filePath = path.join(this.uploadDir, fileName);
        await fs.promises.writeFile(filePath, fileBuffer);
    }

    /**
     * Конвертирует PDF буфер в JPG буфер с использованием pdf2pic.
     * @param pdfBuffer Буфер PDF файла.
     * @param fileNameBase Основа имени файла без расширения.
     * @returns Буфер JPG изображения.
     */
    async convertPdfToJpg(pdfBuffer: Buffer, fileNameBase: string): Promise<Buffer> {
        const options = {
            density: 100,
            saveFilename: fileNameBase,
            savePath: this.uploadDir,
            format: 'jpg',
            width: 600,
            height: 600,
        };

        const converter = fromBuffer(pdfBuffer, options);

        const pageToConvertAsImage = 1;

        try {
            const result = await converter(pageToConvertAsImage, { responseType: 'buffer' });

            if (result && result.buffer) {
                return result.buffer; // Верни буфер
            } else {
                throw new Error('Результат не содержит буфер');
            }
        } catch (error) {
            this.logger.error('Ошибка при конвертации PDF в JPG:', error);
            throw new Error('Ошибка при конвертации PDF в изображение');
        }
    }

    /**
     * Сохраняет файл из Telegram через ссылку.
     * @param fileName Имя файла для сохранения.
     * @param fileLink Ссылка на файл.
     */
    async saveFileFromTg(fileName: string, fileLink: URL): Promise<void> {
        const filePath = path.join(this.uploadDir, fileName);

        const response = await this.httpService.get(fileLink.href, { responseType: 'stream' });

        const writer = fs.createWriteStream(filePath);
        response.data.pipe(writer);

        await new Promise((resolve, reject) => {
            writer.on('finish', resolve);
            writer.on('error', reject);
        });
    }

    async downloadFile(fileUrl: string): Promise<Buffer> {
        try {
            const response = await this.httpService.get(fileUrl, {
                responseType: 'arraybuffer',
            });

            return Buffer.from(response.data);
        } catch (error) {
            throw new Error('Не удалось скачать файл');
        }
    }
}

```

src/module/shared/shared.module.ts:
```
import { Module } from '@nestjs/common';
import { FileService } from './file.service';
import { HttpModule } from '../http/http.module';

@Module({
    providers: [FileService],
    exports: [FileService],
    imports: [HttpModule],
})
export class SharedModule {}

```

src/module/telegram/telegram.module.ts:
```
import { Module } from '@nestjs/common';
import { BaseUpdate, HelpUpdate } from './updates/base-command/base-command.update';
import { StartUpdate } from './updates/start/start.update';
import { ChangeNumberInputCode, ChangeNumberInputNumber, ChangeNumberUpdate } from './updates/change-number/change-number.update';
import { TelegramService } from './telegram.service';
import {
    MakeOrderUpdate,
    OrderChangeRecipient,
    OrderCity,
    OrderFavouriteCity,
    OrderGetOrders,
    OrderInputArticle,
    OrderInputLink,
    OrderInputPromo,
    OrderMenuAccount,
    OrderMenuCart,
} from './updates/make-order/make-order.update';
import { MakeOrderService } from './updates/make-order/make-order.service';
import { CalculateUpdate } from './updates/calculate/calculate.update';
import { CheckingUpdate } from './updates/checking/checking.update';
import { CheckingService } from './updates/checking/checking.service';
import { EmailUpdate } from './updates/email/email.update';
import { EmailService } from './updates/email/email.service';
import { CookieUpdate } from './updates/cookie/cookie.update';
import { QrCodeUpdate } from './updates/qr-code/qr-code.update';
import { QrCodeService } from './updates/qr-code/qr-code.service';
import { GetInfoOrderUpdate, ProfileUpdate } from './updates/profile/profile.update';
import { AdminUpdate } from './updates/admin/admin.update';
import { AuthMirrorUpdate } from './updates/auth-mirror/auth-mirror.update';
import { PaymentPromocodeUpdate, PaymentUpdate } from './updates/payment/payment.update';
import { AccountModule } from '../account/account.module';
import { ProxyModule } from '../proxy/proxy.module';
import { SharedModule } from '../shared/shared.module';
import { HttpModule } from '../http/http.module';
import { UserModule } from '../user/user.module';
import { PaymentModule } from '../payment/payment.module';
import { MirrorModule } from '../mirror/mirror.module';
import { CouponModule } from '../coupon/coupon.module';
import { FortuneUpdate } from './updates/fortune/fortune.update';
import {
    CalculateSettingsScene,
    CommissionRateScene,
    CommissionTypeScene,
    CustomRoundScene,
    RoundToScene,
    TemplateNameScene,
    TemplateTextScene,
} from './updates/calculate/calculate-settings.update';
import { CalculateService } from './updates/calculate/calculate.service';
import { CalculateRepository } from './updates/calculate/calculate.repository';

@Module({
    imports: [AccountModule, ProxyModule, SharedModule, HttpModule, UserModule, PaymentModule, MirrorModule, CouponModule],
    providers: [
        TelegramService,
        MakeOrderService,
        BaseUpdate,
        HelpUpdate,
        AdminUpdate,
        StartUpdate,
        ChangeNumberUpdate,
        ChangeNumberInputNumber,
        ChangeNumberInputCode,
        MakeOrderUpdate,
        OrderMenuAccount,
        OrderCity,
        OrderFavouriteCity,
        OrderMenuCart,
        OrderInputLink,
        OrderInputPromo,
        OrderInputArticle,
        OrderChangeRecipient,
        OrderGetOrders,
        CalculateUpdate,
        CheckingUpdate,
        CheckingService,
        EmailUpdate,
        EmailService,
        CookieUpdate,
        QrCodeUpdate,
        QrCodeService,
        ProfileUpdate,
        GetInfoOrderUpdate,
        AuthMirrorUpdate,
        PaymentUpdate,
        PaymentPromocodeUpdate,
        FortuneUpdate,
        CalculateService,
        CalculateRepository,
        CalculateSettingsScene,
        TemplateNameScene,
        TemplateTextScene,
        CommissionTypeScene,
        CommissionRateScene,
        RoundToScene,
        CustomRoundScene,
    ],
    exports: [TelegramService],
})
export class TelegramModule {}

```

src/module/telegram/telegram.service.ts:
```
import { HttpException, HttpStatus, Inject, Injectable, Logger } from '@nestjs/common';
import { Cache, CACHE_MANAGER } from '@nestjs/cache-manager';
import { Ctx, InjectBot } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { getValueKeysMenu } from './updates/base-command/base-command.constants';
import { IAccountCashing } from '../account/interfaces/account.interface';
import { ERROR_TIMEOUT_TTL_CASH } from './constants/error.constant';
import { ConfigService } from '@nestjs/config';
import { Telegraf } from 'telegraf';

@Injectable()
export class TelegramService {
    private readonly logger = new Logger(TelegramService.name);
    private TTL_CASH = this.configService.getOrThrow('TTL_CASH', 86000000);

    constructor(
        @Inject(CACHE_MANAGER) private cacheManager: Cache,
        private configService: ConfigService,
        @InjectBot() private readonly bot: Telegraf,
    ) {}

    async exitScene(menuBtn: string, @Ctx() ctx: WizardContext) {
        await ctx.scene.leave();
        const scene = getValueKeysMenu(menuBtn);
        if (scene) {
            return await ctx.scene.enter(scene);
        }
    }

    async setTelegramAccountCache(telegramId: string, accountId: string) {
        const accountFromCache = await this.cacheManager.get<IAccountCashing>(String(telegramId));
        if (accountFromCache) {
            await this.cacheManager.del(accountFromCache.accountId);
        }
        await this.cacheManager.del(accountId);
        await this.cacheManager.set(String(telegramId), { accountId }, this.TTL_CASH);
    }

    async getFromCache(telegramId: string) {
        const account = await this.cacheManager.get<IAccountCashing>(String(telegramId));
        if (!account) throw new HttpException(ERROR_TIMEOUT_TTL_CASH, HttpStatus.FORBIDDEN);
        return account;
    }

    async setDataCache<T>(telegramId: string, data: T) {
        const dataFromCache = await this.cacheManager.get<any>(String(telegramId));
        if (dataFromCache) {
            await this.cacheManager.del(dataFromCache.data);
        }
        await this.cacheManager.set(String(telegramId), data, this.TTL_CASH);
    }

    async getDataFromCache<T>(telegramId: string): Promise<T> {
        const data = await this.cacheManager.get<T>(String(telegramId));
        if (!data) throw new HttpException(ERROR_TIMEOUT_TTL_CASH, HttpStatus.FORBIDDEN);
        return data;
    }

    async sendMessage(chatId: number, text: string) {
        try {
            await this.bot.telegram.sendMessage(chatId, text);
        } catch (error) {
            this.logger.error('Ошибка при отправке сообщения:', error);
        }
    }
}

```

src/module/telegram/constants/admin.constant.ts:
```
export const NOT_ADMIN = 'Нет прав администратора  😡';
export const NOT_ADMIN_LIST = 'Список администраторов пуст';

```

src/module/telegram/constants/error.constant.ts:
```
export const ERROR_ACCOUNT_ID =
    'Не верно введен номер аккаунта. Номер должен быть вида: 5d35*ba0-cc*9-4*72-a1*0-9*e9*a0a*b*1. Введите еще раз';
export const ERROR_TIMEOUT_TTL_CASH = 'Данные устарели, повторите заново';
export const ERROR_NUMBER_PHONE = 'Неправильно введён номер! Номер должен иметь вид 88005553535';
export const ERROR_CODE_PHONE = 'В коде должно быть 4 цифры, повторите ввод';
export const ERROR_CITY = 'Не верно введено название города. Название должно содержать только кириллицу. Введите еще раз';
export const ERROR_FIND_CITY = 'Город не найден';
export const ERROR_URL_LINK =
    'Не верный тип ссылки. Должна быть вида: https://www.sportmaster.ru/cart/snapshots/f64c3353-aa2a-4e40-b504-7021f1833f9a?utm_source=android_appshare&utm_medium=soc&utm_campaign=socsharing_cart_android';
export const ERROR_FIO =
    'Не введены данные. Они должны быть как в примере ниже через пробел:\nПетров Петр petroffff148@mail.ru 88005553535';
export const ERROR_FIRST_NAME = 'Имя должно быть введено на кириллице';
export const ERROR_LAST_NAME = 'Фамилия должна быть введена на кириллице';
export const ERROR_EMAIL = 'Не верный формат email. Он должен быть вида example@example.ru';
export const ERROR_INTEGER = 'Не число';
export const ERROR_LOW_MONEY_COUNT = 'Сумма должна быть больше 500р';
export const ERROR_NOT_MULTIPLE_OF_50 = 'Сумма должна быть кратной 50р (1000, 1050 и т.д.)';
export const ERROR_SCRINSHOT = 'Пришлите скриншот перевода или Pdf';
export const ERROR_FOUND_USER = 'Пользователь не найден';
export const ERROR_ACCESS = 'Доступ запрещен';

```

src/module/telegram/filters/telegraf-exception.filter.ts:
```
import { ArgumentsHost, Catch, ExceptionFilter, Logger } from '@nestjs/common';
import { TelegrafArgumentsHost } from 'nestjs-telegraf';
import { Context } from 'telegraf';
import { AxiosError } from 'axios';
import { ERROR_LOGOUT_MP } from '../../account/constants/error.constant';
import { AccountService } from '../../account/account.service';

@Catch()
export class TelegrafExceptionFilter implements ExceptionFilter {
    private readonly logger = new Logger(TelegrafExceptionFilter.name);

    constructor(private accountService: AccountService) {}

    async catch(exception: Error, host: ArgumentsHost): Promise<void> {
        const telegrafHost = TelegrafArgumentsHost.create(host);
        const ctx = telegrafHost.getContext<Context>();
        if (exception instanceof AxiosError) {
            if (exception.message == 'Socks5 proxy rejected connection - NotAllowed') {
                exception.message = ERROR_LOGOUT_MP;
            } else {
                if (exception.response) {
                    switch (exception.response.statusText) {
                        case 'Unauthorized':
                            if (exception.response!.data?.error?.code == 'UNAUTHORIZED') {
                                exception.message = ERROR_LOGOUT_MP;
                                break;
                            }
                        case 'Bad Request':
                            if (exception.response!.data?.error?.code == 'WRONG_TOKEN') {
                                exception.message = ERROR_LOGOUT_MP;
                                const accountId = exception.config!.headers['Account-Id'];
                                await this.accountService.setBanMp(accountId);
                            }
                            if (exception.response!.data?.error?.code == 'TOO_MANY_INCORRECT_CODE_INPUTS') {
                                exception.message = exception.response!.data.error.message;
                            }
                            if (exception.response!.data?.error?.code == 'TOO_MANY_DIFFERENT_PHONES_TO_REQUEST_CODE') {
                                exception.message = exception.response!.data.error.message; //
                            }
                            // exception.message = ERROR_UNKNOWN;
                            exception.message = exception.response!.data?.error?.message;
                            break;
                        default:
                            this.logger.log(exception.response);
                    }
                } else {
                    this.logger.log('pass');
                }
            }
        }
        this.logger.log(exception.message);
        await ctx.replyWithHTML(`<b>❌</b>  ${exception.message}`);
    }
}

```

src/module/telegram/interfaces/calculate.interface.ts:
```
export interface ICalculateCash {
    outputPrices: {
        price: string;
        priceDiscount: number;
        currentBonus: number;
        currentBonusPromo: number;
        priceDiscountPromo: number;
    }[];
    totalPrice: number;
    totalDiscount: number;
    totalPriceBonus: number;
    totalDiscountPromo: number;
    totalFullDiscount: number;
    totalSumOnKassa: number;
}

```

src/module/telegram/interfaces/telegram.context.ts:
```
import { Scenes } from 'telegraf';

interface SessionData {
    [key: string]: any;
}

export interface Context extends Scenes.SceneContext {
    mySession?: SessionData;
}

export interface SenderTelegram {
    id: number;
    is_bot: boolean;
    first_name: string;
    username: string;
    language_code: string;
}

```

src/module/telegram/keyboards/base.keyboard.ts:
```
import { Markup } from 'telegraf';
import {
    AUTH_MIRROR,
    CALCULATE_BONUS,
    CASH_RECEIPT,
    CHANGE_NUMBER,
    CHECK,
    COOKIE,
    HELP,
    MAKE_ORDER,
    PROFILE,
    QR_CODE,
} from '../updates/base-command/base-command.constants';
import { UserRole } from '@prisma/client';

export function getMainMenuKeyboard(role?: UserRole) {
    const firstRow = [CHANGE_NUMBER.name, MAKE_ORDER.name];
    if (role == 'Admin') firstRow.unshift(AUTH_MIRROR.name);
    const keyboard = [
        firstRow,
        [CALCULATE_BONUS.name, CHECK.name],
        [COOKIE.name, QR_CODE.name, CASH_RECEIPT.name],
        [PROFILE.name, HELP.name],
    ];

    return Markup.keyboard(keyboard).resize();
}

```

src/module/telegram/keyboards/calculate.keyboard.ts:
```
import { Markup } from 'telegraf';
import { UserTemplate } from '@prisma/client';

export const calculateInfoKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback(`Как пользоваться калькулятором`, `go_to_calculate_info`)],
    [Markup.button.callback(`Настройки шаблонов`, `go_to_calculate_settings`)],
]);

export const calculateShowKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback(`Показать расчет индивидуально`, `go_to_calculate_show`)],
]);

export const calculateTemplatesKeyboard = (templates: UserTemplate[] = []) => {
    const keyboard = [
        [Markup.button.callback('Создать новый шаблон', 'create_template')],
        ...templates.map(template => [Markup.button.callback(template.name, `template_${template.id}`)]),
        [Markup.button.callback('Назад', 'back_to_calculate')],
    ];

    return Markup.inlineKeyboard(keyboard);
};

```

src/module/telegram/keyboards/make-order.keyboard.ts:
```
import { Markup } from 'telegraf';
import { CitySMEntity } from '../../account/entities/citySM.entity';
import { SearchProductInterface } from '../../account/interfaces/search-product.interface';
import { PickupAvabilityInterface } from '../../account/interfaces/pickup-avability.interface';
import { OrdersInterface } from '../../account/interfaces/orders.interface';
import { ICartItemsInfo } from '../../account/interfaces/cart.interface';

export const mainMenuOrderKeyboard = (city: string) => {
    return Markup.inlineKeyboard([
        [Markup.button.callback(`Изменить город: ${city}`, 'go_to_city')],
        [Markup.button.callback(`Перейти в корзину`, 'go_to_cart')],
        [Markup.button.callback(`Перейти к заказам`, 'go_to_orders')],
    ]);
};

export const getCitiesKeyboard = (cities: CitySMEntity[]) => {
    return Markup.inlineKeyboard([
        ...cities.map(city => {
            return [Markup.button.callback(`${city.fullName}`, `id_city_${city.cityId}`)];
        }),
        [Markup.button.callback('Назад', 're_enter_scene')],
    ]);
};

export const getCitiesForDeleteKeyboard = (cities: CitySMEntity[]) => {
    return Markup.inlineKeyboard([
        ...cities.map(city => {
            return [Markup.button.callback(`${city.name}`, `del_city_${city.cityId}`)];
        }),
        [Markup.button.callback('Назад', 're_enter_scene')],
    ]);
};

export const getFoundedCitiesForFavKeyboard = (cities: CitySMEntity[]) => {
    return Markup.inlineKeyboard([
        ...cities.map(city => {
            return [Markup.button.callback(`${city.fullName}`, `add_favourite_city_${city.cityId}`)];
        }),
        [Markup.button.callback('Назад', 'go_back')],
    ]);
};

export const getUserCitiesKeyboard = (userCities: CitySMEntity[]) => {
    const btns = [
        [Markup.button.callback('Добавить город в избранное', 'add_new_user_city')],
        ...userCities.map(city => {
            return [Markup.button.callback(`${city.name}`, `id_city_${city.cityId}`)];
        }),
        userCities.length != 0 ? [Markup.button.callback('Удалить город из избранного', 'del_favourite_city')] : [],
        [Markup.button.callback('Вернуться в меню', 'go_to_menu')],
    ];
    return Markup.inlineKeyboard(btns);
};

export const comebackBtn = Markup.inlineKeyboard([[Markup.button.callback('Назад', 'go_back')]]);

export const cartItemsKeyboard = (cartItems: ICartItemsInfo[]) => {
    const keyboard = [];
    // const items = cartItems.data.cartFull.availableItems;
    for (const item of cartItems) {
        keyboard.push([Markup.button.callback(item.name, `id_remove_${item.cartItemId.productId}_${item.cartItemId.sku}`)]);
    }

    keyboard.push(
        [Markup.button.callback('Добавить товар', 'add_item_cart')],
        [Markup.button.callback('Внести корзину по ссылке', 'add_order_link')],
        [Markup.button.callback('Поделиться корзиной', 'share_cart'), Markup.button.callback('Очистить корзину', 'clear_cart')],
        [Markup.button.callback('Добавить промокод', 'add_promo'), Markup.button.callback('Удалить промокод', 'delete_promo')],
        [Markup.button.callback('Перейти к выбору ТЦ', 'shop_selection')],
        [Markup.button.callback('Вернуться в меню', 'go_to_menu')],
    );

    return Markup.inlineKeyboard(keyboard);
};

export const emptyCartKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('Добавить товар', 'add_item_cart')],
    [Markup.button.callback('Внести корзину по ссылке', 'add_order_link')],
    [
        Markup.button.callback('Доб. Пакет', 'id_add_23748420299_41707140299'),
        Markup.button.callback('Доб. Батончик', 'id_add_29280430299_51691400299'),
        Markup.button.callback('Доб. Б.Пакет', 'id_add_23748410299_41707130299'),
    ],
    [Markup.button.callback('Вернуться в меню', 'go_to_menu')],
]);

export function getSearchProductKeyboard(searchProduct: SearchProductInterface) {
    const list = searchProduct.data.list;

    return Markup.inlineKeyboard([
        ...list.map(item => {
            return [Markup.button.callback(`${item.name}`, `id_product_${item.id}`)];
        }),
        [Markup.button.callback('Назад', 'go_back')],
    ]);
}

export function getSearchSkuKeyboard(productId: string, searchProduct: SearchProductInterface) {
    const list = searchProduct.data.list;
    const item = list.filter(value => value.id == productId)[0];
    const skus = item.skus;

    const availableSkus = skus.filter(item => item.availability.isOnlineAvailable);
    if (availableSkus.length == 0) return null;

    return Markup.inlineKeyboard([
        ...availableSkus.map(item => {
            return [Markup.button.callback(`${item.sizes[1].value} ${item.sizes[1].name || ''}`, `id_add_${productId}_${item.id}`)];
        }),
        [Markup.button.callback('Назад', 'go_back')],
    ]);
}

const availability = { SUPPLY: 'Под Заказ', IN_STOCK: 'В наличии' };
export const comebackShopSelection = Markup.inlineKeyboard([[Markup.button.callback('Назад', 'shop_selection')]]);

export const accessShopsKeyboard = (avabilityShops: PickupAvabilityInterface) => {
    const shops = avabilityShops.data.list;
    const keyboard = [];
    for (const shop of shops) {
        // const shop = shops[shopKey];
        const avabilityShop = shop.potentialOrders[0].availability;
        keyboard.push([
            Markup.button.callback(
                `${shop.shop.name} ${availability[avabilityShop as keyof typeof availability]}`,
                `id_shop_${shop.shop.shopNumber}`,
            ),
        ]);
    }
    keyboard.push([Markup.button.callback('Назад', 'go_back')]);
    return Markup.inlineKeyboard(keyboard);
};

export const aproveShopKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback(`Подтвердить`, `approve_shop`)],
    [Markup.button.callback(`Вернуться назад`, 'shop_selection')],
]);

export const recipientKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback(`Изменить получателя`, `recipient_not_i`)],
    [Markup.button.callback(`Оставить из профиля`, 'recipient_i')],
]);

export const ordersInfoKeyboard = Markup.inlineKeyboard([[Markup.button.callback(`Перейти к заказам`, `go_to_orders`)]]);

export const comebackCartkeyboard = Markup.inlineKeyboard([[Markup.button.callback('Вернуться в корзину', 'go_to_cart')]]);

export const orderHistoryKeyboard = (orders: OrdersInterface) => {
    const keyboard = [];
    for (const order of orders.data.orders) {
        keyboard.push([
            Markup.button.callback(`${order.number} ${order.status.statusText} ${order.receiptCode || ''}`, `order_${order.number}`),
        ]);
    }
    keyboard.push([Markup.button.callback(`Вернуться в меню`, `go_to_menu`)]);
    return Markup.inlineKeyboard(keyboard);
};

export const infoOrderKeyboard = (accountId: string, orderNumber: string, isCancelled: boolean, DOMAIN: string) => {
    const keyboard = [];

    !isCancelled && keyboard.push([Markup.button.callback(`Отменить заказ`, `cancelled_order_${orderNumber}`)]);

    keyboard.push([Markup.button.callback(`Вернуться к заказам`, `go_to_orders`)]);
    keyboard.push([Markup.button.url(`Посмотреть заказ на сайте`, `${DOMAIN}/api/order/${accountId}/${orderNumber}`)]);

    return Markup.inlineKeyboard(keyboard);
};

```

src/module/telegram/keyboards/payment.keyboard.ts:
```
import { Markup } from 'telegraf';

export const gotoCoupon = Markup.inlineKeyboard([[Markup.button.callback('Получить личный промо', 'goto_coupon')]]);

```

src/module/telegram/keyboards/profile.keyboard.ts:
```
import { Markup } from 'telegraf';
import { PaymentOrderEntity } from '../../payment/entities/payment.entities';
import { UserRole } from '@prisma/client';

export const profileKeyboard = (role: UserRole) => {
    const btnArr: any[] = [];
    role != 'User' ? btnArr.push([Markup.button.callback('Пополнить баланс', 'payment')]) : null;
    role != 'User' ? btnArr.push([Markup.button.callback('Призы фортуны', 'fortune')]) : null;
    // role != 'User' ? btnArr.push([Markup.button.callback('Получить промокод для бота продаж', 'get_promocode')]) : null;
    btnArr.push([Markup.button.callback('Чекер промо', 'check_promo')]);
    btnArr.push([Markup.button.callback('Получить инфо по заказу', 'get_info_order')]);
    return Markup.inlineKeyboard(btnArr);
};

export function cancelPaymentKeyboard(idPayment: string) {
    return Markup.inlineKeyboard([
        [Markup.button.callback(`Ввести купон`, `payment_coupon`)],
        [Markup.button.callback(`Отменить заявку`, `cancelPayment_${idPayment}`)],
        [Markup.button.callback(`Назад`, 'goBack')],
    ]);
}

export function createdPaymentKeyboard(payments: PaymentOrderEntity[]) {
    const keyboardPay = payments.map(pay => [
        Markup.button.callback(`Заявка на сумму ${pay.amount}`, `createdPayment_${pay.id}|${pay.amount}|${pay.amountCredited}`),
    ]);

    return Markup.inlineKeyboard([...keyboardPay]);
}

export const comebackProfile = Markup.inlineKeyboard([[Markup.button.callback('Назад', 'comeback_profile')]]);
export const comebackPayment = Markup.inlineKeyboard([[Markup.button.callback('Назад', 'comeback_payment')]]);

export const createPromocodeScene = Markup.inlineKeyboard([
    [Markup.button.callback('Выпустить промо', 'create_promocode')],
    [Markup.button.callback(`Назад`, 'comeback_profile')],
]);

export const getSurprise = Markup.inlineKeyboard([[Markup.button.callback('Мне повезет', 'get_surprise')]]);

```

src/module/telegram/keyboards/qr-code.keyboard.ts:
```
import { Markup } from 'telegraf';

export const qrCodeUpdateKeyboard = Markup.inlineKeyboard([[Markup.button.callback(`Обновить Код`, `update_qrcode`)]]);

```

src/module/telegram/pipes/isAccountId.pipe.ts:
```
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import validate from 'uuid-validate';
import { ERROR_ACCOUNT_ID } from '../constants/error.constant';

@Injectable()
export class isAccountIdPipe implements PipeTransform<string> {
    transform(uuid: string, metadata: ArgumentMetadata): string {
        if (!validate(uuid)) {
            throw new BadRequestException(ERROR_ACCOUNT_ID);
        }
        return uuid.trim();
    }
}

```

src/module/telegram/pipes/isCity.pipe.ts:
```
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import { ERROR_CITY } from '../constants/error.constant';

@Injectable()
export class isCityPipe implements PipeTransform<string> {
    transform(city: string, metadata: ArgumentMetadata): string {
        const regex = /[а-яёА-ЯЁ\s-]+$/;
        const citytrim = city.trim();
        const isValidCity = regex.test(citytrim);
        if (isValidCity) return citytrim;
        throw new BadRequestException(ERROR_CITY);
    }
}

```

src/module/telegram/pipes/isCode.pipe.ts:
```
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import { ERROR_CODE_PHONE } from '../constants/error.constant';

@Injectable()
export class isCodePipe implements PipeTransform<string> {
    transform(code: string, metadata: ArgumentMetadata): string {
        const regex = /^\d{4}$|^\d{6}$/;
        const codeTrim = code.trim();
        const isValidCode = regex.test(codeTrim);
        if (isValidCode) return codeTrim;

        throw new BadRequestException(ERROR_CODE_PHONE);
    }
}

```

src/module/telegram/pipes/isFio.pipe.ts:
```
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import { ERROR_EMAIL, ERROR_FIO, ERROR_FIRST_NAME, ERROR_LAST_NAME, ERROR_NUMBER_PHONE } from '../constants/error.constant';
import { isPhone } from '../utils/isPhone.utils';
import { IRecipient } from '../../account/interfaces/account.interface';
import * as emailValidator from 'email-validator';

@Injectable()
export class isFioPipe implements PipeTransform<string> {
    transform(dataFio: string, metadata: ArgumentMetadata): IRecipient {
        let firstName, lastName, email, number;
        try {
            [firstName, lastName, email, number] = dataFio.split(' ');
        } catch (err) {
            throw new BadRequestException(ERROR_FIO);
        }

        if (!firstName.match(/[а-яёА-ЯЁ]+/g)) throw new BadRequestException(ERROR_FIRST_NAME);

        if (!lastName.match(/[а-яёА-ЯЁ]+/g)) throw new BadRequestException(ERROR_LAST_NAME);

        if (!emailValidator.validate(email)) {
            throw new BadRequestException(ERROR_EMAIL);
        }

        const validPhone = isPhone(number);
        if (!validPhone) throw new BadRequestException(ERROR_NUMBER_PHONE);

        return {
            firstName,
            lastName,
            email,
            number: validPhone,
        };
    }
}

```

src/module/telegram/pipes/isMoneyAmount.pipe.ts:
```
import { BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import { ERROR_INTEGER, ERROR_LOW_MONEY_COUNT, ERROR_NOT_MULTIPLE_OF_50 } from '../constants/error.constant';

@Injectable()
export class isMoneyAmountPipe implements PipeTransform<string> {
    transform(amountCount: string): number {
        const amount = Math.floor(Number(amountCount));

        if (!Number.isInteger(amount)) {
            throw new BadRequestException(ERROR_INTEGER);
        }
        if (amount < 500) {
            throw new BadRequestException(ERROR_LOW_MONEY_COUNT);
        }
        if (amount % 50 !== 0) {
            throw new BadRequestException(ERROR_NOT_MULTIPLE_OF_50);
        }

        return amount;
    }
}

```

src/module/telegram/pipes/isPhone.pipe.ts:
```
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import { ERROR_NUMBER_PHONE } from '../constants/error.constant';
import { isPhone } from '../utils/isPhone.utils';

@Injectable()
export class isPhonePipe implements PipeTransform<string> {
    transform(phone: string, metadata: ArgumentMetadata): string {
        const validPhone = isPhone(phone);
        if (validPhone) return validPhone;

        throw new BadRequestException(ERROR_NUMBER_PHONE);
    }
}

```

src/module/telegram/pipes/isUrl.pipe.ts:
```
import { BadRequestException, Injectable, PipeTransform } from '@nestjs/common';
import { ERROR_URL_LINK } from '../constants/error.constant';

@Injectable()
export class isUrlPipe implements PipeTransform<string> {
    transform(link: string): string {
        try {
            new URL(link.trim());
            const regex = /\/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\b/gi;
            const match = regex.exec(link.trim());
            if (match) {
                return match[1];
            }
        } catch (err) {
            throw new BadRequestException('Ошибка isUrlPipe');
        }
        throw new BadRequestException(ERROR_URL_LINK);
    }
}

```

src/module/telegram/scenes/base.scene-constant.ts:
```
export const CHANGE_NUMBER_SCENE = 'changeNumberScene';
export const ORDER_SCENE = 'orderScene';
export const CALCULATE_SCENE = 'calculateScene';
export const COOKIE_SCENE = 'getCookieScene';
export const CHECKER_SCENE = 'checkerScene';
export const QR_CODE_SCENE = 'getQrCodeScene';
export const CASH_RECEIPT_SCENE = 'getCashReceiptScene';
export const PROFILE_SCENE = 'profileScene';
export const HELP_SCENE = 'helpScene';
export const AUTH_MIRROR_SCENE = 'authMirrorScene';
export const START_SCENE = 'startScene';
export const ADMIN_SCENE = 'adminScene';

```

src/module/telegram/scenes/calculate.scene-constant.ts:
```
export enum CommissionType {
    BONUS = 'BONUS',
    PROMO = 'PROMO',
    TOTAL = 'TOTAL',
}

export const CALCULATE_SETTINGS_SCENE = 'calculate_settings_scene';
export const TEMPLATE_NAME_SCENE = 'template_name_scene';
export const TEMPLATE_TEXT_SCENE = 'template_text_scene';
export const COMMISSION_TYPE_SCENE = 'commission_type_scene';
export const COMMISSION_RATE_SCENE = 'commission_rate_scene';
export const ROUND_TO_SCENE = 'round_to_scene';
export const CUSTOM_ROUND_SCENE = 'custom_round_scene';

```

src/module/telegram/scenes/change-number.scene-constants.ts:
```
export const CHANGE_NUMBER_INPUT_NUMBER_SCENE = 'changeNumberInputNumberScene';
export const CHANGE_NUMBER_CODE_SCENE = 'changeNumberCodeScene';

```

src/module/telegram/scenes/make-order.scene-constant.ts:
```
export const ORDER_GET_ORDERS_SCENE = 'orderGetOrdersScene';

export const ORDER_INPUT_ARTICLE_SCENE = 'orderInputArticleScene';
export const ORDER_MENU_ACCOUNT_SCENE = 'orderMenuAccountScene';
export const ORDER_MENU_CART_SCENE = 'orderMenuCartScene';

export const ORDER_CITY_SCENE = 'orderCityScene';
export const ORDER_FAVOURITE_CITY_SCENE = 'orderFavouriteCityScene';

export const ORDER_INPUT_LINK_SCENE = 'orderInputLinkScene';
export const ORDER_INPUT_PROMO_SCENE = 'orderInputPromoScene';

export const ORDER_SHOP_SELECTION_SCENE = 'orderShopSelectionScene';

export const ORDER_CHANGE_RECIPIENT_SCENE = 'orderChangeRecipientScene';

```

src/module/telegram/scenes/profile.scene-constant.ts:
```
export const PROFILE_GET_INFO_ORDER = 'profileGetInfoOrder';
export const MAKE_DEPOSIT_SCENE = 'paymentScene';
export const PROMOCODE_BOT_SCENE = 'promocodeBotScene';
export const FORTUNE_BOT_SCENE = 'fortuneBotScene';
export const PAYMENT_PROMOCODE_BOT_SCENE = 'paymentPromocodeBotScene';

```

src/module/telegram/updates/admin/admin.guard.ts:
```
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { TelegrafException, TelegrafExecutionContext } from 'nestjs-telegraf';
import { Context } from 'telegraf';
import { NOT_ADMIN, NOT_ADMIN_LIST } from '../../constants/admin.constant';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class AdminGuard implements CanActivate {
    constructor(private readonly configService: ConfigService) {}

    private TELEGRAM_ADMIN_ID: string[] | undefined;

    async canActivate(context: ExecutionContext): Promise<boolean> {
        this.TELEGRAM_ADMIN_ID = this.configService.getOrThrow('TELEGRAM_ADMIN_ID').split(',');
        if (this.TELEGRAM_ADMIN_ID?.length == 0) {
            throw new TelegrafException(NOT_ADMIN_LIST);
        }
        const ctx = TelegrafExecutionContext.create(context);
        const { from } = ctx.getContext<Context>();

        const isAdmin = this.TELEGRAM_ADMIN_ID!.includes(String(from!.id));
        if (!isAdmin) {
            throw new TelegrafException(NOT_ADMIN);
        }

        return true;
    }
}

```

src/module/telegram/updates/admin/admin.update.ts:
```
import { Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { ADMIN, ALL_KEYS_MENU_BUTTON_NAME } from '../base-command/base-command.constants';
import { TelegramService } from '../../telegram.service';
import { NotFoundException, UseFilters, UseGuards } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { createWriteStream, promises as fsPromises } from 'fs';
import { join } from 'path';
import axios from 'axios';
import { AccountService } from '../../../account/account.service';
import { AdminGuard } from './admin.guard';
import { ERROR_FOUND_USER } from '../../constants/error.constant';
import { UserService } from '../../../user/user.service';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';

@Scene(ADMIN.scene)
@UseFilters(TelegrafExceptionFilter)
export class AdminUpdate {
    constructor(
        private telegramService: TelegramService,
        private accountService: AccountService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    @UseGuards(AdminGuard)
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.reply('Пришли текстовый файл', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('document')
    // @UseGuards(AdminGuard)
    async onDocument(@Message('document') document: any, @Ctx() ctx: WizardContext) {
        const fileId = document.file_id;
        const fileUrl = await ctx.telegram.getFileLink(fileId);
        const filePath = join(process.cwd(), 'downloads', `${document.file_name}`);

        await this.downloadFile(fileUrl.href, filePath);
        const fileContent = await fsPromises.readFile(filePath, 'utf-8');

        const accounts = this.parseFileContent(fileContent);
        await this.addAccounts(accounts);
        await ctx.reply('Аккаунты добавлены');
    }

    private async downloadFile(fileUrl: string, filePath: string): Promise<void> {
        const response = await axios({
            url: fileUrl,
            method: 'GET',
            responseType: 'stream',
        });

        await new Promise((resolve, reject) => {
            const stream = createWriteStream(filePath);
            response.data.pipe(stream);
            stream.on('finish', resolve);
            stream.on('error', reject);
        });
    }

    private parseFileContent(fileContent: string): string[][] {
        return fileContent
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .map(line => line.split('\t'));
    }

    private async addAccounts(accounts: any[][]) {
        for (const account of accounts) {
            let xUserId = account[7];
            if (xUserId.charAt(0) === 'A') {
                xUserId = xUserId.substring(1);
            }
            await this.accountService.addingAccount({
                accountId: account[0],
                email: account[1],
                passImap: account[2],
                passEmail: account[3],
                cookie: account[4],
                accessToken: account[5],
                refreshToken: account[6],
                xUserId,
                deviceId: account[8],
                installationId: account[9],
                expiresIn: '0',
                bonusCount: '0',
                isOnlyAccessOrder: account[10],
                accessTokenCourse: undefined,
                refreshTokenCourse: undefined,
            });
        }
    }
}

```

src/module/telegram/updates/auth-mirror/auth-mirror.update.ts:
```
import { ALL_KEYS_MENU_BUTTON_NAME, AUTH_MIRROR } from '../base-command/base-command.constants';
import { Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { TelegramService } from '../../telegram.service';
import { isAccountIdPipe } from '../../pipes/isAccountId.pipe';
import { NotFoundException, UseFilters, UseGuards } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { ConfigService } from '@nestjs/config';
import { UserService } from '../../../user/user.service';
import { ERROR_FOUND_USER } from '../../constants/error.constant';
import { MirrorService } from '../../../mirror/mirror.service';
import { SellerGuard } from './seller.guard';

@Scene(AUTH_MIRROR.scene)
@UseFilters(TelegrafExceptionFilter)
export class AuthMirrorUpdate {
    private DOMAIN = this.configService.getOrThrow('DOMAIN', 'http://localhost:3001');

    constructor(
        private userService: UserService,
        private telegramService: TelegramService,
        private configService: ConfigService,
        private mirrorService: MirrorService,
    ) {}

    @SceneEnter()
    @UseGuards(SellerGuard)
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId, first_name: telegramName }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        const createdMirror = await this.mirrorService.createAccountMirror(String(telegramId), String(telegramName));
        await ctx.reply('Пройдите авторизацию', {
            reply_markup: {
                inline_keyboard: [
                    [
                        {
                            text: 'Авторизация',
                            web_app: {
                                url: `${this.DOMAIN}/api/webapp/auth?id=${createdMirror.id}`,
                            },
                        },
                    ],
                ],
            },
        });
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async findAccount(@Message('text', new isAccountIdPipe()) accountId: string, @Ctx() ctx: WizardContext) {
        await ctx.reply('Используйте авторизацию по кнопке ⬆️');
        await ctx.scene.leave();
    }
}

```

src/module/telegram/updates/auth-mirror/seller.guard.ts:
```
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { TelegrafException, TelegrafExecutionContext } from 'nestjs-telegraf';
import { Context } from 'telegraf';
import { ERROR_ACCESS } from '../../constants/error.constant';
import { UserService } from '../../../user/user.service';
import { UserRole } from '@prisma/client';

@Injectable()
export class SellerGuard implements CanActivate {
    constructor(private readonly userService: UserService) {}

    async canActivate(context: ExecutionContext): Promise<boolean> {
        const ctx = TelegrafExecutionContext.create(context);
        const { from } = ctx.getContext<Context>();

        const user = await this.userService.getUserByTelegramId(String(from!.id));
        if (!user?.role) throw new TelegrafException(ERROR_ACCESS);

        const isSeller = user.role === UserRole.Admin || user.role === UserRole.Seller;
        if (!isSeller) {
            throw new TelegrafException(ERROR_ACCESS);
        }

        return true;
    }
}

```

src/module/telegram/updates/base-command/base-command.constants.ts:
```
import {
    ADMIN_SCENE,
    AUTH_MIRROR_SCENE,
    CALCULATE_SCENE,
    CASH_RECEIPT_SCENE,
    CHANGE_NUMBER_SCENE,
    CHECKER_SCENE,
    COOKIE_SCENE,
    HELP_SCENE,
    ORDER_SCENE,
    PROFILE_SCENE,
    QR_CODE_SCENE,
    START_SCENE,
} from '../../scenes/base.scene-constant';

export const AUTH_MIRROR = {
    name: '✅ Авторизация',
    scene: AUTH_MIRROR_SCENE,
};

export const CALCULATE_BONUS = {
    name: '💵 Рассчитать стоимость',
    scene: CALCULATE_SCENE,
};

export const CHANGE_NUMBER = {
    name: '📱 Смена',
    scene: CHANGE_NUMBER_SCENE,
};

export const MAKE_ORDER = {
    name: '🛒 Заказ',
    scene: ORDER_SCENE,
};

export const COOKIE = {
    name: '🔑 Выдать Cookie',
    scene: COOKIE_SCENE,
};

export const CHECK = {
    name: '♻️ Чекер',
    scene: CHECKER_SCENE,
};

export const QR_CODE = {
    name: '🪪 Выдать QR',
    scene: QR_CODE_SCENE,
};

export const CASH_RECEIPT = {
    name: '✉️ Выдать чек',
    scene: CASH_RECEIPT_SCENE,
};

export const PROFILE = {
    name: '🏠️ Личный кабинет',
    scene: PROFILE_SCENE,
};

export const HELP = {
    name: '📞 Поддержка',
    scene: HELP_SCENE,
};

export const START = {
    name: '/start',
    scene: START_SCENE,
};

export const ADMIN = {
    name: '/admin',
    scene: ADMIN_SCENE,
};

export const ALL_KEYS_MENU_BUTTON = [
    AUTH_MIRROR,
    CALCULATE_BONUS,
    CHANGE_NUMBER,
    MAKE_ORDER,
    COOKIE,
    CHECK,
    QR_CODE,
    CASH_RECEIPT,
    PROFILE,
    HELP,
    START,
    ADMIN,
];

export const ALL_KEYS_MENU_BUTTON_NAME = ALL_KEYS_MENU_BUTTON.map(item => item.name);
export const getValueKeysMenu = (key: string) => ALL_KEYS_MENU_BUTTON.find(btnObj => key === btnObj.name)?.scene;

```

src/module/telegram/updates/base-command/base-command.update.ts:
```
import { UseFilters, UseGuards } from '@nestjs/common';
import { Ctx, Hears, Message, On, Scene, SceneEnter, Update } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import {
    ADMIN,
    ALL_KEYS_MENU_BUTTON_NAME,
    AUTH_MIRROR,
    CALCULATE_BONUS,
    CASH_RECEIPT,
    CHANGE_NUMBER,
    CHECK,
    COOKIE,
    HELP,
    MAKE_ORDER,
    PROFILE,
    QR_CODE,
    START,
} from './base-command.constants';
import { Context } from '../../interfaces/telegram.context';
import { AdminGuard } from '../admin/admin.guard';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { TelegramService } from '../../telegram.service';
import { ConfigService } from '@nestjs/config';

@Update()
@UseFilters(TelegrafExceptionFilter)
export class BaseUpdate {
    @Hears([START.name])
    async onStart(@Ctx() ctx: Context) {
        await ctx.scene.enter(START.scene);
    }

    @Hears([ADMIN.name])
    @UseGuards(AdminGuard)
    async onAdminCommand(@Ctx() ctx: Context) {
        await ctx.scene.enter(ADMIN.scene);
    }

    @Hears([CHANGE_NUMBER.name])
    async onStartChangeNumber(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CHANGE_NUMBER.scene);
    }

    @Hears([AUTH_MIRROR.name])
    async onStartMirror(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(AUTH_MIRROR.scene);
    }

    @Hears([MAKE_ORDER.name])
    async onStartOrder(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(MAKE_ORDER.scene);
    }

    @Hears([CHECK.name])
    async onStartChecking(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CHECK.scene);
    }

    @Hears([COOKIE.name])
    async onStartCookie(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(COOKIE.scene);
    }

    @Hears([QR_CODE.name])
    async onStartQrCode(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(QR_CODE.scene);
    }

    @Hears([CASH_RECEIPT.name])
    async onStartCashReceipt(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CASH_RECEIPT.scene);
    }

    @Hears([PROFILE.name])
    async onStartProfile(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(PROFILE.scene);
    }

    @Hears([HELP.name])
    async onStartHelp(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(HELP.scene);
    }

    @Hears([CALCULATE_BONUS.name])
    async onStartCalculate(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_BONUS.scene);
    }

    @On('text')
    async unknowCommand(@Ctx() ctx: WizardContext) {
        await ctx.reply(`Неизвестная команда. Введите /start`);
    }
}

@Scene(HELP.scene)
@UseFilters(TelegrafExceptionFilter)
export class HelpUpdate {
    private tgAdmin: string = this.configService.getOrThrow('TG_ADMIN');
    private shopTg: string = this.configService.getOrThrow('SHOP_TELEGRAM');
    constructor(
        private configService: ConfigService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(`Бот для покупки ${this.shopTg}`);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }
}

```

src/module/telegram/updates/calculate/calculate-settings.update.ts:
```
import { Action, Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { ALL_KEYS_MENU_BUTTON_NAME, CALCULATE_BONUS } from '../base-command/base-command.constants';
import { WizardContext } from 'telegraf/typings/scenes';
import { TelegramService } from '../../telegram.service';
import { CalculateService } from './calculate.service';
import { Markup } from 'telegraf';
import { calculateTemplatesKeyboard } from '../../keyboards/calculate.keyboard';
import {
    CALCULATE_SETTINGS_SCENE,
    COMMISSION_RATE_SCENE,
    COMMISSION_TYPE_SCENE,
    CommissionType,
    CUSTOM_ROUND_SCENE,
    ROUND_TO_SCENE,
    TEMPLATE_NAME_SCENE,
    TEMPLATE_TEXT_SCENE,
} from '../../scenes/calculate.scene-constant';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { NotFoundException } from '@nestjs/common';
import { ERROR_FOUND_USER } from '../../constants/error.constant';
import { UserService } from '../../../user/user.service';

@Scene(CALCULATE_SETTINGS_SCENE)
export class CalculateSettingsScene {
    constructor(
        private telegramService: TelegramService,
        private calculateService: CalculateService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const templates = await this.calculateService.getUserTemplates(String(telegramId));

        if (templates.length === 0) {
            await ctx.editMessageText(
                'У вас пока нет шаблонов. Создадим новый шаблон?',
                Markup.inlineKeyboard([
                    [Markup.button.callback('Создать шаблон', 'create_template')],
                    [Markup.button.callback('Назад', 'back_to_calculate')],
                ]),
            );
        } else {
            await ctx.editMessageText('Ваши шаблоны:', calculateTemplatesKeyboard(templates));
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('back_to_calculate')
    async backToCalculate(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_BONUS.scene);
    }

    @Action('create_template')
    async createTemplate(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // Очищаем все данные о текущем создаваемом шаблоне
        await this.telegramService.setDataCache<any>(`template_${telegramId}`, {});
        await ctx.scene.enter(TEMPLATE_NAME_SCENE);
    }

    @Action(/^template_(.+)$/)
    async viewTemplate(@Ctx() ctx: WizardContext) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const templateId = ctx.match[1];
        const template = await this.calculateService.getTemplateById(templateId);

        if (!template) {
            await ctx.editMessageText('Шаблон не найден.');
            return;
        }

        const commissionTypes: Record<CommissionType, string> = {
            BONUS: 'От бонусов',
            PROMO: 'От промокода',
            TOTAL: 'От общей скидки',
        };

        await ctx.editMessageText(
            `Шаблон: ${template.name}\n\n` +
                `Текст шаблона:\n${template.template.replace(/\/n/g, '\n')}\n\n` +
                `Тип комиссии: ${commissionTypes[template.commissionType as CommissionType]}\n` +
                `Ставка комиссии: ${template.commissionRate}%\n` +
                `Округление до: ${template.roundTo}`,
            Markup.inlineKeyboard([
                [Markup.button.callback('Удалить шаблон', `delete_template_${template.id}`)],
                [Markup.button.callback('Назад', 'back_to_settings')],
            ]),
        );
    }

    @Action(/^delete_template_(.+)$/)
    async deleteTemplate(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const templateId = ctx.match[1];
        await this.calculateService.deleteTemplate(templateId, String(telegramId));
        await ctx.editMessageText('Шаблон удален.');
        await this.onSceneEnter(ctx, { id: telegramId });
    }

    @Action('back_to_settings')
    async backToSettings(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        await this.onSceneEnter(ctx, { id: telegramId });
    }
}

@Scene(TEMPLATE_NAME_SCENE)
export class TemplateNameScene {
    constructor(private telegramService: TelegramService) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.editMessageText('Введите название шаблона:');
    }

    @Hears('Отмена')
    async cancel(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_BONUS.scene);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async onNameEntered(@Ctx() ctx: WizardContext, @Message('text') name: string, @Sender() { id: telegramId }: any) {
        const templateData = (await this.telegramService.getDataFromCache<any>(`template_${telegramId}`)) || {};
        templateData.name = name;
        await this.telegramService.setDataCache<any>(`template_${telegramId}`, templateData);

        await ctx.scene.enter(TEMPLATE_TEXT_SCENE);
    }
}

@Scene(TEMPLATE_TEXT_SCENE)
export class TemplateTextScene {
    constructor(private telegramService: TelegramService) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            'Введите текст шаблона.\n\n' +
                'Вы можете использовать следующие переменные:\n' +
                '{payment} - сумма к оплате\n' +
                '{commission} - сумма комиссии\n\n' +
                'Для переноса строки используйте /n\n\n' +
                'Пример:\n' +
                'Здравствуйте./n' +
                'Цена на кассу: {payment}р/n' +
                'Комиссия {commission}р.',
            Markup.keyboard([['Отмена']])
                .oneTime()
                .resize(),
        );
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Hears('Отмена')
    async cancel(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_BONUS.scene);
    }

    @On('text')
    async onTextEntered(@Ctx() ctx: WizardContext, @Message('text') text: string, @Sender() { id: telegramId }: any) {
        if (text === 'Отмена') return;

        // Сохраняем текст шаблона в кеш
        const templateData = (await this.telegramService.getDataFromCache<any>(`template_${telegramId}`)) || {};
        templateData.template = text;
        await this.telegramService.setDataCache<any>(`template_${telegramId}`, templateData);

        // Переходим к следующему шагу
        await ctx.scene.enter(COMMISSION_TYPE_SCENE);
    }
}

@Scene(COMMISSION_TYPE_SCENE)
export class CommissionTypeScene {
    constructor(private telegramService: TelegramService) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            'Выберите тип комиссии:',
            Markup.inlineKeyboard([
                [Markup.button.callback('От бонусов', 'commission_BONUS')],
                [Markup.button.callback('От промокода', 'commission_PROMO')],
                [Markup.button.callback('От общей скидки', 'commission_TOTAL')],
                [Markup.button.callback('Отмена', 'cancel_template')],
            ]),
        );
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('cancel_template')
    async cancel(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_SETTINGS_SCENE);
    }

    @Action(/^commission_(.+)$/)
    async onTypeSelected(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const commissionType = ctx.match[1];

        // Сохраняем тип комиссии в кеш
        const templateData = (await this.telegramService.getDataFromCache<any>(`template_${telegramId}`)) || {};
        templateData.commissionType = commissionType;
        await this.telegramService.setDataCache<any>(`template_${telegramId}`, templateData);

        await ctx.scene.enter(COMMISSION_RATE_SCENE);
    }
}

@Scene(COMMISSION_RATE_SCENE)
export class CommissionRateScene {
    constructor(private telegramService: TelegramService) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            'Введите процент комиссии (например, 15 для 15%):',
            Markup.keyboard([['Отмена']])
                .oneTime()
                .resize(),
        );
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Hears('Отмена')
    async cancel(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(COMMISSION_TYPE_SCENE);
    }

    @On('text')
    async onRateEntered(@Ctx() ctx: WizardContext, @Message('text') text: string, @Sender() { id: telegramId }: any) {
        if (text === 'Отмена') return;

        try {
            const rate = parseFloat(text);
            if (isNaN(rate) || rate < 0 || rate > 100) {
                await ctx.reply('Пожалуйста, введите число от 0 до 100.');
                return;
            }

            // Сохраняем ставку комиссии в кеш
            const templateData = (await this.telegramService.getDataFromCache<any>(`template_${telegramId}`)) || {};
            templateData.commissionRate = rate;
            await this.telegramService.setDataCache<any>(`template_${telegramId}`, templateData);

            // Переходим к следующему шагу
            await ctx.scene.enter(ROUND_TO_SCENE);
        } catch (e) {
            await ctx.reply('Пожалуйста, введите корректное число.');
        }
    }
}

@Scene(ROUND_TO_SCENE)
export class RoundToScene {
    constructor(
        private telegramService: TelegramService,
        private calculateService: CalculateService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            'До какого значения округлять комиссию (10, 50, 100 и т.д.)?',
            Markup.inlineKeyboard([
                [
                    Markup.button.callback('10', 'round_10'),
                    Markup.button.callback('50', 'round_50'),
                    Markup.button.callback('100', 'round_100'),
                ],
                [Markup.button.callback('Другое значение', 'round_other')],
                [Markup.button.callback('Отмена', 'cancel_template')],
            ]),
        );
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('cancel_template')
    async cancel(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_SETTINGS_SCENE);
    }

    @Action(/^round_(\d+)$/)
    async onRoundSelected(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const roundTo = parseInt(ctx.match[1]);
        await this.saveTemplate(ctx, String(telegramId), roundTo);
    }

    @Action('round_other')
    async onCustomRound(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CUSTOM_ROUND_SCENE);
    }

    private async saveTemplate(ctx: WizardContext, telegramId: string, roundTo: number) {
        const templateData = await this.telegramService.getDataFromCache<any>(`template_${telegramId}`);

        if (!templateData || !templateData.name || !templateData.template || !templateData.commissionType || !templateData.commissionRate) {
            await ctx.editMessageText('Что-то пошло не так. Пожалуйста, начните создание шаблона заново.');
            await ctx.scene.enter(CALCULATE_SETTINGS_SCENE);
            return;
        }

        await this.calculateService.createTemplate(
            telegramId,
            templateData.name,
            templateData.template,
            templateData.commissionType,
            templateData.commissionRate,
            roundTo,
        );

        // Очищаем данные о текущем создаваемом шаблоне
        await this.telegramService.setDataCache<any>(`template_${telegramId}`, null);

        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        const keyboard = getMainMenuKeyboard(user.role);

        await ctx.reply('Шаблон успешно создан', keyboard);

        await ctx.scene.enter(CALCULATE_BONUS.scene);
    }

    @Action('back_to_settings')
    async backToSettings(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_SETTINGS_SCENE);
    }
}

@Scene(CUSTOM_ROUND_SCENE)
export class CustomRoundScene {
    constructor(
        private telegramService: TelegramService,
        private calculateService: CalculateService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            'Введите значение для округления:',
            Markup.keyboard([['Отмена']])
                .oneTime()
                .resize(),
        );
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Hears('Отмена')
    async cancel(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ROUND_TO_SCENE);
    }

    @On('text')
    async onCustomRoundEntered(@Ctx() ctx: WizardContext, @Message('text') text: string, @Sender() { id: telegramId }: any) {
        if (text === 'Отмена') return;

        try {
            const roundTo = parseInt(text);
            if (isNaN(roundTo) || roundTo <= 0) {
                await ctx.editMessageText('Пожалуйста, введите положительное целое число.');
                return;
            }

            const templateData = await this.telegramService.getDataFromCache<any>(`template_${telegramId}`);

            if (
                !templateData ||
                !templateData.name ||
                !templateData.template ||
                !templateData.commissionType ||
                !templateData.commissionRate
            ) {
                await ctx.editMessageText('Что-то пошло не так. Пожалуйста, начните создание шаблона заново.');
                await ctx.scene.enter(CALCULATE_SETTINGS_SCENE);
                return;
            }

            await this.calculateService.createTemplate(
                telegramId,
                templateData.name,
                templateData.template,
                templateData.commissionType,
                templateData.commissionRate,
                roundTo,
            );

            // Очищаем данные о текущем создаваемом шаблоне
            await this.telegramService.setDataCache<any>(`template_${telegramId}`, null);

            const user = await this.userService.getUserByTelegramId(String(telegramId));
            if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

            const keyboard = getMainMenuKeyboard(user.role);

            await ctx.reply('Шаблон успешно создан', keyboard);

            await ctx.scene.enter(CALCULATE_BONUS.scene);
        } catch (e) {
            await ctx.reply('Пожалуйста, введите корректное число.');
        }
    }

    @Action('back_to_calculate')
    async backToSettings(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_BONUS.scene);
    }
}

```

src/module/telegram/updates/calculate/calculate.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';

@Injectable()
export class CalculateRepository {
    constructor(private readonly prisma: PrismaService) {}

    async getUserTemplates(userTelegramId: string) {
        return this.prisma.userTemplate.findMany({
            where: { userTelegramId },
            orderBy: { createdAt: 'desc' },
        });
    }

    async createTemplate(
        userTelegramId: string,
        name: string,
        template: string,
        commissionType: string,
        commissionRate: number,
        roundTo: number,
    ) {
        return this.prisma.userTemplate.create({
            data: {
                name,
                template,
                commissionType,
                commissionRate,
                roundTo,
                userTelegram: {
                    connect: { telegramId: userTelegramId },
                },
            },
        });
    }

    async deleteTemplate(id: string, userTelegramId: string) {
        return this.prisma.userTemplate.deleteMany({
            where: {
                id,
                userTelegramId,
            },
        });
    }

    async getTemplateById(id: string) {
        return this.prisma.userTemplate.findUnique({
            where: { id },
        });
    }
}

```

src/module/telegram/updates/calculate/calculate.service.ts:
```
import { Injectable } from '@nestjs/common';
import { CalculateRepository } from './calculate.repository';
import { UserTemplate } from '@prisma/client';
import { CommissionType } from '../../scenes/calculate.scene-constant';

@Injectable()
export class CalculateService {
    constructor(private readonly calculateRepository: CalculateRepository) {}

    async getUserTemplates(userTelegramId: string): Promise<UserTemplate[]> {
        return this.calculateRepository.getUserTemplates(userTelegramId);
    }

    async createTemplate(
        userTelegramId: string,
        name: string,
        template: string,
        commissionType: CommissionType,
        commissionRate: number,
        roundTo: number = 10,
    ): Promise<UserTemplate> {
        return this.calculateRepository.createTemplate(userTelegramId, name, template, commissionType, commissionRate, roundTo);
    }

    async deleteTemplate(id: string, userTelegramId: string): Promise<void> {
        await this.calculateRepository.deleteTemplate(id, userTelegramId);
    }

    async getTemplateById(id: string): Promise<UserTemplate | null> {
        return this.calculateRepository.getTemplateById(id);
    }

    calculateCommission(
        commissionType: string,
        commissionRate: number,
        roundTo: number,
        totalBonus: number,
        totalPromo: number,
        totalDiscount: number,
    ): number {
        let baseAmount = 0;

        switch (commissionType) {
            case 'BONUS':
                baseAmount = totalBonus;
                break;
            case 'PROMO':
                baseAmount = totalPromo;
                break;
            case 'TOTAL':
            default:
                baseAmount = totalDiscount;
                break;
        }

        // Рассчитываем комиссию
        let commission = baseAmount * (commissionRate / 100);

        // Округляем до указанного порога (roundTo)
        if (commission % roundTo !== 0) {
            commission = Math.ceil(commission / roundTo) * roundTo;
        }

        return Math.floor(commission);
    }

    applyTemplate(template: string, totalPrice: number, commission: number): string {
        return template
            .replace(/{payment}/g, totalPrice.toString())
            .replace(/{commission}/g, commission.toString())
            .replace(/\/n/g, '\n');
    }
}

```

src/module/telegram/updates/calculate/calculate.update.ts:
```
import { Action, Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { ALL_KEYS_MENU_BUTTON_NAME, CALCULATE_BONUS } from '../base-command/base-command.constants';
import { WizardContext } from 'telegraf/typings/scenes';
import { TelegramService } from '../../telegram.service';
import { calculateInfoKeyboard } from '../../keyboards/calculate.keyboard';
import { CalculateService } from './calculate.service';
import { Markup } from 'telegraf';
import { CALCULATE_SETTINGS_SCENE } from '../../scenes/calculate.scene-constant';
import { ICalculateCash } from '../../interfaces/calculate.interface';

@Scene(CALCULATE_BONUS.scene)
export class CalculateUpdate {
    constructor(
        private telegramService: TelegramService,
        private calculateService: CalculateService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply('🔑 Введите цены вещей', calculateInfoKeyboard);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('go_to_calculate_info')
    async goToCalculateInfo(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            `Цены на вещи вводим каждую с новой строки.\nВводим изначальную цену, БЕЗ УЧЕТА СКИДКИ.\nЕсли товар - инвентарь, велосипед, палатка, то к цене без пробела делаем приписку буквы - и.\nЕсли на товар установлена скидка от магазина, то через пробел указываем какая.\nЕсли товар по лучшей/финальной/желтой цене, то через пробел пишем букву л (или любую другую)\nНапример:\n7299 35\n8999\n6499 70\n7499 л\n2400и 20\n10000и`,
        );
    }

    @Action('go_to_calculate_settings')
    async goToCalculateSettings(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(CALCULATE_SETTINGS_SCENE);
    }

    @On('text')
    async calculatePrice(@Ctx() ctx: WizardContext, @Message('text') inputPrices: string, @Sender() { id: telegramId }: any) {
        try {
            const prices: string[] = inputPrices.split(/\r?\n/);

            let totalDiscountPromo = 0;
            let totalPricePromo = 0;

            let totalDiscount = 0;
            let totalPrice = 0;

            let priceWithoutDiscount = 0;

            const outputPrices = [];

            for (let value of prices) {
                let isInventory = false;

                let discountShop = 0;
                value = value.trim();
                const parts = value.split(' ');
                if (parts.length > 1) {
                    discountShop = /^\d+$/.test(parts[1]) ? parseInt(parts[1]) : 228;
                }

                if (parts[0].includes('и')) {
                    isInventory = true;
                    parts[0] = parts[0].split('и')[0];
                }

                const priceItem = parseInt(parts[0]);

                const currentPriceItem = this.calculateCurrentPrice(priceItem, discountShop);
                const currentBonus = this.calculateBonus(priceItem, currentPriceItem, discountShop, isInventory);
                const priceDiscount = currentPriceItem - currentBonus;

                priceWithoutDiscount += currentPriceItem;

                const currentPriceItemPromo = this.calculatePriceWithPromoWithoutBonus(
                    priceItem,
                    currentPriceItem,
                    discountShop,
                    isInventory,
                );

                const currentBonusPromo = this.calculateBonus(priceItem, currentPriceItemPromo, discountShop, isInventory);
                const priceDiscountPromo = currentPriceItemPromo - currentBonusPromo;

                totalPrice += priceDiscount;
                totalDiscount += currentBonus;

                totalPricePromo += priceDiscountPromo;
                totalDiscountPromo += currentBonusPromo;

                const priceStr = parts.length > 1 ? `${parts[0]} ${parts[1]}` : `${parts[0]}`;

                outputPrices.push({
                    price: priceStr,
                    priceDiscount,
                    currentBonus,
                    currentBonusPromo,
                    priceDiscountPromo,
                });
            }

            const totalFullDiscountTmp = priceWithoutDiscount - totalPricePromo;

            // Сохраняем результаты расчетов в кеш
            const calculationResult: ICalculateCash = {
                outputPrices,
                totalPrice,
                totalDiscount,
                totalPriceBonus: totalDiscountPromo,
                totalDiscountPromo: totalFullDiscountTmp - totalDiscountPromo,
                totalFullDiscount: totalFullDiscountTmp,
                totalSumOnKassa: totalPricePromo,
            };

            await this.telegramService.setDataCache<ICalculateCash>(String(telegramId), calculationResult);

            // Получаем шаблоны пользователя для отображения в клавиатуре
            const templates = await this.calculateService.getUserTemplates(String(telegramId));

            const keyboardButtons = [[Markup.button.callback(`Показать расчет индивидуально`, `go_to_calculate_show`)]];

            // Если есть шаблоны, добавляем их в клавиатуру
            if (templates.length > 0) {
                const templateButtons = templates.map((template: { name: any; id: any }) =>
                    Markup.button.callback(`Шаблон: ${template.name}`, `use_template_${template.id}`),
                );
                keyboardButtons.push(templateButtons);
            }

            await ctx.reply(
                `Расчет без промо:
Цена на кассу: ${totalPrice}
Количество возможно примененных бонусов: ${totalDiscount}
                        
Расчет с промо:
Цена на кассу: ${totalPricePromo}
Количество возможно примененных бонусов: ${totalDiscountPromo}
Общая скидка (бонусы + промо): ${priceWithoutDiscount - totalPricePromo}`,
                Markup.inlineKeyboard(keyboardButtons),
            );
        } catch (e) {
            await ctx.reply('Что то пошло не так. Проверьте правильность введения');
        }
    }

    @Action('go_to_calculate_show')
    async goToCalculateShow(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const calculationResult = await this.telegramService.getDataFromCache<any>(String(telegramId));

        if (!calculationResult || !calculationResult.outputPrices) {
            await ctx.reply('Данные расчета не найдены. Пожалуйста, сделайте новый расчет.');
            return;
        }

        let message = '';
        calculationResult.outputPrices.forEach((value: { [x: string]: any }) => {
            message += `Изначальная цена: ${value['price']}\nТекущая цена со скидкой: ${value['priceDiscount']}\nКоличество возможно примененных бонусов: ${value['currentBonus']}\n\n`;
        });
        await ctx.reply(message);
    }

    @Action(/^use_template_(.+)$/)
    async useTemplate(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const templateId = ctx.match[1];
        const template = await this.calculateService.getTemplateById(templateId);

        if (!template) {
            await ctx.reply('Шаблон не найден.');
            return;
        }

        const calculationResult = await this.telegramService.getDataFromCache<ICalculateCash>(String(telegramId));

        if (!calculationResult) {
            await ctx.reply('Данные расчета не найдены. Пожалуйста, сделайте новый расчет.');
            return;
        }

        // Рассчитываем комиссию в зависимости от настроек шаблона
        const commission = this.calculateService.calculateCommission(
            template.commissionType,
            template.commissionRate,
            template.roundTo,
            calculationResult.totalPriceBonus,
            calculationResult.totalDiscountPromo,
            calculationResult.totalFullDiscount,
        );

        // Применяем шаблон
        const message = this.calculateService.applyTemplate(template.template, calculationResult.totalSumOnKassa, commission);

        await ctx.reply(`<code>${message}</code>`, {
            parse_mode: 'HTML',
        });
    }

    private calculateCurrentPrice(price: number, discountShop: number) {
        if (discountShop === 228) {
            return price;
        }

        let currentPriceItem = (1 - discountShop / 100) * price;
        if (discountShop % 5 !== 0) {
            const lastNumberPrice = currentPriceItem % 100;
            const roundPrice = Math.floor(currentPriceItem / 100) * 100;
            currentPriceItem = lastNumberPrice < 50 ? roundPrice - 1 : roundPrice + 99;
        }

        return Math.floor(currentPriceItem);
    }

    private calculateBonus(price: number, currentPriceItem: number, discountShop: number, isInventory: boolean = false) {
        let currentBonus = 0;

        if (0 <= discountShop && discountShop < 50) {
            // Используем 20% вместо 30% для инвентаря
            const bonusPercentage = isInventory ? 0.2 : 0.3;
            currentBonus = currentPriceItem * bonusPercentage;

            // Максимальная скидка 30% для инвентаря, 50% для обычных товаров
            const maxDiscountFactor = isInventory ? 0.3 : 0.5;
            const maxDiscountItem = price * maxDiscountFactor;

            if (currentPriceItem - currentBonus < price - maxDiscountItem) {
                currentBonus = currentPriceItem - (price - maxDiscountItem);
            }
        }
        return Math.floor(currentBonus);
    }

    private calculatePriceWithPromoWithoutBonus(
        price: number,
        currentPriceItem: number,
        discountShop: number,
        isInventory: boolean = false,
    ) {
        let calcPrice = currentPriceItem;

        if (0 <= discountShop && discountShop < 50) {
            const priceWithPromo = currentPriceItem * 0.9;

            // Максимальная скидка 30% для инвентаря, 50% для обычных товаров
            const maxDiscountFactor = isInventory ? 0.3 : 0.5;
            const maxDiscountItem = price * maxDiscountFactor;

            if (price - priceWithPromo > maxDiscountItem) {
                calcPrice = price - maxDiscountItem;
            } else {
                calcPrice = priceWithPromo;
            }
        }
        return Math.floor(calcPrice);
    }
}

```

src/module/telegram/updates/change-number/change-number.update.ts:
```
import { Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { ALL_KEYS_MENU_BUTTON_NAME, CHANGE_NUMBER } from '../base-command/base-command.constants';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { AccountService } from '../../../account/account.service';
import { isAccountIdPipe } from '../../pipes/isAccountId.pipe';
import { CHANGE_NUMBER_CODE_SCENE, CHANGE_NUMBER_INPUT_NUMBER_SCENE } from '../../scenes/change-number.scene-constants';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { TelegramService } from '../../telegram.service';
import { isPhonePipe } from '../../pipes/isPhone.pipe';
import { isCodePipe } from '../../pipes/isCode.pipe';
import { Context } from '../../interfaces/telegram.context';
import { UserService } from '../../../user/user.service';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { ERROR_FOUND_USER } from '../../constants/error.constant';

@Scene(CHANGE_NUMBER.scene)
@UseFilters(TelegrafExceptionFilter)
export class ChangeNumberUpdate {
    constructor(
        private telegramService: TelegramService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: Context, @Sender() telegramUser: any) {
        // в будующем удалить регу или обновление юзера
        const { first_name: telegramName, id: telegramId } = telegramUser;
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        await this.userService.createOrUpdateUserByTelegram({
            telegramName,
            telegramId: String(telegramId),
        });

        await ctx.reply('🔑 Введите номер вашего аккаунта:', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async findAccount(
        @Message('text', new isAccountIdPipe()) accountId: string,
        @Sender() { id: telegramId }: any,
        @Ctx() ctx: WizardContext,
    ) {
        await this.telegramService.setTelegramAccountCache(telegramId, accountId);
        await ctx.scene.enter(CHANGE_NUMBER_INPUT_NUMBER_SCENE);
    }
}

@Scene(CHANGE_NUMBER_INPUT_NUMBER_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class ChangeNumberInputNumber {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(String(telegramId));

        const shortInfo = await this.accountService.shortInfo(account.accountId);
        const text = `📱 Аккаунт найден. Баланс: ${shortInfo.bonusCount}.\nВведите номер телефона, на который хотите перепривязать его`;
        await ctx.reply(text);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputPhoneNumber(
        @Message('text', new isPhonePipe()) phoneNumber: string,
        @Ctx() ctx: WizardContext,
        @Sender() { id: telegramId }: any,
    ) {
        const account = await this.telegramService.getFromCache(String(telegramId));
        account.requestId = await this.accountService.sendSmsWithAnalytics(account.accountId, phoneNumber);
        await ctx.scene.enter(CHANGE_NUMBER_CODE_SCENE);
    }
}

@Scene(CHANGE_NUMBER_CODE_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class ChangeNumberInputCode {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply(
            'Код выслан на указанный номер. Отправьте его в чат. Если код не пришел, то проблема в номере, используйте другой, ранее не использованный в Спортмастер. У вас есть 3 попытки отправки кода в день',
        );
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputCodePhoneNumber(
        @Message('text', new isCodePipe()) code: string,
        @Ctx() ctx: WizardContext,
        @Sender() { id: telegramId }: any,
    ) {
        const account = await this.telegramService.getFromCache(String(telegramId));
        await this.accountService.phoneChange(account.accountId, account.requestId, code);
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.reply('✅ Номер успешно изменен. Можете авторизоваться в аккаунт', getMainMenuKeyboard(user.role));
        await ctx.scene.leave();
    }
}

```

src/module/telegram/updates/checking/checking.service.ts:
```
import { Injectable, NotFoundException } from '@nestjs/common';
import { AccountService } from '../../../account/account.service';
import validate from 'uuid-validate';
import { AxiosError } from 'axios';
import { addDays, isBefore, parseISO } from 'date-fns';
import * as path from 'node:path';
import * as fs from 'node:fs';

interface IOutputBonusDate {
    amount: number;
    date: string;
}

interface IBonusDetail {
    bonusType: string;
    amount: number;
    dateEnd: string;
}

@Injectable()
export class CheckingService {
    private readonly TIMEOUT = 15000;

    constructor(private readonly accountService: AccountService) {}

    async checkingAccounts(accounts: string[]): Promise<string[]> {
        return this.checkAccounts(accounts, this.processCheckingAccount.bind(this));
    }

    async checkingAccountsOnPromocodes(accounts: string[]): Promise<string[]> {
        return this.checkAccounts(accounts, this.processCheckingAccountOnPromocode.bind(this));
    }

    private async checkAccounts(
        accounts: string[],
        processAccount: (resultChecking: Record<string, string>, accountId: string) => Promise<void>,
    ): Promise<string[]> {
        const resultChecking: Record<string, string> = {};
        const accountChunks = this.chunkArray(accounts, 5);

        for (const chunk of accountChunks) {
            await Promise.all(chunk.map(account => this.processWithTimeout(processAccount, resultChecking, account)));
        }

        return this.bringCompliance(resultChecking, accounts);
    }

    private chunkArray<T>(array: T[], chunkSize: number): T[][] {
        const chunks: T[][] = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }

    private async processWithTimeout(
        processAccount: (resultChecking: Record<string, string>, accountId: string) => Promise<void>,
        resultChecking: Record<string, string>,
        accountId: string,
    ): Promise<void> {
        const timeoutPromise = new Promise<void>((_, reject) =>
            setTimeout(() => reject(new Error(`Timeout: ${accountId} took too long to process`)), this.TIMEOUT),
        );

        try {
            await Promise.race([processAccount(resultChecking, accountId), timeoutPromise]);
        } catch (error: any) {
            resultChecking[accountId] = `${accountId}: Ошибка тайм-аута\n`;
        }
    }

    private async processCheckingAccount(resultChecking: Record<string, string>, accountId: string): Promise<void> {
        const trimmedAccountId = accountId.trim();
        if (trimmedAccountId.length === 0) return;

        if (!validate(trimmedAccountId)) {
            resultChecking[trimmedAccountId] = `${trimmedAccountId}: Неверный формат\n`;
            return;
        }

        try {
            const { bonusCount, bonusDetails } = await this.accountService.shortInfo(trimmedAccountId);
            await this.accountService.orderHistory(trimmedAccountId);
            let result = `${trimmedAccountId}: ${bonusCount}`;
            const uniqueBonuses = new Set<string>();

            const filteredBonusDetails = bonusDetails.filter(detail => detail.amount >= 100);
            const firstBonusDate = this.getCombustionDates(filteredBonusDetails);

            if (firstBonusDate) {
                const { amount: firstAmount, date: firstDate } = firstBonusDate;
                const firstBonusString = `${firstDate} - ${firstAmount}`;
                uniqueBonuses.add(firstBonusString);
                result += ` ${firstBonusString}`;

                const secondBonusDate = this.getCombustionDates(filteredBonusDetails, firstDate);
                if (secondBonusDate) {
                    const { amount: secondAmount, date: secondDate } = secondBonusDate;
                    const secondBonusString = `${secondDate} - ${secondAmount}`;
                    if (!uniqueBonuses.has(secondBonusString)) {
                        uniqueBonuses.add(secondBonusString);
                        result += ` ${secondBonusString}`;
                    }
                }
            }

            resultChecking[trimmedAccountId] = result + '\n';
        } catch (err: any) {
            this.handleError(err, trimmedAccountId, resultChecking);
        }
    }

    private bringCompliance(resultChecking: Record<string, string>, accounts: string[]): string[] {
        return accounts.map(account => {
            const trimmedAccount = account.trim();
            if (trimmedAccount === '') return '\n';
            return resultChecking[trimmedAccount];
        });
    }

    private getCombustionDates(data: IBonusDetail[], previousDate?: string): IOutputBonusDate | null {
        const threeWeeksFromNow = addDays(new Date(), 21);

        for (const detail of data) {
            const dateObject = parseISO(detail.dateEnd);

            if (isBefore(dateObject, threeWeeksFromNow)) {
                if (previousDate && isBefore(parseISO(previousDate), dateObject)) {
                    continue;
                }
                const formattedDate = dateObject
                    .toLocaleDateString('en-GB', {
                        day: '2-digit',
                        month: '2-digit',
                    })
                    .replace(/\//g, '/');

                return {
                    amount: detail.amount,
                    date: formattedDate,
                };
            }
        }
        return null;
    }

    private handleError(err: any, accountId: string, resultChecking: Record<string, string>): void {
        const logFilePath = path.join(__dirname, 'error_log.txt');

        if (err instanceof NotFoundException) {
            resultChecking[accountId] = `${accountId}: Не найден\n`;
        } else if (err instanceof AxiosError) {
            try {
                const errorResponse = err.response?.data?.error;

                if (errorResponse?.message) {
                    const errorMessage = `${new Date().toISOString()} - Account ID: ${accountId} - Axios Error: ${JSON.stringify(errorResponse, null, 2)}\n`;
                    fs.appendFileSync(logFilePath, errorMessage, 'utf8');

                    resultChecking[accountId] = `${accountId}: ${errorResponse.message}\n`;
                } else {
                    const errorMessage = `${new Date().toISOString()} - Account ID: ${accountId} - Axios Error: ${JSON.stringify(err.response?.data || err.toJSON(), null, 2)}\n`;
                    fs.appendFileSync(logFilePath, errorMessage, 'utf8');

                    resultChecking[accountId] = `${accountId}: Ошибка запроса, повторите\n`;
                }
            } catch (writeError: any) {
                const writeErrorMessage = `${new Date().toISOString()} - Account ID: ${accountId} - Write Error: ${writeError.message}\n`;
                fs.appendFileSync(logFilePath, writeErrorMessage, 'utf8');

                resultChecking[accountId] = `${accountId}: Ошибка запроса, повторите\n`;
            }
        } else {
            try {
                const errorMessage = `${new Date().toISOString()} - Account ID: ${accountId} - Error: ${err.message}\n`;
                fs.appendFileSync(logFilePath, errorMessage, 'utf8');
                resultChecking[accountId] = `${accountId}: ${err.message || 'Неизвестная ошибка'}\n`;
            } catch (writeError: any) {
                const writeErrorMessage = `${new Date().toISOString()} - Account ID: ${accountId} - Write Error: ${writeError.message}\n`;
                fs.appendFileSync(logFilePath, writeErrorMessage, 'utf8');
                resultChecking[accountId] = `${accountId}: Неизвестная ошибка\n`;
            }
        }
    }

    private async processCheckingAccountOnPromocode(resultChecking: Record<string, string>, accountId: string): Promise<void> {
        const trimmedAccountId = accountId.trim();
        if (trimmedAccountId.length === 0) return;

        if (!validate(trimmedAccountId)) {
            resultChecking[trimmedAccountId] = `${trimmedAccountId}: Неверный формат\n`;
            return;
        }

        try {
            const { data } = await this.accountService.getPromocodeFromProfile(trimmedAccountId);
            const accountInfo = `${trimmedAccountId}: `;
            let promocodes = '';

            for (const promo of data.list) {
                const actionName = promo.actionName;
                if (
                    actionName === 'Скидка 10% на первый онлайн заказ' ||
                    actionName === '-15% на туризм и рыбалку' ||
                    actionName === '-15% на обувь для горного туризма' ||
                    actionName === '-20% на фитнес-аксессуары'
                ) {
                    continue;
                }
                if (actionName === '-10% по промокоду на онлайн-покупку') {
                    const textLegal = promo.textLegal;
                    if (textLegal && textLegal.includes('Промокод не суммируется')) {
                        continue;
                    }
                }
                const promoId = promo.promoId;
                const dateEnd = promo.dateEnd;
                promocodes += `${actionName} <b><code>${promoId}</code></b> ${dateEnd} `;
            }

            resultChecking[trimmedAccountId] = accountInfo + (promocodes || 'Нет промо') + '\n';
        } catch (err: any) {
            this.handleError(err, trimmedAccountId, resultChecking);
        }
    }
}

```

src/module/telegram/updates/checking/checking.update.ts:
```
import { Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { TelegramService } from '../../telegram.service';
import { WizardContext } from 'telegraf/typings/scenes';
import { ALL_KEYS_MENU_BUTTON_NAME, CHECK } from '../base-command/base-command.constants';
import { CheckingService } from './checking.service';
import { UserService } from '../../../user/user.service';
import { Context } from '../../interfaces/telegram.context';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { ERROR_FOUND_USER } from '../../constants/error.constant';

@Scene(CHECK.scene)
@UseFilters(TelegrafExceptionFilter)
export class CheckingUpdate {
    constructor(
        private checkingService: CheckingService,
        private telegramService: TelegramService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: Context, @Sender() telegramUser: any) {
        // в будующем удалить регу или обновление юзера
        const { first_name: telegramName, id: telegramId } = telegramUser;
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        await this.userService.createOrUpdateUserByTelegram({
            telegramName,
            telegramId: String(telegramId),
        });

        await ctx.reply('Пришлите номера аккаунтов, каждый с новой строки. За раз не больше 20', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputAccounts(@Message('text') inputAccounts: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        const allAccounts = inputAccounts.split('\n');
        const accounts = allAccounts.slice(0, 22);
        const extraAccounts = allAccounts.slice(22);

        if (extraAccounts.length > 0) {
            await ctx.reply(`Следующие аккаунты не вместились, отправьте их ещё раз:\n${extraAccounts.join('\n')}`);
        }

        await ctx.reply('Началась проверка');
        const checkedAccounts = await this.checkingService.checkingAccounts(accounts);
        await ctx.reply(checkedAccounts.join(''), getMainMenuKeyboard(user.role));
    }
}

```

src/module/telegram/updates/cookie/cookie.update.ts:
```
import { ALL_KEYS_MENU_BUTTON_NAME, COOKIE } from '../base-command/base-command.constants';
import { Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { AccountService } from '../../../account/account.service';
import { WizardContext } from 'telegraf/typings/scenes';
import { TelegramService } from '../../telegram.service';
import { isAccountIdPipe } from '../../pipes/isAccountId.pipe';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { UserService } from '../../../user/user.service';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { ERROR_FOUND_USER } from '../../constants/error.constant';

@Scene(COOKIE.scene)
@UseFilters(TelegrafExceptionFilter)
export class CookieUpdate {
    constructor(
        private accountService: AccountService,
        private userService: UserService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.reply('🔑 Введите номер вашего аккаунта:', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async findAccount(@Message('text', new isAccountIdPipe()) accountId: string, @Ctx() ctx: WizardContext) {
        const account = await this.accountService.getAccount(accountId);
        await ctx.reply(account.getBaseCookie());
    }
}

```

src/module/telegram/updates/email/email.service.ts:
```
import { Injectable, Logger } from '@nestjs/common';
import Imap from 'imap';
import { simpleParser } from 'mailparser';

@Injectable()
export class EmailService {
    private readonly logger = new Logger(EmailService.name);

    private readonly receiptSubjectPatterns: RegExp[] = [/Электронный чек/, /Кассовый чек/];

    private readonly receiptLinkPatterns: RegExp[] = [
        /https:\/\/consumer\.1-ofd\.ru\/v1\?.*?t=\d+T\d+&s=\d+&fn=\d+&i=\d+&fp=\d+&n=1/g,
        /https:\/\/ofd\.ru\/b\/[a-fA-F0-9]{32}/g,
    ];

    public async findEmailCashReceipt(email: string, password: string): Promise<{ subject: string; links: string[] }[]> {
        const hostServer = email.includes('rambler.ru') ? 'imap.rambler.ru' : 'imap.mail.ru';

        return new Promise((resolve, reject) => {
            const imap = new Imap({
                user: email,
                password,
                host: hostServer,
                port: 993,
                tls: true,
                tlsOptions: { rejectUnauthorized: false },
            });

            const results: { subject: string; links: string[] }[] = [];

            imap.once('ready', async () => {
                try {
                    const mailboxes = await this.listMailboxes(imap);
                    for (const mailbox of mailboxes) {
                        await this.openMailbox(imap, mailbox);
                        const messageIds = await this.searchMessages(imap);
                        for (const id of messageIds) {
                            await this.processMessage(imap, id, results);
                        }
                    }

                    resolve(results.filter(result => result.links.length > 0));
                } catch (error) {
                    this.logger.error('Error during IMAP operations:', error);
                    reject(error);
                } finally {
                    imap.end();
                }
            });

            imap.once('error', (error: any) => {
                this.logger.error('IMAP Error:', error);
                reject(error);
            });

            imap.once('end', () => {
                this.logger.log('IMAP connection closed');
            });

            imap.connect();
        });
    }

    private async processMessage(imap: Imap, messageId: number, results: { subject: string; links: string[] }[]): Promise<void> {
        const fetch = imap.fetch(messageId, { bodies: '' });

        return new Promise((resolve, reject) => {
            fetch.on('message', msg => {
                let rawMessage = '';

                msg.on('body', stream => {
                    stream.on('data', chunk => {
                        rawMessage += chunk.toString('utf8');
                    });
                });

                msg.once('end', async () => {
                    try {
                        const parsed = await simpleParser(rawMessage);
                        if (parsed.subject && this.isReceiptSubject(parsed.subject)) {
                            const content = [parsed.subject, parsed.text || '', parsed.html || ''].join('\n');
                            const links = this.extractLinks(content);

                            if (parsed.html) {
                                links.push(...this.extractLinksFromHtml(parsed.html));
                            }

                            const filteredLinks = this.filterValidLinks(links);

                            if (filteredLinks.length > 0) {
                                results.push({
                                    subject: parsed.subject,
                                    links: [...new Set(filteredLinks)], // Remove duplicates
                                });
                            }
                        }
                    } catch (error) {
                        this.logger.error('Error parsing message:', error);
                    } finally {
                        resolve();
                    }
                });
            });

            fetch.once('error', error => {
                this.logger.error('Fetch error:', error);
                reject(error);
            });

            fetch.once('end', () => {
                resolve();
            });
        });
    }

    private isReceiptSubject(subject: string): boolean {
        return this.receiptSubjectPatterns.some(pattern => pattern.test(subject));
    }

    private extractLinks(content: string): string[] {
        const links: string[] = [];
        for (const pattern of this.receiptLinkPatterns) {
            links.push(...(content.match(pattern) || []));
        }
        return links;
    }

    private extractLinksFromHtml(html: string): string[] {
        const hrefPattern = /href=["'](https?:\/\/[^"'>]+)["']/g;
        const links: string[] = [];
        let match;
        while ((match = hrefPattern.exec(html)) !== null) {
            links.push(match[1]);
        }
        return links;
    }

    private filterValidLinks(links: string[]): string[] {
        return links.map(link => this.normalizeLink(link)).filter(link => this.receiptLinkPatterns.some(pattern => pattern.test(link)));
    }

    private normalizeLink(link: string): string {
        return link.replace(/&amp;/g, '&');
    }

    private listMailboxes(imap: Imap): Promise<string[]> {
        return new Promise((resolve, reject) => {
            imap.getBoxes((err, boxes) => {
                if (err) return reject(err);
                resolve(Object.keys(boxes));
            });
        });
    }

    private openMailbox(imap: Imap, mailbox: string): Promise<void> {
        return new Promise((resolve, reject) => {
            imap.openBox(mailbox, false, err => {
                if (err) return reject(err);
                resolve();
            });
        });
    }

    private searchMessages(imap: Imap): Promise<number[]> {
        return new Promise((resolve, reject) => {
            imap.search(['ALL'], (err, results) => {
                if (err) return reject(err);
                resolve(results || []);
            });
        });
    }
}

```

src/module/telegram/updates/email/email.update.ts:
```
import { Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { ALL_KEYS_MENU_BUTTON_NAME, CASH_RECEIPT } from '../base-command/base-command.constants';
import { EmailService } from './email.service';
import { AccountService } from '../../../account/account.service';
import { TelegramService } from '../../telegram.service';
import { isAccountIdPipe } from '../../pipes/isAccountId.pipe';
import { ERROR_ACCOUNT_NOT_FOUND } from '../../../account/constants/error.constant';
import { ERROR_FOUND_USER } from '../../constants/error.constant';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { UserService } from '../../../user/user.service';

@Scene(CASH_RECEIPT.scene)
@UseFilters(TelegrafExceptionFilter)
export class EmailUpdate {
    constructor(
        private accountService: AccountService,
        private userService: UserService,
        private emailService: EmailService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.reply('🔑 Введите номер вашего аккаунта:', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async findAccount(@Message('text', new isAccountIdPipe()) accountId: string, @Ctx() ctx: WizardContext) {
        const account = await this.accountService.findAccountEmail(accountId);
        if (!account) throw new NotFoundException(ERROR_ACCOUNT_NOT_FOUND);

        await ctx.reply('Начался поиск, подождите');

        const cashReceipt = await this.emailService.findEmailCashReceipt(account.email, account.passImap);

        if (cashReceipt.length == 0) {
            await ctx.reply('❌ Чеков не найдено');
        }

        for (const subject of cashReceipt) {
            for (const receipt of subject.links) {
                await ctx.reply(receipt);
            }
        }
    }
}

```

src/module/telegram/updates/fortune/fortune.update.ts:
```
import { Action, Ctx, Hears, Message, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { FORTUNE_BOT_SCENE } from '../../scenes/profile.scene-constant';
import { UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { TelegramService } from '../../telegram.service';
import { WizardContext } from 'telegraf/typings/scenes';
import { ALL_KEYS_MENU_BUTTON_NAME } from '../base-command/base-command.constants';
import { getSurprise } from '../../keyboards/profile.keyboard';
import { FortuneCouponService } from '../../../coupon/fortune-coupon.service';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { SenderTelegram } from '../../interfaces/telegram.context';

@Scene(FORTUNE_BOT_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class FortuneUpdate {
    constructor(
        private telegramService: TelegramService,
        private fortuneCouponService: FortuneCouponService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: SenderTelegram) {
        const prizeToday = await this.fortuneCouponService.getPrizeForToday(String(telegramId));
        if (prizeToday) {
            await ctx.editMessageText('😦 Вы уже получили приз сегодня, приходите за ним завтра.');
        } else {
            const text = 'Жмите на кнопку, забирайте приз! 🥳';
            await ctx.editMessageText(text, getSurprise);
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('get_surprise')
    async getSurprise(@Ctx() ctx: WizardContext, @Sender() sender: SenderTelegram) {
        const prizeToday = await this.fortuneCouponService.getPrizeForToday(String(sender.id));
        if (prizeToday) {
            await ctx.reply('😦 Вы уже получили приз сегодня, приходите за ним завтра.');
            return;
        }
        const prize = await this.fortuneCouponService.getRandomPrize(sender);
        const newCoupon = await this.fortuneCouponService.awardPrizeToUser(prize, String(sender.id));

        await ctx.reply(
            `🔥 Поздравляем! Вы выиграли: ${prize.name}.\nДЕЙСТВУЕТ ДО КОНЦА ДНЯ\n(код: <b><code>${newCoupon.coupon}</code></b>)`,
            {
                parse_mode: 'HTML',
                ...getMainMenuKeyboard(),
            },
        );
    }
}

```

src/module/telegram/updates/make-order/make-order.service.ts:
```
import { Injectable } from '@nestjs/common';
import { aproveShopKeyboard, comebackShopSelection } from '../../keyboards/make-order.keyboard';
import { IAccountCashing } from '../../../account/interfaces/account.interface';

@Injectable()
export class MakeOrderService {
    constructor() {}

    async approveShop(account: IAccountCashing, shopId: string) {
        const accessItemsPickupAvailability = account.accessItemsPickupAvailability;
        const shop = accessItemsPickupAvailability?.data.list.find(shop => String(shop.shop.shopNumber) === shopId);

        if (!shop) {
            return {
                text: 'Магазин не найден',
                keyboard: comebackShopSelection,
                shop: null,
            };
        }

        const selectedShop = shop;
        const isAllAvailabilityItems = selectedShop.potentialOrders[0].availability === 'IN_STOCK';

        if (isAllAvailabilityItems) {
            return {
                text: `Подтвердите выбор ТЦ по адресу:\n${selectedShop.shop.address}\n${selectedShop.shop.name}`,
                keyboard: aproveShopKeyboard,
                shop: selectedShop.shop,
            };
        }

        const partAvailabilityItems = selectedShop.potentialOrders[1];
        const cart = account.cartResponse!;
        const text =
            'Сегодня доступны вещи:\n' +
            partAvailabilityItems.availableItems
                .map(item => {
                    const itemProductId = item.productId;
                    const availableItem = cart.data.cartFull.availableItems.find(
                        productId => productId.cartItemId.productId === itemProductId,
                    );
                    return availableItem!.name;
                })
                .join('\n');

        return {
            text: text,
            keyboard: comebackShopSelection,
            shop: null,
        };
    }
}

```

src/module/telegram/updates/make-order/make-order.update.ts:
```
import { Action, Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { ALL_KEYS_MENU_BUTTON_NAME, MAKE_ORDER } from '../base-command/base-command.constants';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { TelegramService } from '../../telegram.service';
import { WizardContext } from 'telegraf/typings/scenes';
import { isAccountIdPipe } from '../../pipes/isAccountId.pipe';
import {
    ORDER_CHANGE_RECIPIENT_SCENE,
    ORDER_CITY_SCENE,
    ORDER_FAVOURITE_CITY_SCENE,
    ORDER_GET_ORDERS_SCENE,
    ORDER_INPUT_ARTICLE_SCENE,
    ORDER_INPUT_LINK_SCENE,
    ORDER_INPUT_PROMO_SCENE,
    ORDER_MENU_ACCOUNT_SCENE,
    ORDER_MENU_CART_SCENE,
} from '../../scenes/make-order.scene-constant';
import { AccountService } from '../../../account/account.service';
import {
    accessShopsKeyboard,
    cartItemsKeyboard,
    comebackBtn,
    comebackCartkeyboard,
    emptyCartKeyboard,
    getCitiesForDeleteKeyboard,
    getCitiesKeyboard,
    getFoundedCitiesForFavKeyboard,
    getSearchProductKeyboard,
    getSearchSkuKeyboard,
    getUserCitiesKeyboard,
    infoOrderKeyboard,
    mainMenuOrderKeyboard,
    orderHistoryKeyboard,
    ordersInfoKeyboard,
    recipientKeyboard,
} from '../../keyboards/make-order.keyboard';
import { UserService } from '../../../user/user.service';
import { isCityPipe } from '../../pipes/isCity.pipe';
import { ERROR_FIND_CITY, ERROR_FOUND_USER } from '../../constants/error.constant';
import { getTextCart } from '../../utils/cart.utils';
import { isUrlPipe } from '../../pipes/isUrl.pipe';
import { prepareForInternalPickupAvailability } from '../../utils/order.utils';
import { MakeOrderService } from './make-order.service';
import { isFioPipe } from '../../pipes/isFio.pipe';
import { IRecipient, IRecipientOrder } from '../../../account/interfaces/account.interface';
import { ConfigService } from '@nestjs/config';
import { Context } from '../../interfaces/telegram.context';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';

@Scene(MAKE_ORDER.scene)
@UseFilters(TelegrafExceptionFilter)
export class MakeOrderUpdate {
    constructor(
        private telegramService: TelegramService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: Context, @Sender() telegramUser: any) {
        // в будующем удалить регу или обновление юзера
        const { first_name: telegramName, id: telegramId } = telegramUser;
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        await this.userService.createOrUpdateUserByTelegram({
            telegramName,
            telegramId: String(telegramId),
        });

        await ctx.reply('🔑 Введите номер вашего аккаунта:', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async findAccount(
        @Message('text', new isAccountIdPipe()) accountId: string,
        @Sender() { id: telegramId }: any,
        @Ctx() ctx: WizardContext,
    ) {
        await this.telegramService.setTelegramAccountCache(telegramId, accountId);
        await ctx.scene.enter(ORDER_MENU_ACCOUNT_SCENE);
    }
}

@Scene(ORDER_MENU_ACCOUNT_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderMenuAccount {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(String(telegramId));

        const shortInfo = await this.accountService.shortInfo(account.accountId);
        const text = `📱 Аккаунт найден. Баланс: ${shortInfo.bonusCount}`;

        const keyboard = mainMenuOrderKeyboard(shortInfo.citySMName);

        if (ctx.updateType === 'callback_query') {
            await ctx.editMessageText(text, keyboard);
        } else {
            await ctx.reply(text, keyboard);
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('go_to_city')
    async choosingWayCity(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_CITY_SCENE);
    }

    @Action('go_to_cart')
    async choosingWayCart(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }

    @Action('go_to_orders')
    async choosingWayOrder(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_GET_ORDERS_SCENE);
    }
}

@Scene(ORDER_CITY_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderCity {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const userCities = await this.userService.getUserCities(String(telegramId));
        const keyboard = getUserCitiesKeyboard(userCities);

        const text = 'Введите название города для его изменения. Либо выберете из Ваших избранных';
        if (ctx.updateType === 'callback_query') {
            await ctx.editMessageText(text, keyboard);
        } else {
            await ctx.reply(text, keyboard);
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputCity(@Message('text', new isCityPipe()) city: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        const findCities = await this.accountService.findCity(account.accountId, city);
        if (findCities.length == 0) {
            await ctx.reply(ERROR_FIND_CITY);
            await ctx.scene.reenter();
        }
        const keyboard = getCitiesKeyboard(findCities);
        await ctx.reply('Выберете город для изменения', keyboard);
    }

    @Action(/^id_city_\d+$/)
    async setCity(@Sender() { id: telegramId }: any, @Ctx() ctx: WizardContext) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const cityId = ctx.match[0].split('_')[2];
        const account = await this.telegramService.getFromCache(telegramId);
        await this.accountService.setAccountCity(account.accountId, cityId);
        await this.accountService.getProfile(account.accountId);
        await ctx.scene.enter(ORDER_MENU_ACCOUNT_SCENE);
    }

    @Action('add_new_user_city')
    async addFavouriteCity(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_FAVOURITE_CITY_SCENE);
    }

    @Action('del_favourite_city')
    async selectDelFavouriteCity(@Sender() { id: telegramId }: any, @Ctx() ctx: WizardContext) {
        const userCities = await this.userService.getUserCities(String(telegramId));
        const keyboard = getCitiesForDeleteKeyboard(userCities);
        await ctx.editMessageText('Выберете город для удаления', keyboard);
    }

    @Action(/^del_city_\d+$/)
    async delFavouriteCity(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const cityId = ctx.match[0].split('_')[2];

        await this.userService.deleteUserCity(String(telegramId), cityId);
        await ctx.scene.enter(ORDER_CITY_SCENE);
    }

    @Action('re_enter_scene')
    async reEnterScene(@Ctx() ctx: WizardContext) {
        await ctx.scene.reenter();
    }

    @Action('go_to_menu')
    async goToMenu(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_ACCOUNT_SCENE);
    }
}

@Scene(ORDER_FAVOURITE_CITY_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderFavouriteCity {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.editMessageText('Введите название города для добавления в избранное', comebackBtn);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputFavouriteCity(
        @Message('text', new isCityPipe()) city: string,
        @Ctx() ctx: WizardContext,
        @Sender() { id: telegramId }: any,
    ) {
        const account = await this.telegramService.getFromCache(telegramId);
        const findCities = await this.accountService.findCity(account.accountId, city);
        if (findCities.length == 0) {
            await ctx.reply(ERROR_FIND_CITY);
            await ctx.scene.reenter();
        }
        const keyboard = getFoundedCitiesForFavKeyboard(findCities);
        await ctx.reply('Выберете город для добавления', keyboard);
    }

    @Action(/^add_favourite_city_\d+$/)
    async selectFavouriteCity(@Sender() { id: telegramId }: any, @Ctx() ctx: WizardContext) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const cityId = ctx.match[0].split('_')[3];
        await this.userService.addUserCity(String(telegramId), cityId);
        await ctx.scene.enter(ORDER_CITY_SCENE);
    }

    @Action('go_back')
    async reEnterScene(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_CITY_SCENE);
    }
}

@Scene(ORDER_MENU_CART_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderMenuCart {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
        private makeOrderService: MakeOrderService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        const cartResponse = await this.accountService.getCart(account.accountId);
        account.email = cartResponse.data.cartFull.owner.email;
        let keyboard;
        let text;
        if (cartResponse.data.cartFull.soldOutLines.length != 0) {
            keyboard = cartItemsKeyboard(cartResponse.data.cartFull.soldOutLines);
            text = 'В корзине есть товары, которые нельзя заказать';
        } else if (cartResponse.data.cartFull.availableItems.length != 0) {
            keyboard = cartItemsKeyboard(cartResponse.data.cartFull.availableItems);
            text = getTextCart(cartResponse);
            account.cartResponse = cartResponse;
        } else {
            keyboard = emptyCartKeyboard;
            text = 'Выберете действие';
        }

        try {
            await ctx.editMessageText(text, keyboard);
        } catch (err) {
            await ctx.reply(text, keyboard);
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action('add_order_link')
    async addOrderLink(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_INPUT_LINK_SCENE);
    }

    @Action('share_cart')
    async shareCartLink(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        const url = await this.accountService.createSnapshot(account.accountId);
        await ctx.reply(url);
        await ctx.scene.reenter();
    }

    @Action('add_item_cart')
    async addProduct(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_INPUT_ARTICLE_SCENE);
    }

    @Action('shop_selection')
    async choosingShopOrder(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);

        //Не понятно, как определить, что есть самовывоз
        // const nonAccessItems = isAccessShop(account.cartResponse!);

        // if (nonAccessItems.length != 0) return await ctx.reply(`❌ ${nonAccessItems.join(', ')} Нет доступности для заказа`);

        const internalPickupAvabilityItems = prepareForInternalPickupAvailability(account.cartResponse!);
        const accessItemsPickupAvailability = await this.accountService.internalPickupAvailability(
            account.accountId,
            internalPickupAvabilityItems,
        );
        account.internalPickupAvabilityItems = internalPickupAvabilityItems;
        account.accessItemsPickupAvailability = accessItemsPickupAvailability;

        const keyboardShops = accessShopsKeyboard(accessItemsPickupAvailability);
        await ctx.editMessageText('Выберите ТЦ', keyboardShops);
    }

    @Action(/^id_shop_\d+$/)
    async approveShop(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const shopId = ctx.match[0].split('_')[2];

        const account = await this.telegramService.getFromCache(telegramId);
        const { text, keyboard, shop } = await this.makeOrderService.approveShop(account, shopId);
        if (shop) account.shop = shop;
        await ctx.editMessageText(text, keyboard);
    }

    @Action('approve_shop')
    async choiceChangeRecipient(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        const shopId = String(account.shop!.shopNumber);

        const { potentialOrder, version } = await this.accountService.internalPickup(
            account.accountId,
            shopId,
            account.internalPickupAvabilityItems,
        );
        account.version = version;
        account.potentialOrder = potentialOrder;

        await ctx.editMessageText(`Изменить получателя заказа?`, recipientKeyboard);
    }

    @Action('recipient_i')
    async orderConfirmation(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        const orderNumber = await this.accountService.submitOrder(account.accountId, account.version!);

        await ctx.editMessageText(`Поздравляю! Ваш заказ под номером: <code>${orderNumber}</code>`, {
            parse_mode: 'HTML',
            ...ordersInfoKeyboard,
        });
    }

    @Action('recipient_not_i')
    async changeRecipient(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_CHANGE_RECIPIENT_SCENE);
    }

    @Action('go_to_orders')
    async selectOrder(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_GET_ORDERS_SCENE);
    }

    @Action('add_promo')
    async addPromo(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_INPUT_PROMO_SCENE);
    }

    @Action('delete_promo')
    async deletePromo(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        await this.accountService.deletePromocode(account.accountId);
        await ctx.reply('Промокод удален');
        await ctx.scene.reenter();
    }

    @Action('clear_cart')
    async clearCart(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        await this.accountService.removeAllCart(account.accountId);
        await ctx.reply('Вещи удалены из списка');
        await ctx.scene.reenter();
    }

    @Action(/id_remove_\d+_\d+/)
    async removeItemCart(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const productId = ctx.match[0].split('_')[2];
        const item = account.cartResponse?.data.cartFull.availableItems.filter(item => item.cartItemId.productId == productId);
        if (item && item.length == 0) return;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const linesIds = item[0].cartItemId.linesIds;

        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const sku = ctx.match[0].split('_')[3];
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        await this.accountService.removeFromCart(account.accountId, [{ productId, sku, linesIds }]);
        await ctx.scene.reenter();
    }

    @Action(/id_add_\d+_\d+/)
    async addItemCart(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const productId = ctx.match[0].split('_')[2];

        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const sku = ctx.match[0].split('_')[3];

        await this.accountService.addInCart(account.accountId, { productId, sku });
        await ctx.scene.reenter();
    }

    @Action('go_to_menu')
    async goToMenu(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_ACCOUNT_SCENE);
    }

    @Action('go_back')
    async choosingWayCart(@Ctx() ctx: WizardContext) {
        await ctx.scene.reenter();
    }
}

@Scene(ORDER_INPUT_ARTICLE_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderInputArticle {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.editMessageText('Введите артикул или название вещи:', comebackBtn);
    }

    @Action('go_back')
    async choosingWayCart(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async searchingAddingArticle(@Message('text') article: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);

        const foundedProduct = await this.accountService.searchProduct(account.accountId, article);
        let text;
        if (foundedProduct.data.list.length != 0) {
            text = 'Выберете товар';
            account.foundedProduct = foundedProduct;
        } else {
            text = 'Товар не найден';
        }
        const keyboard = getSearchProductKeyboard(foundedProduct);
        await ctx.reply(text, keyboard);
    }

    @Action(/id_product_\d/)
    async selectProduct(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const productId = ctx.update.callback_query.data.split('_')[2];

        const foundedProduct = account.foundedProduct!;
        const list = foundedProduct.data.list;
        const item = list.filter(value => value.id == productId)[0];
        const keyboard = getSearchSkuKeyboard(productId, foundedProduct);
        if (!keyboard) {
            await ctx.editMessageText('Доступных размеров нет', comebackBtn);
        } else {
            await ctx.editMessageText(item.name, keyboard);
        }
    }

    @Action(/id_add_\d+_\d+/)
    async addItemCart(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const productId = ctx.match[0].split('_')[2];

        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const sku = ctx.match[0].split('_')[3];

        await this.accountService.addInCart(account.accountId, { productId, sku });
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }
}

@Scene(ORDER_INPUT_LINK_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderInputLink {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.editMessageText('Отправьте ссылку, которую скопировали из мобильного приложения', comebackBtn);
    }

    @Action('go_back')
    async choosingWayCart(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async addOrderLink(@Message('text', new isUrlPipe()) urlLink: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);

        await this.accountService.applySnapshot(account.accountId, urlLink);
        await ctx.reply('Товары были добавлены в корзину');
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }
}

@Scene(ORDER_INPUT_PROMO_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderInputPromo {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.editMessageText('Введите промокод', comebackBtn);
    }

    @Action('go_back')
    async choosingWayCart(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputPromocode(@Message('text') promocode: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        await this.accountService.addPromocode(account.accountId, promocode);
        await ctx.reply('Промокод успешно применен');
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }
}

@Scene(ORDER_CHANGE_RECIPIENT_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderChangeRecipient {
    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        await ctx.editMessageText(
            `Введите Имя, Фамилию, email и номер телефона через пробелы:\nИванов Иван <code>${account.email}</code> 88005553535`,
            {
                parse_mode: 'HTML',
                ...comebackCartkeyboard,
            },
        );
    }

    @Action('go_to_cart')
    async choosingWayCart(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_CART_SCENE);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputRecipient(
        @Message('text', new isFioPipe()) fioData: IRecipient,
        @Sender() { id: telegramId }: any,
        @Ctx() ctx: WizardContext,
    ) {
        const account = await this.telegramService.getFromCache(telegramId);
        const data: IRecipientOrder = {
            ...fioData,
            potentialOrder: account.potentialOrder!,
        };

        const version = await this.accountService.approveRecipientOrder(account.accountId, data);
        const orderNumber = await this.accountService.submitOrder(account.accountId, version);
        await ctx.reply(`Поздравляю! Ваш заказ под номером: <code>${orderNumber}</code>`, {
            parse_mode: 'HTML',
            ...ordersInfoKeyboard,
        });
    }

    @Action('go_to_orders')
    async selectOrder(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_GET_ORDERS_SCENE);
    }
}

@Scene(ORDER_GET_ORDERS_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class OrderGetOrders {
    private DOMAIN = this.configService.getOrThrow('DOMAIN', 'http://localhost:3001');

    constructor(
        private accountService: AccountService,
        private telegramService: TelegramService,
        private configService: ConfigService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        const orders = await this.accountService.orderHistory(account.accountId);
        const keyboard = orderHistoryKeyboard(orders);
        const text = 'Имеющиеся заказы на аккаунте:';
        try {
            await ctx.editMessageText(text, keyboard);
        } catch (err) {
            await ctx.reply(text, keyboard);
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @Action(/^order_(\d+)-\d+$/)
    async selectOrder(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const orderNumber = ctx.match[0].split('_')[1];
        const order = await this.accountService.orderInfo(account.accountId, orderNumber);
        const keyboard = infoOrderKeyboard(account.accountId, order.data.order.number, order.data.order.isCancelled, this.DOMAIN);

        const text = `Заказ номер: <code>${order.data.order.number}</code>`;
        await ctx.editMessageText(text, {
            parse_mode: 'HTML',
            ...keyboard,
        });
    }

    @Action(/^cancelled_order_(\d+)-\d+$/)
    async cancellOrder(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(telegramId);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const orderNumber = ctx.match[0].split('_')[2];
        await this.accountService.cancellOrder(account.accountId, orderNumber);

        await ctx.reply('Заказ отменен');
        await ctx.scene.reenter();
    }

    @Action('go_to_menu')
    async goToMenu(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(ORDER_MENU_ACCOUNT_SCENE);
    }
}

```

src/module/telegram/updates/payment/payment.update.ts:
```
import { Action, Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { BadRequestException, Logger, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { ALL_KEYS_MENU_BUTTON_NAME } from '../base-command/base-command.constants';
import { TelegramService } from '../../telegram.service';
import { MAKE_DEPOSIT_SCENE, PAYMENT_PROMOCODE_BOT_SCENE, PROMOCODE_BOT_SCENE } from '../../scenes/profile.scene-constant';
import { isMoneyAmountPipe } from '../../pipes/isMoneyAmount.pipe';
import { cancelPaymentKeyboard, comebackPayment, createdPaymentKeyboard } from '../../keyboards/profile.keyboard';
import { StatusPayment } from '@prisma/client';
import { ERROR_SCRINSHOT } from '../../constants/error.constant';
import { FileService } from '../../../shared/file.service';
import { getFileNameForReceipt } from '../../utils/receipt.utils';
import { extractAmountFTransferedPay } from '../../utils/payment.utils';
import { PaymentService } from '../../../payment/payment.service';
import { gotoCoupon } from '../../keyboards/payment.keyboard';
import { FortuneCouponService } from '../../../coupon/fortune-coupon.service';

@Scene(MAKE_DEPOSIT_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class PaymentUpdate {
    private readonly logger = new Logger(PaymentUpdate.name);

    constructor(
        private telegramService: TelegramService,
        private paymentService: PaymentService,
        private fileService: FileService,
        private fortuneCouponService: FortuneCouponService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const allPayments = await this.paymentService.getUserPaymentOrders(String(telegramId));

        const createdPayments = allPayments.filter(payment => payment.status == StatusPayment.Created);
        const transferedPayments = allPayments.filter(payment => payment.status == StatusPayment.Transfered);
        let text = extractAmountFTransferedPay(transferedPayments);

        if (createdPayments.length == 0) {
            text +=
                'Для пополнения введите сумму (кратную 50р), на которую хотите пополнить.\nМинимум 500р, от 2000р пополнение +2%, от 5000р +5%';
            try {
                await ctx.editMessageText(text);
            } catch (e) {
                await ctx.reply(text);
            }
        } else {
            const keyboard = createdPaymentKeyboard(createdPayments);
            text +=
                'У вас есть незавершенные заявки на пополнение. Выберете одну из них, либо создайте новую, отправив сумму пополнения в бот';
            try {
                await ctx.editMessageText(text, keyboard);
            } catch (e) {
                await ctx.reply(text, keyboard);
            }
        }
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputMoneyAmount(
        @Message('text', new isMoneyAmountPipe()) amountCount: number,
        @Ctx() ctx: WizardContext,
        @Sender() { id: telegramId }: any,
    ) {
        const createOrder = await this.paymentService.createPaymentOrder(amountCount, String(telegramId));
        await this.telegramService.setDataCache<string>(String(telegramId), createOrder.id);
        await ctx.reply(
            `Создана заявка на пополнение на сумму ${createOrder.amount}р.\nК зачислению ${createOrder.amountCredited}р\n
Сделайте перевод (${createOrder.amount}р) на реквизиты Админа и пришлите чек о переводе в чат`,
            cancelPaymentKeyboard(createOrder.id),
        );
    }

    @Action('goBack')
    async goBack(@Ctx() ctx: WizardContext) {
        await ctx.scene.reenter();
    }

    @Action(/^cancelPayment_.*$/)
    async cancelPayment(@Ctx() ctx: WizardContext) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const paymentId = ctx.match[0].split('_')[1];

        const orderPayment = await this.paymentService.getPaymentOrder(paymentId);
        if (!orderPayment) {
            await ctx.reply('Ошибка: платеж не найден.');
            return;
        }

        let coupon;
        if (orderPayment.couponApplied && orderPayment.couponId) {
            coupon = await this.fortuneCouponService.restoreCoupon(orderPayment.couponId);
        }

        const updatedOrder = await this.paymentService.updatePaymentOrderStatus(paymentId, StatusPayment.Cancelled);

        await ctx.editMessageText(
            `Заявка на сумму ${updatedOrder.amount}р отменена. ${orderPayment.couponApplied ? `Купон ${coupon && coupon.coupon} восстановлен.` : ''}`,
        );
    }

    @Action(/^createdPayment_.*$/)
    async createdPayment(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const paymentInfo = ctx.match[0].split('_')[1];
        const [paymentId, amount, amountCredited] = paymentInfo.split('|');
        await this.telegramService.setDataCache<string>(String(telegramId), paymentId);

        await ctx.editMessageText(
            `Заявка на сумму ${amount}р\nК зачислению ${amountCredited}р\n
Сделайте перевод (${amount}р) на реквизиты Админа и пришлите чек о переводе в чат`,
            cancelPaymentKeyboard(paymentId),
        );
    }

    @On('photo')
    async inputReceipt(@Sender() { id: telegramId }: any, @Ctx() ctx: WizardContext) {
        try {
            const paymentId = await this.telegramService.getDataFromCache<string>(String(telegramId));
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore
            const photos = ctx!.message!.photo;
            const fileId = photos[photos.length - 2].file_id;
            const fileLink = await ctx.telegram.getFileLink(fileId);

            const fileExtension = fileLink.href.split('.').pop() || 'jpg';
            const fileName = getFileNameForReceipt(String(telegramId), fileExtension);
            await this.fileService.saveFileFromTg(fileName, fileLink);

            const orderPayment = await this.paymentService.makeDepositUserBalance(paymentId, fileName);
            await ctx.reply(`Заявка на сумму ${orderPayment.amountCredited}р исполнена. Квитанция сохранена.`);
        } catch (error) {
            this.logger.error('Error processing receipt:', error);
            await ctx.reply('Произошла ошибка при обработке квитанции.');
        }
    }

    @On('document')
    async inputReceiptDoc(@Sender() { id: telegramId }: any, @Ctx() ctx: WizardContext) {
        try {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore
            const document = ctx.message!.document!;

            if (document?.mime_type === 'application/pdf') {
                const fileLink = await ctx.telegram.getFileLink(document.file_id);
                const pdfBuffer = await this.fileService.downloadFile(fileLink.href);
                const fileName = getFileNameForReceipt(String(telegramId), 'jpg');
                const jpgBuffer = await this.fileService.convertPdfToJpg(pdfBuffer, fileName);

                await this.fileService.saveFile(fileName, jpgBuffer);

                const paymentId = await this.telegramService.getDataFromCache<string>(String(telegramId));
                const orderPayment = await this.paymentService.makeDepositUserBalance(paymentId, fileName);
                await ctx.reply(`Заявка на сумму ${orderPayment.amountCredited}р исполнена. Квитанция сохранена.`);
            } else {
                await ctx.reply('Пожалуйста, отправьте файл в формате PDF.');
            }
        } catch (error) {
            await ctx.reply('Ошибка при обработке документа квитанции');
        }
    }

    @On('text')
    async ErrorText() {
        throw new BadRequestException(ERROR_SCRINSHOT);
    }

    // @Action('goto_coupon')
    // async gotoCoupon(@Ctx() ctx: WizardContext) {
    //     await ctx.scene.enter(PROMOCODE_BOT_SCENE);
    // }

    @Action('payment_coupon')
    async selectCouponPayment(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(PAYMENT_PROMOCODE_BOT_SCENE);
    }
}

@Scene(PAYMENT_PROMOCODE_BOT_SCENE)
@UseFilters(TelegrafExceptionFilter)
export class PaymentPromocodeUpdate {
    private readonly logger = new Logger(PaymentUpdate.name);
    constructor(
        private telegramService: TelegramService,
        private paymentService: PaymentService,
        private fortuneCouponService: FortuneCouponService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.editMessageText('Если у вас есть купон на пополнение, пришлите его. Активировать можно 1 раз', comebackPayment);
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputCoupon(@Message('text') couponCode: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const paymentId = await this.telegramService.getDataFromCache<string>(String(telegramId));
        if (!paymentId) {
            await ctx.reply('Не найдена заявка на пополнение. Попробуйте снова.');
            return;
        }

        try {
            const redeemedCoupon = await this.fortuneCouponService.validateAndRedeemCoupon(couponCode, String(telegramId));

            const paymentOrder = await this.paymentService.getPaymentOrder(paymentId);
            if (!paymentOrder) {
                await ctx.reply('Не найдена заявка на пополнение.');
                return;
            }

            const multiplier = 1 + redeemedCoupon.value / 100;
            const newAmountCredited = Math.floor(paymentOrder.amount * multiplier);

            const updatedPaymentOrder = await this.paymentService.applyCouponToPaymentOrder(
                paymentId,
                newAmountCredited,
                redeemedCoupon.id,
            );

            await ctx.reply(`Купон успешно применен! Новая сумма зачисления: ${updatedPaymentOrder.amountCredited}₽.`);
            await ctx.scene.enter(MAKE_DEPOSIT_SCENE);
        } catch (error: any) {
            this.logger.error(error);
            await ctx.reply(`Ошибка при применении купона: ${error.message}`);
        }
    }

    @Action('comeback_payment')
    async selectCouponPayment(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(MAKE_DEPOSIT_SCENE);
    }
}

```

src/module/telegram/updates/profile/profile.update.ts:
```
import { Action, Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { ALL_KEYS_MENU_BUTTON_NAME, PROFILE } from '../base-command/base-command.constants';
import { TelegramService } from '../../telegram.service';
import { AccountService } from '../../../account/account.service';
import { CheckingService } from '../checking/checking.service';
import { profileKeyboard } from '../../keyboards/profile.keyboard';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { FORTUNE_BOT_SCENE, MAKE_DEPOSIT_SCENE, PROFILE_GET_INFO_ORDER } from '../../scenes/profile.scene-constant';
import { UserService } from '../../../user/user.service';
import { ERROR_FOUND_USER } from '../../constants/error.constant';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';

@Scene(PROFILE.scene)
@UseFilters(TelegrafExceptionFilter)
export class ProfileUpdate {
    constructor(
        private telegramService: TelegramService,
        private checkingService: CheckingService,
        private userService: UserService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.reply('Выберете действие', profileKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputAccounts(@Message('text') inputAccounts: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);

        const allAccounts = inputAccounts.split('\n');
        const accounts = allAccounts.slice(0, 22);
        const extraAccounts = allAccounts.slice(22);

        if (extraAccounts.length > 0) {
            await ctx.reply(`Не вместилось, отправьте еще раз:\n${extraAccounts.join('\n')}`);
        }
        await ctx.reply('Началась проверка');
        const checkedAccounts = await this.checkingService.checkingAccountsOnPromocodes(accounts);
        await ctx.reply(checkedAccounts.join(''), { parse_mode: 'HTML', ...getMainMenuKeyboard(user.role) });
    }

    @Action('check_promo')
    async goToCheckerPromo(@Ctx() ctx: WizardContext) {
        await ctx.reply('Пришлите номера аккаунтов, каждый с новой строки. За раз не больше 20');
    }

    @Action('get_info_order')
    async getInfoOrder(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(PROFILE_GET_INFO_ORDER);
    }

    @Action('payment')
    async makeDeposit(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(MAKE_DEPOSIT_SCENE);
    }

    // @Action('get_promocode')
    // async getPromocode(@Ctx() ctx: WizardContext) {
    //     await ctx.scene.enter(PROMOCODE_BOT_SCENE);
    // }

    @Action('fortune')
    async goToFortune(@Ctx() ctx: WizardContext) {
        await ctx.scene.enter(FORTUNE_BOT_SCENE);
    }
}

@Scene(PROFILE_GET_INFO_ORDER)
@UseFilters(TelegrafExceptionFilter)
export class GetInfoOrderUpdate {
    constructor(
        private accountService: AccountService,
        private userService: UserService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext) {
        await ctx.reply('Введите номер вашего заказа для поиска аккаунта, с которого был выполнен заказ:');
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async inputAccounts(@Message('text') numberOrder: string, @Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        const order = await this.accountService.findOrderNumber(numberOrder);
        if (order) {
            await ctx.reply(order.accountId, getMainMenuKeyboard(user.role));
        } else {
            await ctx.reply('Нет данных о заказе', getMainMenuKeyboard(user.role));
        }
    }
}

// @Scene(PROMOCODE_BOT_SCENE)
// @UseFilters(TelegrafExceptionFilter)
// export class PromocodeBotUpdate {
//     constructor(
//         private telegramService: TelegramService,
//         private paymentService: PaymentService,
//         private userService: UserService,
//     ) {
//     }
//
//     @SceneEnter()
//     async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId, username }: any) {
//         const remainingActivations = await this.paymentService.findRemainingActivations(String(telegramId), username);
//         if (remainingActivations) {
//             await ctx.editMessageText(
//                 `У вас еще осталось (${remainingActivations.activationsLeft}) активации промокода <b><code>${username}</code></b> на ${remainingActivations.discount}% скидки`,
//                 { parse_mode: 'HTML', ...comebackProfile },
//             );
//         } else {
//             const avaliblePromocode = await this.paymentService.getInfoAboutPromocode(String(telegramId), username);
//
//             await ctx.editMessageText(`Вы можете выпустить промокод на скидку ${avaliblePromocode}%`, createPromocodeScene);
//         }
//     }
//
//     @Action('comeback_profile')
//     async getInfoOrder(@Ctx() ctx: WizardContext) {
//         await ctx.deleteMessage();
//         await ctx.scene.enter(PROFILE.scene);
//     }
//
//     @Action('create_promocode')
//     async createPromocode(@Ctx() ctx: WizardContext, @Sender() { id: telegramId, username }: any) {
//         const { promoName, discountPercent } = await this.paymentService.createPromocode(String(telegramId), username);
//         const user = await this.userService.getUserByTelegramId(String(telegramId));
//         if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
//         await ctx.reply(
//             `Ваш промокод <b><code>${promoName}</code></b> на ${discountPercent}% скидку создан. Всего активаций: 5 для перевыпуска`,
//             { parse_mode: 'HTML', ...getMainMenuKeyboard(user.role) },
//         );
//         await ctx.scene.leave();
//     }
//
//     @Hears(ALL_KEYS_MENU_BUTTON_NAME)
//     async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
//         await this.telegramService.exitScene(menuBtn, ctx);
//     }
// }

```

src/module/telegram/updates/qr-code/qr-code.service.ts:
```
import { Injectable } from '@nestjs/common';
import * as QRCode from 'qrcode';
import sharp from 'sharp';
import * as fs from 'fs';
import { join } from 'path';

@Injectable()
export class QrCodeService {
    private cropCenter = async (imageBuffer: Buffer, cropWidth: number, cropHeight: number): Promise<Buffer> => {
        const { width, height } = await sharp(imageBuffer).metadata();

        if (!width || !height) {
            throw new Error('Could not retrieve image metadata');
        }

        const validCropWidth = Math.min(cropWidth, width);
        const validCropHeight = Math.min(cropHeight, height);

        const left = (width - validCropWidth) / 2;
        const top = (height - validCropHeight) / 2;

        return sharp(imageBuffer)
            .extract({ left: Math.round(left), top: Math.round(top), width: validCropWidth, height: validCropHeight })
            .toBuffer();
    };

    public generateQrCode = async (qrCode: string): Promise<Buffer> => {
        const filePath = join(process.cwd(), 'src/module/telegram/updates/qr-code/back_img.png');
        const back_img = fs.readFileSync(filePath);

        const qr_img = await QRCode.toBuffer(qrCode, { scale: 12 });
        const cropped_qr_img = await this.cropCenter(qr_img, 500, 500);

        return await sharp(back_img)
            .composite([{ input: cropped_qr_img, top: 680, left: 290 }])
            .toBuffer();
    };
}

```

src/module/telegram/updates/qr-code/qr-code.update.ts:
```
import { Action, Ctx, Hears, Message, On, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { WizardContext } from 'telegraf/typings/scenes';
import { ALL_KEYS_MENU_BUTTON_NAME, QR_CODE } from '../base-command/base-command.constants';
import { AccountService } from '../../../account/account.service';
import { NotFoundException, UseFilters } from '@nestjs/common';
import { TelegrafExceptionFilter } from '../../filters/telegraf-exception.filter';
import { QrCodeService } from './qr-code.service';
import { TelegramService } from '../../telegram.service';
import { isAccountIdPipe } from '../../pipes/isAccountId.pipe';
import { qrCodeUpdateKeyboard } from '../../keyboards/qr-code.keyboard';
import { ERROR_FOUND_USER } from '../../constants/error.constant';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { UserService } from '../../../user/user.service';

@Scene(QR_CODE.scene)
@UseFilters(TelegrafExceptionFilter)
export class QrCodeUpdate {
    constructor(
        private qrCodeService: QrCodeService,
        private accountService: AccountService,
        private userService: UserService,
        private telegramService: TelegramService,
    ) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.reply('🔑 Введите номер вашего аккаунта:', getMainMenuKeyboard(user.role));
    }

    @Hears(ALL_KEYS_MENU_BUTTON_NAME)
    async exit(@Message('text') menuBtn: string, @Ctx() ctx: WizardContext) {
        await this.telegramService.exitScene(menuBtn, ctx);
    }

    @On('text')
    async findAccount(
        @Message('text', new isAccountIdPipe()) accountId: string,
        @Sender() { id: telegramId }: any,
        @Ctx() ctx: WizardContext,
    ) {
        await this.telegramService.setTelegramAccountCache(String(telegramId), accountId);
        const { qrCode, bonusCount } = await this.accountService.shortInfo(accountId);

        const qrCodeBuff = await this.qrCodeService.generateQrCode(qrCode);
        const text = `📱 Аккаунт найден. Баланс: ${bonusCount}`;

        await ctx.replyWithPhoto({ source: qrCodeBuff }, { caption: text, ...qrCodeUpdateKeyboard });
    }

    @Action('update_qrcode')
    async updateQrCode(@Ctx() ctx: WizardContext, @Sender() { id: telegramId }: any) {
        const account = await this.telegramService.getFromCache(String(telegramId));
        const { qrCode } = await this.accountService.shortInfo(account.accountId);
        const qrCodeBuff = await this.qrCodeService.generateQrCode(qrCode);
        const keyboard = qrCodeUpdateKeyboard.reply_markup;
        try {
            await ctx.editMessageMedia({ type: 'photo', media: { source: qrCodeBuff } }, { reply_markup: keyboard });
        } catch (err) {
            await ctx.reply('Не обновлено. Старый QR активен');
        }
    }
}

```

src/module/telegram/updates/start/start.update.ts:
```
import { Ctx, Scene, SceneEnter, Sender } from 'nestjs-telegraf';
import { START } from '../base-command/base-command.constants';
import { Context } from '../../interfaces/telegram.context';
import { UserService } from '../../../user/user.service';
import { getMainMenuKeyboard } from '../../keyboards/base.keyboard';
import { NotFoundException } from '@nestjs/common';
import { ERROR_FOUND_USER } from '../../constants/error.constant';

@Scene(START.scene)
export class StartUpdate {
    constructor(private userService: UserService) {}

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: Context, @Sender() telegramUser: any) {
        const { first_name: telegramName, id: telegramId } = telegramUser;
        await this.userService.createOrUpdateUserByTelegram({
            telegramName,
            telegramId: String(telegramId),
        });
        const user = await this.userService.getUserByTelegramId(String(telegramId));
        if (!user?.role) throw new NotFoundException(ERROR_FOUND_USER);
        await ctx.replyWithPhoto('https://cstor.nn2.ru/forum/data/forum/images/2018-04/203019686-3f3b88013d6894fa103d7e79121a346a.jpg', {
            caption: `Добро пожаловать в меню, ${telegramName}!\n\nЧто вас интересует?`,
            ...getMainMenuKeyboard(user.role),
        });

        await ctx.scene.leave();
    }
}

```

src/module/telegram/utils/cart.utils.ts:
```
import { CartInterface, ICartItemsInfo } from '../../account/interfaces/cart.interface';

export interface IItemsCart {
    sku: string;
    productId: string;
    name?: string;
    linesIds?: string[];
}

export function selectMainFromCart(cart: CartInterface): IItemsCart[] {
    const items: ICartItemsInfo[] = [];
    items.push(...cart.data.cartFull.availableItems);
    const itemsDelivery = cart.data.cartFull.obtainPoints;
    const itemsOutStock = cart.data.cartFull.soldOutLines;

    if (itemsDelivery.length > 0) {
        const itemsTemp = itemsDelivery[0].cartItems[0];
        items.push(itemsTemp);
    }
    items.push(...itemsOutStock);

    return items.map(item => ({
        sku: String(item.cartItemId.sku),
        productId: item.cartItemId.productId,
        linesIds: item.cartItemId.linesIds,
        name: item.name,
    }));
}

export function getTextCart(cart: CartInterface): string {
    let text = '\n';
    const unallocatedItems = cart.data.cartFull.availableItems;
    unallocatedItems.forEach(item => {
        text += `Название товара: ${item.name}\n`;
        text += `Количество товара: ${item.quantity}\n`;

        item.params.forEach(param => {
            text += `${param.name}: ${param.value}\n`;
        });

        const itemPrice = item.itemPrice.value / 100;
        const catalogPrice = item.catalogPrice.value / 100;
        text += `Цена товара с учетом скидки: ${Math.floor(itemPrice)}\n`;
        text += `Цена товара без учета скидки: ${Math.floor(catalogPrice)}\n\n`;
    });

    text += '\nОбщая информация по заказу:\n';
    const totals = cart.data.cartFull.totals;
    const productsAmount = Math.floor(totals.productsAmount);
    const priceWoDiscount = Math.floor(totals.priceWoDiscount.value / 100);
    const bonuses = Math.floor(totals.bonuses.value / 100);
    const promo = Math.floor(totals.promo.value / 100);
    const total = Math.floor(totals.total.value / 100);
    const promocodes: string[] = cart.data.cartFull.promoCodes;

    text += `Использовать бонусы?: ${cart.data.cartFull.bonusesInfo.bonusApplied ? 'ДА' : 'НЕТ'}\n`;
    text += `Применены ли бонусы к заказу?: ${cart.data.cartFull.bonusesInfo.isBonusAvailable ? 'ДА' : 'НЕТ'}\n`;
    text += `Использованные промокоды: ${promocodes.length > 0 ? promocodes[0] : 'НЕТ'}\n`;
    text += `Количество товаров в корзине: ${productsAmount}\n`;
    text += `Цена товаров без всех скидок: ${priceWoDiscount}\n`;
    text += `Количество примененных бонусов: ${bonuses}\n`;
    text += `Скидка по промо: ${promo}\n\n`;
    text += `Итоговая цена со всеми скидками: ${total}\n`;

    return text;
}

```

src/module/telegram/utils/isPhone.utils.ts:
```
export const isPhone = (phone: string) => {
    const regex1 = new RegExp('^7\\d{10}$');
    const regex2 = new RegExp('^8\\d{10}$');
    const regex3 = new RegExp('^\\+7\\d{10}$');
    const regex4 = new RegExp('^9\\d{9}$');

    if (regex1.test(phone) || regex2.test(phone)) {
        return phone.trim().substring(1);
    } else if (regex3.test(phone)) {
        return phone.trim().substring(2);
    } else if (regex4.test(phone)) {
        return phone.trim();
    }
    return null;
};

```

src/module/telegram/utils/order.utils.ts:
```
import { CartInterface } from '../../account/interfaces/cart.interface';
import { IItemsCart } from './cart.utils';

export const isAccessShop = (cart: CartInterface): string[] => {
    const availableItems = cart.data.cartFull.availableItems;
    const unAccessItemsOrder: string[] = [];

    for (const item of availableItems) {
        const name = item.name;
        const deliveryInfo = item.deliveryInfo;
        const onlyIntPickup = deliveryInfo.onlyIntPickup;
        const isExpressDeliveryEnabled = deliveryInfo.isExpressDeliveryEnabled;
        const isDeliveryServicesEnabled = deliveryInfo.isDeliveryServicesEnabled;

        if (!(onlyIntPickup || isExpressDeliveryEnabled || isDeliveryServicesEnabled)) unAccessItemsOrder.push(name);
    }
    return unAccessItemsOrder;
};

export const refactorNonAccessItems = (resultList: string[]) => {
    return resultList.join(', ');
};

export const prepareForInternalPickupAvailability = (itemsCart: CartInterface): IItemsCart[] => {
    const newItems: IItemsCart[] = [];

    for (const item of itemsCart.data.cartFull.availableItems) {
        const newItem: IItemsCart = {
            productId: item.cartItemId.productId,
            sku: String(item.cartItemId.sku),
            linesIds: item.cartItemId.linesIds,
        };
        newItems.push(newItem);
    }
    return newItems;
};

// const availability = { SUPPLY: 'Под доставку', IN_STOCK: 'В наличии' };
//
// export const refactorShopAddress = (shops: ShopType[]): ShopAddressType => {
//     const shopAdd: ShopAddressType = {};
//
//     for (const shop of shops) {
//         const shopId = shop.shop.shopNumber;
//         const name = shop.shop.name;
//         const shopAddress = shop.shop.address;
//         shopAdd[shopId] = {
//             shopAddress,
//             name,
//             availability: availability[shop.availability],
//         };
//     }
//     return shopAdd;
// };

```

src/module/telegram/utils/payment.utils.ts:
```
import { PaymentOrderEntity } from '../../payment/entities/payment.entities';
import dayjs from 'dayjs';
import { USerPromocodeActivations, UserStatistic } from '../../payment/interfaces/statistic.interface';

export const extractCsrf = (html: string) => {
    const csrfRegex = /<meta name="csrf-token" content="([^"]+)">/;
    const match = html.match(csrfRegex);

    if (!match || !match[1]) {
        throw new Error('CSRF-токен не найден');
    }

    return match[1];
};

export const extractUserBotId = (html: string) => {
    const userBotIdRegex = /data-key="([\w\W]*?)">/;
    const match = html.match(userBotIdRegex);

    if (!match || !match[1]) {
        throw new Error('UserBotId не найден');
    }

    return match[1];
};

export const extractAmountFTransferedPay = (payments: PaymentOrderEntity[]) => {
    if (payments.length == 0) return '';
    let text = 'Суммы не подтверждены админом:\n';
    payments.forEach(pay => (text += pay.amountCredited + ` от ${dayjs(pay.completedAt).format('DD-MM-YYYY  HH:mm')}` + '\n'));
    return text;
};

export const extractUsersStatistics = (html: string, usersException: string[]): UserStatistic[] => {
    const regex =
        /<th scope="row">(\d+)<\/th>\s*<td>(?:<a href="tg:\/\/user\?id=(\d+)">([^<]+)<\/a>|(@[\w_]+))<\/td>\s*<td>([\d\s]+) ₽<\/td>/g;
    const usersStatistics: Array<UserStatistic> = [];
    let match: RegExpExecArray | null;
    let exceptionCount = 0;

    while ((match = regex.exec(html)) !== null) {
        let row = parseInt(match[1], 10);
        const tgId = match[2] || null;
        const name = match[3] ? match[3].trim() : match[4].trim().replace(/^@/, '');

        if (usersException.includes(name)) {
            exceptionCount++;
            continue;
        }
        row -= exceptionCount;

        usersStatistics.push({ row, name, tgId });
    }

    if (usersStatistics.length === 0) {
        throw new Error('Статистика пользователей не найдена');
    }

    return usersStatistics;
};

export const getPromoCodeDetailsFromHtml = (html: string, promoCodeName: string): USerPromocodeActivations | null => {
    const regex = new RegExp(
        `<tr[^>]*?>\\s*` +
            `<td[^>]*?>${promoCodeName}<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Статус"[^>]*?)?>Не активирован<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Тип"[^>]*?)?>Скидка в процентах<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Ник пользователя"[^>]*?)?>-<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Срок действия"[^>]*?)?>(?:Бессрочно|[^<]+)<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Минимальная сумма"[^>]*?)?>\\d+<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Размер скидки(?:\\/начисления)?"[^>]*?)?>\\s*<span[^>]*?>(\\d+\\s?%)<\\/span>\\s*<\\/td>\\s*` +
            `<td[^>]*?(?:aria-label="Кол-во активаций"[^>]*?)?>(\\d+|Одноразовый)<\\/td>`,
        'i',
    );

    const match = regex.exec(html);

    if (match) {
        const discountStr = match[1];
        const activationsStr = match[2];

        const discount = parseInt(discountStr, 10);
        const activationsLeft = activationsStr === 'Одноразовый' ? 1 : parseInt(activationsStr, 10);

        return { discount, activationsLeft };
    }

    return null;
};

```

src/module/telegram/utils/receipt.utils.ts:
```
import dayjs from 'dayjs';

export const getFileNameForReceipt = (telegramId: string, extension: string) => {
    const day = dayjs().format('YYYY-MM-DD_HH-mm');
    return `receipt_${telegramId}_${day}.${extension}`;
};

```

src/module/user/user.controller.ts:
```
import { Controller, Get } from '@nestjs/common';
import { UserService } from './user.service';
import { HasRoles, RoleEnum } from '@common/decorators/roles.decorator';
import { UserContext } from '../auth/types/user.context.interface';
import { User } from '@common/decorators/user.decorator';

@Controller('user')
export class UserController {
    constructor(private readonly usersService: UserService) {}

    @HasRoles([RoleEnum.USER, RoleEnum.ADMIN])
    @Get('profile')
    async getMyProfile(@User() user: UserContext): Promise<any> {
        return {};
    }
}

```

src/module/user/user.module.ts:
```
import { Module } from '@nestjs/common';
import { UserController } from './user.controller';
import { UserService } from './user.service';
import { UserRepository } from './user.repository';
import { DatabaseModule } from '@common/database';

@Module({
    imports: [DatabaseModule],
    controllers: [UserController],
    providers: [UserService, UserRepository],
    exports: [UserService],
})
export class UserModule {}

```

src/module/user/user.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { UserTelegram } from '@prisma/client';
import { UserTelegramEntity } from './entities/user-telegram.entity';

@Injectable()
export class UserRepository {
    constructor(private readonly prisma: PrismaService) {}

    async createUserByTelegram({ telegramId, telegramName }: UserTelegramEntity): Promise<UserTelegram> {
        return this.prisma.userTelegram.create({
            data: {
                telegramId,
                telegramName,
            },
        });
    }

    async updateUserByTelegram({ telegramId, telegramName }: UserTelegramEntity): Promise<UserTelegram> {
        return this.prisma.userTelegram.update({
            where: {
                telegramId,
            },
            data: {
                telegramName,
            },
        });
    }

    async getUserByTelegramId(telegramId: string): Promise<UserTelegram | null> {
        return this.prisma.userTelegram.findUnique({
            where: {
                telegramId,
            },
        });
    }

    async getUserCities(telegramId: string): Promise<any> {
        return this.prisma.userCitySM.findMany({
            where: {
                userTelegramId: telegramId,
            },
            include: {
                city: true,
            },
        });
    }

    async addUserCity(telegramId: string, cityId: string): Promise<any> {
        return this.prisma.userCitySM.upsert({
            where: {
                cityId_userTelegramId: {
                    cityId,
                    userTelegramId: telegramId,
                },
            },
            update: {},
            create: {
                city: {
                    connect: {
                        cityId,
                    },
                },
                userTelegram: {
                    connect: {
                        telegramId,
                    },
                },
            },
        });
    }

    async deleteUserCity(telegramId: string, cityId: string): Promise<void> {
        await this.prisma.userCitySM.delete({
            where: {
                cityId_userTelegramId: {
                    cityId,
                    userTelegramId: telegramId,
                },
            },
        });
    }
}

```

src/module/user/user.service.ts:
```
import { Injectable } from '@nestjs/common';
import { UserRepository } from './user.repository';
import { ITelegramUser } from './interfaces/user-telegram.interface';
import { UserTelegram } from '@prisma/client';
import { UserTelegramEntity } from './entities/user-telegram.entity';
import { CitySMEntity } from '../account/entities/citySM.entity';

@Injectable()
export class UserService {
    constructor(private readonly userRepository: UserRepository) {}

    async createOrUpdateUserByTelegram({ telegramName, telegramId }: ITelegramUser): Promise<UserTelegram | void> {
        const existUser = await this.getUserByTelegramId(telegramId);
        if (!existUser) {
            return await this.createUserByTelegram({ telegramName, telegramId });
        }
        if (existUser.telegramName != telegramName) {
            return await this.updateUserByTelegram({ telegramName, telegramId });
        }
    }

    async getUserByTelegramId(telegramId: string): Promise<UserTelegram | null> {
        const existUser = await this.userRepository.getUserByTelegramId(telegramId);
        if (!existUser) {
            return null;
        }
        if (existUser.isBan) {
            throw new Error('Доступ запрещен');
        }
        return new UserTelegramEntity(existUser);
    }

    async createUserByTelegram({ telegramName, telegramId }: ITelegramUser): Promise<UserTelegram> {
        const user = new UserTelegramEntity({ telegramName, telegramId });
        return this.userRepository.createUserByTelegram(user);
    }

    async updateUserByTelegram({ telegramName, telegramId }: ITelegramUser): Promise<UserTelegram> {
        const user = new UserTelegramEntity({ telegramName, telegramId });
        return this.userRepository.updateUserByTelegram(user);
    }

    async getUserCities(telegramId: string): Promise<CitySMEntity[]> {
        const cities: any[] = await this.userRepository.getUserCities(telegramId);
        return cities.map(city => {
            return new CitySMEntity(city.city);
        });
    }

    async addUserCity(telegramId: string, cityId: string) {
        return await this.userRepository.addUserCity(telegramId, cityId);
    }

    async deleteUserCity(telegramId: string, cityId: string) {
        return await this.userRepository.deleteUserCity(telegramId, cityId);
    }
}

```

src/module/user/entities/user-telegram.entity.ts:
```
import { UserRole, UserTelegram } from '@prisma/client';

export class UserTelegramEntity implements UserTelegram {
    telegramId: string;
    telegramName: string;
    countBonuses: number;
    role: UserRole;
    isBan: boolean;
    createdAt: Date;
    updatedAt: Date;

    constructor(user: Partial<UserTelegram>) {
        Object.assign(this, user);
        return this;
    }
}

```

src/module/user/interfaces/user-telegram.interface.ts:
```
export interface ITelegramUser {
    telegramName: string;
    telegramId: string;
}

```

src/module/webapp/webapp.controller.ts:
```
import { BadRequestException, Body, Controller, Get, Post, Req, Res } from '@nestjs/common';
import { Request, Response } from 'express';
import { TelegramService } from '../telegram/telegram.service';
import { join } from 'path';
import { ConfigService } from '@nestjs/config';
import { MirrorService } from '../mirror/mirror.service';

@Controller('webapp')
export class WebAppController {
    private DOMAIN = this.configService.getOrThrow('DOMAIN', 'http://localhost:3001');

    constructor(
        private telegramService: TelegramService,
        private configService: ConfigService,
        private mirrorService: MirrorService,
    ) {}

    @Get('auth')
    async serveAuthPage(@Res() res: Response) {
        const filePath = join(process.cwd(), 'views', 'web-app.auth.html');
        res.sendFile(filePath);
    }

    @Post('auth')
    async handleAuth(@Body() body: any, @Req() request: Request) {
        const ipAddress = Array.isArray(request.headers['x-forwarded-for'])
            ? request.headers['x-forwarded-for'][0]
            : request.headers['x-forwarded-for'] || request.ip;

        const { telegramId, accountId, id } = body;
        if (!telegramId || !ipAddress || !accountId || !id) {
            throw new BadRequestException('Не удалось получить данные.');
        }

        await this.mirrorService.updateAccountMirror(id, { accountId, userIp: ipAddress });
        const mirrorToken = await this.mirrorService.generateMirrorToken(id);
        const mirrorUrl = `${this.DOMAIN}/api/mirror/auth?token=${mirrorToken.mirrorToken}`;
        await this.telegramService.sendMessage(Number(telegramId), `Ваша ссылка на зеркало: ${mirrorUrl}`);
        return { success: true, link: mirrorUrl };
    }
}

```

src/module/webapp/webapp.module.ts:
```
import { Module } from '@nestjs/common';
import { WebAppController } from './webapp.controller';
import { TelegramModule } from '../telegram/telegram.module';
import { ConfigService } from '@nestjs/config';
import { MirrorModule } from '../mirror/mirror.module';

@Module({
    imports: [TelegramModule, MirrorModule],
    controllers: [WebAppController],
    providers: [ConfigService],
    exports: [],
})
export class WebappModule {}

```

src/module/zenno/zenno.controller.ts:
```
import { Body, Controller, Get, HttpCode, Patch } from '@nestjs/common';
import { HasZenno } from '@common/decorators/zenno.decorator';
import { ZennoService } from './zenno.service';
import { ZennoConfigDto } from './dto/config.dto';
import { ZennoConfigDtoV2 } from './dto/configV2.dto';

@Controller('zenno')
export class ZennoController {
    constructor(private zennoService: ZennoService) {}

    @HasZenno()
    @Patch('/config')
    @HttpCode(200)
    async updateZennoConfig(@Body() dto: ZennoConfigDto): Promise<ZennoConfigDto> {
        return await this.zennoService.updateZennoConfig(dto);
    }

    @HasZenno()
    @Patch('/v2/config')
    @HttpCode(200)
    async updateZennoConfigV2(@Body() dto: ZennoConfigDtoV2) {
        return await this.zennoService.updateZennoConfigV2(dto);
    }

    @HasZenno()
    @Get('/config')
    @HttpCode(200)
    async getZennoConfig(): Promise<ZennoConfigDto> {
        return await this.zennoService.getZennoConfig();
    }

    @HasZenno()
    @Get('/v2/config')
    @HttpCode(200)
    async getZennoConfigV2() {
        return await this.zennoService.getZennoConfigV2();
    }
}

```

src/module/zenno/zenno.module.ts:
```
import { Module } from '@nestjs/common';
import { ZennoController } from './zenno.controller';
import { ZennoService } from './zenno.service';
import { ZennoRepository } from './zenno.repository';

@Module({
    controllers: [ZennoController],
    providers: [ZennoService, ZennoRepository],
})
export class ZennoModule {}

```

src/module/zenno/zenno.repository.ts:
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@common/database/prisma.service';
import { Course, Todo } from '@prisma/client';

@Injectable()
export class ZennoRepository {
    constructor(private readonly prisma: PrismaService) {}

    async updateTodoActive(todo: string, active: boolean): Promise<void> {
        await this.prisma.todo.update({
            where: { todo },
            data: { active },
        });
    }

    async updateCourseActive(name: string, active: boolean): Promise<void> {
        await this.prisma.course.update({
            where: { name },
            data: { active },
        });
    }

    async getTodos(): Promise<Todo[]> {
        return this.prisma.todo.findMany();
    }

    async getCourses(): Promise<Course[]> {
        return this.prisma.course.findMany();
    }
}

```

src/module/zenno/zenno.service.ts:
```
import { Injectable } from '@nestjs/common';
import { ZennoRepository } from './zenno.repository';
import { ZennoConfigDto } from './dto/config.dto';
import { ZennoConfigDtoV2 } from './dto/configV2.dto';

@Injectable()
export class ZennoService {
    constructor(private zennoRepository: ZennoRepository) {}

    async updateZennoConfig(dto: ZennoConfigDto): Promise<ZennoConfigDto> {
        const { mobile } = dto;
        //cделать проверку на уникальное значение задания

        for (const easyItem of mobile.easy) {
            await this.zennoRepository.updateTodoActive(easyItem.todo, easyItem.active);
        }

        for (const heavyItem of mobile.heavy) {
            await this.zennoRepository.updateTodoActive(heavyItem.todo, heavyItem.active);

            for (const course of heavyItem.courses) {
                await this.zennoRepository.updateCourseActive(course.name, course.active);
            }
        }

        return await this.getZennoConfig();
    }

    async updateZennoConfigV2({ config }: ZennoConfigDtoV2) {
        const configFromDB = await this.getZennoConfigV2();
        const currentTodo = configFromDB.data.features.find(todo => todo.active);
        if (currentTodo?.id !== config.activeId) {
            for (const feature of configFromDB.data.features) {
                const active = feature.id === config.activeId;
                await this.zennoRepository.updateTodoActive(feature.id, active);
            }
        }

        for (const course of config.courses) {
            await this.zennoRepository.updateCourseActive(course.name, course.active);
        }

        return await this.getZennoConfigV2();
    }

    async getZennoConfig(): Promise<ZennoConfigDto> {
        const todos = await this.zennoRepository.getTodos();
        const coursesDB = await this.zennoRepository.getCourses();

        const todosFilters = todos.map(todo => ({
            todo: todo.todo,
            name: todo.name,
            active: todo.active,
        }));

        const easy = todosFilters.filter(todo => todo.todo !== 'course');

        const courses = coursesDB.map(todo => {
            return {
                id: todo.id,
                name: todo.name,
                active: todo.active,
                count: todo.count,
            };
        });

        const heavy = todosFilters
            .filter(todo => todo.todo === 'course')
            .map(todo => {
                if (todo.todo === 'course') {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    todo['courses'] = courses;
                }
                return todo;
            });

        return {
            mobile: {
                easy,
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-expect-error
                heavy,
            },
        };
    }

    async getZennoConfigV2() {
        const todos = await this.zennoRepository.getTodos();
        const coursesDB = await this.zennoRepository.getCourses();

        const todosMap = todos.map(todo => ({
            id: todo.todo,
            name: todo.name,
            active: todo.active,
        }));

        const courses = coursesDB.map(todo => {
            return {
                id: todo.id,
                name: todo.name,
                active: todo.active,
                count: todo.count,
            };
        });

        return {
            data: {
                features: todosMap,
                configs: {
                    courses,
                },
            },
        };
    }
}

```

src/module/zenno/dto/config.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const EasyItemSchema = z.object({
    todo: z.string(),
    name: z.string(),
    active: z.boolean(),
});

const CourseSchema = z.object({
    id: z.number(),
    name: z.string(),
    count: z.number(),
    active: z.boolean(),
});

const HeavyItemSchema = EasyItemSchema.extend({
    courses: z.array(CourseSchema),
});

const DifficultyLevelItemSchema = z.object({
    easy: z.array(EasyItemSchema),
    heavy: z.array(HeavyItemSchema),
});

const ZennoConfigSchema = z.object({
    mobile: DifficultyLevelItemSchema,
});

export namespace ZennoConfigCommand {
    export const RequestSchema = ZennoConfigSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = ZennoConfigSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class ZennoConfigDto extends createZodDto(ZennoConfigCommand.RequestSchema) {}

```

src/module/zenno/dto/configV2.dto.ts:
```
import { createZodDto } from 'nestjs-zod';
import { z } from 'zod';

const CourseSchema = z.object({
    id: z.number(),
    name: z.string(),
    count: z.number(),
    active: z.boolean(),
});

const ItemSchema = z.object({
    activeId: z.string(),
    courses: z.array(CourseSchema),
});

const ZennoConfigSchema = z.object({
    config: ItemSchema,
});

export namespace ZennoConfigCommand {
    export const RequestSchema = ZennoConfigSchema;
    export type Request = z.infer<typeof RequestSchema>;

    export const ResponseSchema = ZennoConfigSchema;
    export type Response = z.infer<typeof ResponseSchema>;
}

export class ZennoConfigDtoV2 extends createZodDto(ZennoConfigCommand.RequestSchema) {}

```

views/order.hbs:
```
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Спортмастер — спортивный магазин для всей семьи!</title>
    <link rel="icon" href="/img/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/css/styles.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="main">

    <div class="header">
        <a class="back-arrow" href="#">
            <img src="/img/arrow.svg" alt="Назад">
        </a>
        <p class="text17-black order-number">
            Заказ №{{order.number}}
        </p>
    </div>

    <div class="date-create">
        <p class="date-create-item text14-grey">
            Создан {{formatDate order.createdDate}}
        </p>
        <a class="button-check" id="check-button" style="background-color: {{order.status.backgroundColor}}; color: {{order.status.textColor}}">
            <span id="check-button-text">{{trim order.status.statusText}}</span>
        </a>
    </div>

    <div class="about-address">
        <div class="about-address-info" id="about-address-info-id">
            <p class="type-order text16-black">
                {{order.deliveryInfo.type.title}}
            </p>
            <p class="address text14-black">
                {{order.deliveryInfo.intPickup.shopAddress}}
            </p>
            <p class="operating-mode text14-black" id="operating-mode-id">
                Ежедневно: с 10:00 до 22:00
            </p>
        </div>
        <div class="button-route" id="button-route-id">
            <img src="/img/route.svg" alt="Назад" width="20" height="20">
        </div>
    </div>
    <div id="trek-number-block" style="display: {{#if order.deliveryInfo.delivery}}block{{else}}none{{/if}}">
        <p class="type-order text16-black">
            Трек-номер
        </p>
        <div id="trek-number-link-block">
            <p class="text14-black">
                {{extractTrackNumber order.deliveryInfo.delivery.trackNumbers.[0]}}
            </p>
            <a href="{{order.deliveryInfo.delivery.trackNumbers.[0]}}" target="_blank" id="trek-number-link">
                <img src="/img/link.svg" alt="Ссылка" width="20" height="20">
            </a>
        </div>
    </div>
    <div class="date-delivery">
        <p class="text16-black">
            Дата доставки
        </p>
        <p class="text14-black">
            {{formatDateRange order.deliveryInfo.planReceivingDateTimeFrom order.deliveryInfo.receivingDateTo}}
        </p>
    </div>

    <div class="payment-method-info">
        <p class="text16-black">
            Способ оплаты
        </p>
        <div class="payment-method">
            <p class="text14-black">
                {{order.payment.paymentMethod.name}}
            </p>
            <p class="text14-orange">
                {{getPaymentStatus order.payment.isPayed}}
            </p>
        </div>
    </div>

    <div class="about-price">
        <div class="count-items">
            <p class="text14-grey">
                {{order.items.length}}
                {{getItemName order.items.length}}
            </p>
            <p class="price-items text14-grey">
                {{digitSeparator (divide order.totals.totalCatalogCost.value 100)}} ₽
            </p>
        </div>
        <div class="discount-bonus" id="catalog-discount-block" style="display: {{#if order.totals.catalogDiscount.value}}flex{{else}}none{{/if}}">
            <p class="text14-grey">
                Скидка
            </p>
            <p class="count-bonus text14-grey">
                -{{digitSeparator (divide order.totals.catalogDiscount.value 100)}} ₽
            </p>
        </div>
        <div class="discount-bonus" id="promocode-discount-block" style="display: {{#if order.totals.promocodeDiscount.value}}flex{{else}}none{{/if}}">
            <p class="text14-grey">
                Скидка по промокоду
            </p>
            <p class="count-bonus text14-grey">
                -{{digitSeparator (divide order.totals.promocodeDiscount.value 100)}} ₽
            </p>
        </div>
        <div class="discount-bonus" id="total-bonuses-used-block" style="display: {{#if order.totals.totalBonusesUsed.value}}flex{{else}}none{{/if}}">
            <p class="text14-grey">Оплата бонусами</p>
            <p class="count-bonus text14-grey">-{{digitSeparator (divide order.totals.totalBonusesUsed.value 100)}} ₽</p>
        </div>

        <div class="total-price">
            <p class="text14-black-med">
                Итого
            </p>
            <p class="count-total-price text14-black-med">{{digitSeparator (divide order.totals.totalCost.value 100)}} ₽</p>
        </div>
    </div>

    <div class="about-buyer">
        <p class="text16-black">
            Получатель
        </p>
        <p class="fio text14-black">
            {{order.deliveryInfo.receiver.fio}}
        </p>
        <p class="email-buyer text14-black">
            {{order.deliveryInfo.receiver.email}}
        </p>
        <p class="tel-number text14-black">
            +7 {{formatPhone order.deliveryInfo.receiver.phone.nationalNumber}}
        </p>
    </div>

    <div class="about-order">
        <p class="about-order-count text18-black">
            {{order.items.length}}
            {{getItemName order.items.length}}
            в заказе
        </p>
        <ul class="about-order-section">
            {{#each order.items}}
                <li class="order-section">
                    <img class="image_item" src="{{removeImagePath this.image}}" alt="{{this.name}}">
                    <div class="about-order-info">
                        <div class="wrapper-order-info">
                            <p class="text12-black">{{this.name}}</p>
                            <ul class="param-order text12-grey">
                                {{#each this.params}}
                                    <li>{{this.name}}: {{this.value}}</li>
                                {{/each}}
                            </ul>
                        </div>
                        <div class="about-order-info-price">
                            <p class="price-item text14-black-bold">{{digitSeparator (divide this.totalPrice.value 100)}} ₽</p>
                            <p class="price-item-discount text12-grey">{{digitSeparator (divide this.priceWoDiscount.value 100)}} ₽</p>
                            <p class="count-item text12-grey">{{this.amount}} шт.</p>
                        </div>
                    </div>
                </li>
            {{/each}}
        </ul>
    </div>
    <div class="buttons-footer">
        <div class="button-ask" id="electronic-receipt" style="display: {{#if (or (equals order.status.status 'issued') (equals order.status.status 'delivered'))}}block{{else}}none{{/if}}">
            <p>Электронный чек</p>
        </div>
        <div class="button-ask">
            <p>Задать вопрос по заказу</p>
        </div>
        <div class="button-ask" id="cancelled-order" style="display: {{#if (equals order.status.status 'cancelled')}}none{{else}}block{{/if}}">
            <p>Отменить заказ</p>
        </div>
    </div>
    <div class="footer-menu">
        <ul>
            <li class="Home">
                <img class="grey-wrap" src="/img/home.svg" width="19" height="19">
            </li>
            <li class="Catalog">
                <img class="grey-wrap menu-svg" src="/img/search.svg">
            </li>
            <li class="Menu">
                <img src="/img/menu.png" width="19" height="19">
            </li>
            <li class="Cart">
                <img class="grey-wrap" src="/img/cart.svg" width="24" height="24">
            </li>
            <li class="Profile">
                <img class="grey-wrap current-link" src="/img/person.svg" width="19" height="19">
            </li>
        </ul>
    </div>
</div>
</body>
</html>

```

views/web-app.auth.html:
```
<!DOCTYPE html>
<html>
<head>
    <title>Telegram Web App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<form id="authForm">
    <input type="text" id="accountId" placeholder="Введите номер аккаунта" required>
    <button type="submit" >Авторизоваться</button>
</form>
<div id="link-container" style="display: none">

    <a id="mirrorLink" href="" target="_blank">Перейти</a>
</div>

<script>
    const authForm = document.getElementById('authForm');
    const tg = window.Telegram.WebApp;
    const linkContainer = document.getElementById('link-container');
    const mirrorLink = document.getElementById('mirrorLink');
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');

    authForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const accountId = document.getElementById('accountId').value;
        const data = {
            telegramId: tg.initDataUnsafe.user.id,
            accountId: accountId,
            id: id
        };

        fetch('/api/webapp/auth', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        })
            .then((response) => response.json())
            .then((result) => {
                if (result.success) {
                    mirrorLink.href = result.link;
                    linkContainer.style.display = 'block';
                } else {
                    alert('Ошибка авторизации: ' + result.message);
                }
            });
    });
</script>
</body>
</html>
```
